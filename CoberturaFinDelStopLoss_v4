//+------------------------------------------------------------------+
//|                                            CoberturaEspecial.mq5 |
//|                                      Copyright 2024, YourCompany |
//|                                             https://www.mql5.com |
//|                        Elaborado por Jhoan Daniel Ocoro Hernandez|
//+------------------------------------------------------------------+
#property copyright "Copyright 2024"
#property link      "https://www.mql5.com"
#property version   "4.0"
#property strict

#include <Controls\Dialog.mqh>
#include <Controls\Button.mqh>
#include <Controls\Edit.mqh>
#include <Controls\Label.mqh>
#include <Controls\Panel.mqh>
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\OrderInfo.mqh>

//+------------------------------------------------------------------+
//| Variables globales para el sistema de trading                    |
//+------------------------------------------------------------------+
CTrade trade;
CPositionInfo posicionInfo;
COrderInfo ordenInfo;

// Variables del sistema de cobertura
double g_precio_entrada1 = 0;
double g_precio_entrada2 = 0;
double g_lote_inicial = 0;
double g_tp1_ticks = 0;
double g_tp2_ticks = 0;
double g_distancia_ticks = 0;
int g_numero_magico = 12345;
bool g_sistema_activo = false;
ENUM_ORDER_TYPE g_tipo_inicial;
int g_nivel_actual = 0;

// Variables para precios de cobertura FIJOS
double g_precio_cobertura1_fijo = 0;  // TP fijo de Entrada#1
double g_precio_cobertura2_fijo = 0;  // TP fijo de Entrada#2

// Variables para cierre virtual
int g_nivel_activacion_cierre = 0;
double g_ganancia_objetivo = 0;
// Precios de cobertura FIJOS (calculados una sola vez al inicio)
double g_precio_cobertura_E1 = 0;  // TP fijo de Entrada#1
double g_precio_cobertura_E2 = 0;  // TP fijo de Entrada#2

// ============== VARIABLES GLOBALES PARA ROLL-OFF ==============
bool g_roll_off_activo = false;           // Indica si el sistema Roll-Off est√° activo
double g_precio_activacion_roll_off = 0;  // Precio donde se activ√≥ la neutralizaci√≥n
int g_ticks_umbral_roll_off = 77;         // Umbral de movimiento favorable para Roll-Off (77 ticks = 7.7 pips)
datetime g_ultimo_roll_off = 0;           // Timestamp del √∫ltimo Roll-Off ejecutado
datetime g_tiempo_primera_entrada = 0;    // NUEVA: Marca el inicio de la secuencia actual



//+------------------------------------------------------------------+
//| Calcular vol√∫menes totales BUY y SELL                           |
//+------------------------------------------------------------------+
void CalcularVolumenesTotales(double &volumenBuyTotal, double &volumenSellTotal)
{
   volumenBuyTotal = 0;
   volumenSellTotal = 0;
   
   CPositionInfo posInfo;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            double volumen = posInfo.Volume();
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            // Determinar tipo real seg√∫n nivel
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            if(tipoReal == ORDER_TYPE_BUY)
               volumenBuyTotal += volumen;
            else
               volumenSellTotal += volumen;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Verificar si hay neutralizaci√≥n de vol√∫menes                     |
//+------------------------------------------------------------------+
bool VerificarNeutralizacion()
{
   double volBuy = 0, volSell = 0;
   CalcularVolumenesTotales(volBuy, volSell);
   
   double diferencia = MathAbs(volBuy - volSell);
   double minVol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   
   // Se considera neutralizado si la diferencia es menor al volumen m√≠nimo
   return (diferencia < minVol * 2);
}

//+------------------------------------------------------------------+
//| Calcular P&L actual de todas las posiciones                     |
//+------------------------------------------------------------------+
double CalcularPLTotal()
{
   double plTotal = 0;
   CPositionInfo posInfo;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            plTotal += posInfo.Profit() + posInfo.Swap() + posInfo.Commission();
         }
      }
   }
   
   return plTotal;
}

//+------------------------------------------------------------------+
//| Calcular P&L separado por tipo (BUY/SELL)                       |
//+------------------------------------------------------------------+
void CalcularPLPorTipo(double &plBuy, double &plSell)
{
   plBuy = 0;
   plSell = 0;
   
   CPositionInfo posInfo;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            double pl = posInfo.Profit() + posInfo.Swap() + posInfo.Commission();
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            // Determinar tipo real seg√∫n nivel
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            if(tipoReal == ORDER_TYPE_BUY)
               plBuy += pl;
            else
               plSell += pl;
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Ejecutar Roll-Off - VERSI√ìN SIMPLIFICADA SIN CICLOS             |
//| Cada vez que se alcanza el umbral, lee TODA la secuencia        |
//| No necesita contadores ni acumulados                            |
//+------------------------------------------------------------------+
bool EjecutarRollOff()
{
   Print("========================================");
   Print("========== EJECUTANDO ROLL-OFF ==========");
   
   CTrade tradeRollOff;
   CPositionInfo posInfo;
   tradeRollOff.SetExpertMagicNumber(g_numero_magico);
   
   // Calcular P&L por tipo
   double plBuy = 0, plSell = 0;
   CalcularPLPorTipo(plBuy, plSell);
   
   Print("P&L BUY: ", DoubleToString(plBuy, 2), " | P&L SELL: ", DoubleToString(plSell, 2));
   
   bool buyGanando = (plBuy > plSell);
   Print("Lado ganador: ", (buyGanando ? "BUY" : "SELL"));
   
   // ========== PASO 1: CERRAR PERDEDORAS Y LEER TODA LA SECUENCIA ==========
   Print("========================================");
   Print(">>> PASO 1: CERRANDO PERDEDORAS <<<");
   
   ulong ticketsCerrar[];
   int contadorTickets = 0;
   
   // Identificar perdedoras
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esPerdedora = (!buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                              (buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esPerdedora)
            {
               ulong ticket = posInfo.Ticket();
               double volumen = posInfo.Volume();
               
               Print("  Identificada #", ticket, " Vol:", DoubleToString(volumen, 2));
               
               ArrayResize(ticketsCerrar, contadorTickets + 1);
               ticketsCerrar[contadorTickets] = ticket;
               contadorTickets++;
            }
         }
      }
   }
   
   // CERRAR todas las perdedoras
   for(int i = 0; i < contadorTickets; i++)
   {
      ulong ticket = ticketsCerrar[i];
      
      if(tradeRollOff.PositionClose(ticket))
      {
         Print("  ‚úì Cerrada #", ticket);
         Sleep(100);
      }
   }
   
   Sleep(200);
   
   // LEER TODAS LAS ENTRADAS CERRADAS DE LA SECUENCIA ACTUAL
   Print("--- Leyendo TODA la secuencia desde inicio ---");
   
   double profitTodasCerradas = 0;
   int cantidadCerradas = 0;
   
   datetime desde = g_tiempo_primera_entrada; // Desde la primera entrada de la secuencia
   datetime hasta = TimeCurrent();
   
   if(HistorySelect(desde, hasta))
   {
      int totalDeals = HistoryDealsTotal();
      
      for(int i = totalDeals - 1; i >= 0; i--)
      {
         ulong dealTicket = HistoryDealGetTicket(i);
         
         if(dealTicket > 0)
         {
            long magic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
            string symbol = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
            long dealEntry = HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
            
            if(magic == g_numero_magico && symbol == _Symbol && dealEntry == DEAL_ENTRY_OUT)
            {
               double profitReal = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
               double swapReal = HistoryDealGetDouble(dealTicket, DEAL_SWAP);
               double volumen = HistoryDealGetDouble(dealTicket, DEAL_VOLUME);
               ulong positionTicket = HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID);
               
               Print("  Deal #", dealTicket, " Pos #", positionTicket);
               Print("    Profit: ", DoubleToString(profitReal, 2));
               Print("    Swap: ", DoubleToString(swapReal, 2));
               Print("    Volumen: ", DoubleToString(volumen, 2));
               
               profitTodasCerradas += profitReal + swapReal;
               cantidadCerradas++;
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("Total entradas cerradas: ", cantidadCerradas);
   Print("PROFIT TODAS CERRADAS: ", DoubleToString(profitTodasCerradas, 2));
   
   // ========== PASO 2: COMISIONES DE TODA LA SECUENCIA ==========
   Print("========================================");
   Print(">>> PASO 2: COMISIONES TOTALES <<<");
   
   double comisionesTotales = 0;
   
   // Comisiones de TODAS las cerradas
   if(HistorySelect(desde, hasta))
   {
      int totalDeals = HistoryDealsTotal();
      
      for(int i = totalDeals - 1; i >= 0; i--)
      {
         ulong dealTicket = HistoryDealGetTicket(i);
         
         if(dealTicket > 0)
         {
            long magic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
            string symbol = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
            long dealEntry = HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
            
            if(magic == g_numero_magico && symbol == _Symbol && dealEntry == DEAL_ENTRY_OUT)
            {
               double volumen = HistoryDealGetDouble(dealTicket, DEAL_VOLUME);
               double comision = CalcularComisionPepperstone(volumen, _Symbol);
               comisionesTotales += comision;
               
               ulong positionTicket = HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID);
               Print("  Comisi√≥n cerrada #", positionTicket, ": ", DoubleToString(comision, 2));
            }
         }
      }
   }
   
   // Comisiones de TODAS las abiertas
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            double volumen = posInfo.Volume();
            double comision = CalcularComisionPepperstone(volumen, _Symbol);
            comisionesTotales += comision;
            Print("  Comisi√≥n abierta #", posInfo.Ticket(), ": ", DoubleToString(comision, 2));
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("COMISIONES TOTALES: ", DoubleToString(comisionesTotales, 2));
   
   // ========== PASO 3: CALCULAR P&L TOTAL ==========
   Print("========================================");
   Print(">>> PASO 3: P&L TOTAL <<<");
   
   double plTotal = profitTodasCerradas - comisionesTotales;
   
   Print("PROFIT TODAS CERRADAS: ", DoubleToString(profitTodasCerradas, 2));
   Print("COMISIONES TOTALES: -", DoubleToString(comisionesTotales, 2));
   Print("----------------------------------------------");
   Print("P&L TOTAL: ", DoubleToString(plTotal, 2));
   
   // ========== PASO 4: CALCULAR TP ==========
   Print("========================================");
   Print(">>> PASO 4: CALCULAR TP <<<");
   
   // Ganancia BRUTA necesaria
   double gananciaBrutaNecesaria = MathAbs(plTotal) + g_ganancia_objetivo;
   
   Print("P&L TOTAL: ", DoubleToString(plTotal, 2));
   Print("GananciaM: ", DoubleToString(g_ganancia_objetivo, 2));
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   
   // Cancelar √≥rdenes anteriores
   COrderInfo ordInfo;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(ordInfo.SelectByIndex(i))
      {
         if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
         {
            string com = ordInfo.Comment();
            if(StringFind(com, "RollOff_Proteccion") >= 0)
            {
               tradeRollOff.OrderDelete(ordInfo.Ticket());
            }
         }
      }
   }
   
   // ANALIZAR GANADORAS
   double punto = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   double volumenTotalGanadoras = 0;
   ENUM_ORDER_TYPE tipoGanadoras = ORDER_TYPE_BUY;
   int contadorGanadoras = 0;
   int nivelMasAlto = 0;
   double precioAperturaUltimaGanadora = 0;
   
   Print("--- Analizando ganadoras ---");
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                            (!buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esGanadora)
            {
               ulong ticket = posInfo.Ticket();
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               
               Print("  Ganadora #", ticket, " Nivel:", nivel, " Vol:", DoubleToString(volumen, 2));
               Print("    Precio apertura: ", DoubleToString(precioApertura, digits));
               
               volumenTotalGanadoras += volumen;
               tipoGanadoras = tipoReal;
               contadorGanadoras++;
               
               if(nivel > nivelMasAlto)
               {
                  nivelMasAlto = nivel;
                  precioAperturaUltimaGanadora = precioApertura;
               }
            }
         }
      }
   }
   
   if(contadorGanadoras == 0)
   {
      Print("‚úó ERROR: No hay ganadoras");
      return false;
   }
   
   // Calcular precio promedio ponderado de apertura
   double sumatoriaPrecioVolumen = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                            (!buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esGanadora)
            {
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               sumatoriaPrecioVolumen += precioApertura * volumen;
            }
         }
      }
   }
   
   double precioPromedioApertura = sumatoriaPrecioVolumen / volumenTotalGanadoras;
   
   // ========== EXTRAER VALOR DEL PUNTO DESDE POSICIONES REALES ==========
   double valorPuntoPorLote = 0;
   bool valorObtenido = false;
   
   double precioActualCalculo;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      precioActualCalculo = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   else
      precioActualCalculo = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                            (!buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esGanadora)
            {
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               double profit = posInfo.Profit();
               
               // Calcular diferencia en precio
               double diferenciaPrecio;
               if(tipoReal == ORDER_TYPE_BUY)
                  diferenciaPrecio = precioActualCalculo - precioApertura;
               else
                  diferenciaPrecio = precioApertura - precioActualCalculo;
               
               // Calcular cu√°ntos puntos hay
               double puntos = diferenciaPrecio / punto;
               
               // Solo usar si hay movimiento significativo
               if(MathAbs(puntos) >= 1.0 && MathAbs(profit) >= 0.01)
               {
                  valorPuntoPorLote = profit / puntos / volumen;
                  
                  Print("Extrayendo valor del punto desde posici√≥n #", posInfo.Ticket());
                  Print("  Precio apertura: ", DoubleToString(precioApertura, digits));
                  Print("  Precio actual: ", DoubleToString(precioActualCalculo, digits));
                  Print("  Diferencia puntos: ", DoubleToString(puntos, 1));
                  Print("  Profit actual: ", DoubleToString(profit, 2));
                  Print("  Volumen: ", DoubleToString(volumen, 2));
                  Print("  ‚Üí Valor 1 punto/lote: ", DoubleToString(valorPuntoPorLote, 2));
                  
                  valorObtenido = true;
                  break;
               }
            }
         }
      }
   }
   
   // Fallback
   if(!valorObtenido || MathAbs(valorPuntoPorLote) < 0.1)
   {
      Print("‚ö† WARNING: No se pudo extraer valor del punto");
      Print("‚ö† Usando valor aproximado: 8.5");
      valorPuntoPorLote = 8.5;
   }
   
   Print("----------------------------------------------");
   Print(">>> VALOR DEL PUNTO <<<");
   Print("Valor 1 punto (1 lote): ", DoubleToString(valorPuntoPorLote, 2));
   
   // Calcular puntos necesarios
   double puntosNecesarios = gananciaBrutaNecesaria / (volumenTotalGanadoras * valorPuntoPorLote);
   double diferenciaNecesaria = puntosNecesarios * punto;
   
   double precioTP;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      precioTP = precioPromedioApertura + diferenciaNecesaria;
   else
      precioTP = precioPromedioApertura - diferenciaNecesaria;
   
   precioTP = NormalizeDouble(precioTP, digits);
   
   Print("Volumen total ganadoras: ", DoubleToString(volumenTotalGanadoras, 2));
   Print("Precio promedio apertura: ", DoubleToString(precioPromedioApertura, digits));
   Print("Puntos necesarios: ", DoubleToString(puntosNecesarios, 1));
   Print("Diferencia necesaria: ", DoubleToString(diferenciaNecesaria, digits));
   Print("TP calculado: ", DoubleToString(precioTP, digits));
   
   // Verificar si el precio actual ya super√≥ el TP
   Print("Precio actual: ", DoubleToString(precioActualCalculo, digits));
   
   bool tpYaSuperado = false;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      tpYaSuperado = (precioActualCalculo >= precioTP);
   else
      tpYaSuperado = (precioActualCalculo <= precioTP);
   
   if(tpYaSuperado)
   {
      Print("========================================");
      Print(">>> TP YA SUPERADO <<<");
      Print(">>> Cerrando TODAS las posiciones");
      Print("========================================");
      
      // Cerrar todas
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         if(posInfo.SelectByIndex(i))
         {
            if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
            {
               ulong ticket = posInfo.Ticket();
               if(tradeRollOff.PositionClose(ticket))
               {
                  Print("  ‚úì Cerrada #", ticket);
                  Sleep(50);
               }
            }
         }
      }
      
      // Cancelar √≥rdenes
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         if(ordInfo.SelectByIndex(i))
         {
            if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
            {
               tradeRollOff.OrderDelete(ordInfo.Ticket());
            }
         }
      }
      
      Print(">>> OBJETIVO ALCANZADO");
      return true;
   }
   
   // ========== PASO 5: CONFIGURAR TP Y ORDEN PROTECCI√ìN ==========
   Print("========================================");
   Print(">>> PASO 5: CONFIGURAR TP <<<");
   
   int tpsConfigurados = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                            (!buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esGanadora)
            {
               ulong ticket = posInfo.Ticket();
               
               if(tradeRollOff.PositionModify(ticket, 0, precioTP))
               {
                  Print("  ‚úì TP configurado #", ticket);
                  tpsConfigurados++;
               }
               else
               {
                  Print("  ‚úó Error TP #", ticket);
               }
            }
         }
      }
   }
   
   Print("TPs configurados: ", tpsConfigurados);
   

//+------------------------------------------------------------------+
//| PASO 6: AFINAR TP - VERSI√ìN DEFINITIVA CON B√öSQUEDA EXHAUSTIVA  |
//| GARANTIZA resultado positivo - NUNCA acepta resultado negativo  |
//+------------------------------------------------------------------+

   // ========== PASO 6: AFINAR TP ==========
   Print("========================================");
   Print(">>> PASO 6: AFINAR TP <<<");
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   Print("GananciaM objetivo: ", DoubleToString(g_ganancia_objetivo, 2));
   
   // Obtener valor del punto EXACTO de MT5
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double valorPuntoExacto = (punto / tickSize) * tickValue;
   
   Print("Valor punto EXACTO (MT5): ", DoubleToString(valorPuntoExacto, 4));
   
   // Calcular profit esperado usando VALOR EXACTO del punto
   double profitTotalEsperado = 0;
   int posicionesConTP = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            string comentario = posInfo.Comment();
            int nivel = 0;
            
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal;
            if(nivel % 2 == 1)
               tipoReal = g_tipo_inicial;
            else
               tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
            
            bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                            (!buyGanando && tipoReal == ORDER_TYPE_SELL);
            
            if(esGanadora)
            {
               double tp = posInfo.TakeProfit();
               if(tp != 0)
               {
                  double precioApertura = posInfo.PriceOpen();
                  double volumen = posInfo.Volume();
                  
                  double diferenciaTP;
                  if(tipoReal == ORDER_TYPE_BUY)
                     diferenciaTP = tp - precioApertura;
                  else
                     diferenciaTP = precioApertura - tp;
                  
                  double puntosTP = diferenciaTP / punto;
                  double profitEsperado = puntosTP * volumen * valorPuntoExacto;
                  
                  Print("  Pos #", posInfo.Ticket(), " Vol:", DoubleToString(volumen, 2));
                  Print("    TP: ", DoubleToString(tp, digits), " Puntos: ", DoubleToString(puntosTP, 1));
                  Print("    Profit esperado: ", DoubleToString(profitEsperado, 2));
                  
                  profitTotalEsperado += profitEsperado;
                  posicionesConTP++;
               }
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("PROFIT TOTAL esperado (TP actual): ", DoubleToString(profitTotalEsperado, 2));
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   
   double diferencia = profitTotalEsperado - gananciaBrutaNecesaria;
   Print("Diferencia: ", DoubleToString(diferencia, 3));
   
   // C√ÅLCULO CR√çTICO: Resultado proyectado
   double resultadoProyectado = g_ganancia_objetivo + diferencia;
   Print("Resultado proyectado: ", DoubleToString(resultadoProyectado, 3));
   
   // ========== DECISI√ìN CR√çTICA ==========
   bool peligroCritico = (resultadoProyectado <= 0.005);
   
   if(peligroCritico)
   {
      Print("========================================");
      Print("üö® PELIGRO CR√çTICO DETECTADO");
      Print("   Resultado proyectado: ", DoubleToString(resultadoProyectado, 3));
      Print("   ¬°Resultado ser√≠a NEGATIVO o CERO!");
      Print("   MODO EMERGENCIA: B√∫squeda exhaustiva");
      Print("========================================");
   }
   
   // Ajustar si: peligro cr√≠tico O diferencia > 0.015
   if(peligroCritico || MathAbs(diferencia) > 0.015)
   {
      Print(">>> Iniciando b√∫squeda de TP √≥ptimo...");
      
      double mejorTP = precioTP;
      double mejorResultado = resultadoProyectado;
      int iteracionMejor = 0;
      bool tpSeguroEncontrado = false;
      
      int rangoInicio, rangoFin;
      
      if(peligroCritico)
      {
         // MODO EMERGENCIA: B√∫squeda exhaustiva
         rangoInicio = 1;  // Solo hacia adelante (m√°s profit)
         rangoFin = 100;   // Hasta 100 puntos
         Print("MODO EMERGENCIA: B√∫squeda de i=", rangoInicio, " a ", rangoFin);
         Print("Objetivo: Encontrar resultado POSITIVO (> 0.01)");
      }
      else
      {
         // Modo normal
         rangoInicio = -10;
         rangoFin = 10;
         Print("Modo est√°ndar: B√∫squeda de i=", rangoInicio, " a ", rangoFin);
      }
      
      for(int i = rangoInicio; i <= rangoFin; i++)
      {
         double tpPrueba;
         if(tipoGanadoras == ORDER_TYPE_BUY)
            tpPrueba = precioTP + (i * punto);
         else
            tpPrueba = precioTP - (i * punto);
         
         tpPrueba = NormalizeDouble(tpPrueba, digits);
         
         // Calcular profit con este TP
         double profitConEstTP = 0;
         
         for(int j = 0; j < PositionsTotal(); j++)
         {
            if(posInfo.SelectByIndex(j))
            {
               if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
               {
                  string comentario = posInfo.Comment();
                  int nivel = 0;
                  
                  if(StringFind(comentario, "Nivel_") >= 0)
                  {
                     nivel = (int)StringToInteger(StringSubstr(comentario, 6));
                  }
                  
                  ENUM_ORDER_TYPE tipoReal;
                  if(nivel % 2 == 1)
                     tipoReal = g_tipo_inicial;
                  else
                     tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
                  
                  bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                                  (!buyGanando && tipoReal == ORDER_TYPE_SELL);
                  
                  if(esGanadora)
                  {
                     double precioApertura = posInfo.PriceOpen();
                     double volumen = posInfo.Volume();
                     
                     double diferenciaTP;
                     if(tipoReal == ORDER_TYPE_BUY)
                        diferenciaTP = tpPrueba - precioApertura;
                     else
                        diferenciaTP = precioApertura - tpPrueba;
                     
                     double puntosTP = diferenciaTP / punto;
                     double profitEsperado = puntosTP * volumen * valorPuntoExacto;
                     
                     profitConEstTP += profitEsperado;
                  }
               }
            }
         }
         
         double diferenciaConEstTP = profitConEstTP - gananciaBrutaNecesaria;
         double resultadoConEstTP = g_ganancia_objetivo + diferenciaConEstTP;
         
         // Logs estrat√©gicos
         if(peligroCritico)
         {
            // En modo emergencia: mostrar cada 5 o primeros 10
            if(i <= 10 || i % 5 == 0)
            {
               Print("  i=", i, " TP:", DoubleToString(tpPrueba, digits),
                     " Resultado:", DoubleToString(resultadoConEstTP, 3));
            }
         }
         else
         {
            // En modo normal: cada 5
            if(i % 5 == 0)
            {
               Print("  i=", i, " TP:", DoubleToString(tpPrueba, digits),
                     " Dif:", DoubleToString(diferenciaConEstTP, 3),
                     " Resultado:", DoubleToString(resultadoConEstTP, 3));
            }
         }
         
         // CRITERIOS DE SELECCI√ìN
         if(peligroCritico)
         {
            // MODO EMERGENCIA: Primera opci√≥n con resultado POSITIVO >= 0.01
            if(resultadoConEstTP >= 0.01 && !tpSeguroEncontrado)
            {
               mejorTP = tpPrueba;
               mejorResultado = resultadoConEstTP;
               iteracionMejor = i;
               tpSeguroEncontrado = true;
               
               Print("========================================");
               Print("‚úÖ TP SEGURO ENCONTRADO");
               Print("   Iteraci√≥n: ", i);
               Print("   TP: ", DoubleToString(mejorTP, digits));
               Print("   Resultado proyectado: ", DoubleToString(mejorResultado, 3));
               Print("========================================");
               
               break;  // Salir inmediatamente
            }
         }
         else
         {
            // MODO NORMAL: Buscar menor diferencia absoluta
            if(MathAbs(diferenciaConEstTP) < MathAbs(mejorResultado - g_ganancia_objetivo))
            {
               mejorTP = tpPrueba;
               mejorResultado = resultadoConEstTP;
               iteracionMejor = i;
            }
         }
      }
      
      // VERIFICACI√ìN FINAL
      if(peligroCritico && !tpSeguroEncontrado)
      {
         Print("========================================");
         Print("‚ö†Ô∏è ADVERTENCIA CR√çTICA");
         Print("   No se encontr√≥ TP seguro en 100 puntos");
         Print("   Usando TP extremo como √∫ltimo recurso");
         
         // √öltimo recurso: TP MUY lejano (garantiza profit alto)
         if(tipoGanadoras == ORDER_TYPE_BUY)
            mejorTP = precioTP + (100 * punto);
         else
            mejorTP = precioTP - (100 * punto);
         
         mejorTP = NormalizeDouble(mejorTP, digits);
         
         Print("   TP √∫ltimo recurso: ", DoubleToString(mejorTP, digits));
         Print("   Esto garantiza resultado muy positivo");
         Print("========================================");
      }
      
      Print("----------------------------------------------");
      Print(">>> RESULTADO DE B√öSQUEDA <<<");
      Print("TP anterior: ", DoubleToString(precioTP, digits));
      Print("TP √≥ptimo: ", DoubleToString(mejorTP, digits));
      Print("Iteraci√≥n: ", iteracionMejor);
      Print("Resultado FINAL proyectado: ", DoubleToString(mejorResultado, 3));
      
      double cambio = MathAbs(mejorTP - precioTP);
      double cambioEnPuntos = cambio / punto;
      Print("Cambio: ", DoubleToString(cambioEnPuntos, 1), " puntos");
      
      // APLICAR si es diferente
      if(mejorTP != precioTP)
      {
         Print(">>> Aplicando TP √≥ptimo...");
         
         int tpsAjustados = 0;
         for(int i = 0; i < PositionsTotal(); i++)
         {
            if(posInfo.SelectByIndex(i))
            {
               if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
               {
                  string comentario = posInfo.Comment();
                  int nivel = 0;
                  
                  if(StringFind(comentario, "Nivel_") >= 0)
                  {
                     nivel = (int)StringToInteger(StringSubstr(comentario, 6));
                  }
                  
                  ENUM_ORDER_TYPE tipoReal;
                  if(nivel % 2 == 1)
                     tipoReal = g_tipo_inicial;
                  else
                     tipoReal = (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
                  
                  bool esGanadora = (buyGanando && tipoReal == ORDER_TYPE_BUY) || 
                                  (!buyGanando && tipoReal == ORDER_TYPE_SELL);
                  
                  if(esGanadora)
                  {
                     ulong ticket = posInfo.Ticket();
                     
                     if(tradeRollOff.PositionModify(ticket, 0, mejorTP))
                     {
                        Print("  ‚úì TP ajustado #", ticket, " ‚Üí ", DoubleToString(mejorTP, digits));
                        tpsAjustados++;
                     }
                     else
                     {
                        Print("  ‚úó Error ajustando #", ticket, " Error:", GetLastError());
                     }
                  }
               }
            }
         }
         
         Print("TPs ajustados: ", tpsAjustados);
         precioTP = mejorTP;
      }
      else
      {
         Print(">>> TP actual es √≥ptimo");
      }
   }
   else
   {
      Print(">>> Diferencia aceptable, no se requiere ajuste");
      Print(">>> Resultado proyectado: ", DoubleToString(resultadoProyectado, 3), " ‚úì");
   }
   
   Print("========================================");




   // ORDEN PROTECCI√ìN
   Print("----------------------------------------------");
   Print(">>> ORDEN PROTECCI√ìN NEUTRALIZADORA <<<");
   
   double precioOrdenPendiente;
   ENUM_ORDER_TYPE tipoOrdenPendiente;
   
   if(tipoGanadoras == ORDER_TYPE_BUY)
   {
      precioOrdenPendiente = precioActualCalculo - (77 * punto);
      tipoOrdenPendiente = ORDER_TYPE_SELL_STOP;
   }
   else
   {
      precioOrdenPendiente = precioActualCalculo + (77 * punto);
      tipoOrdenPendiente = ORDER_TYPE_BUY_STOP;
   }
   
   precioOrdenPendiente = NormalizeDouble(precioOrdenPendiente, digits);
   
   Print("Tipo: ", (tipoOrdenPendiente == ORDER_TYPE_BUY_STOP ? "BUY STOP" : "SELL STOP"));
   Print("Volumen: ", DoubleToString(volumenTotalGanadoras, 2));
   Print("Precio: ", DoubleToString(precioOrdenPendiente, digits));
   
   if(tradeRollOff.OrderOpen(_Symbol, tipoOrdenPendiente, volumenTotalGanadoras, 0, 
                      precioOrdenPendiente, 0, 0, 
                      ORDER_TIME_GTC, 0, 
                      "RollOff_Proteccion"))
   {
      Print("‚úì Orden protecci√≥n #", tradeRollOff.ResultOrder());
   }
   
   // PRECIO REFERENCIA
   Print("----------------------------------------------");
   Print(">>> PRECIO REFERENCIA <<<");
   
   if(MathAbs(g_precio_activacion_roll_off - precioAperturaUltimaGanadora) > (punto * 2))
   {
      g_precio_activacion_roll_off = precioAperturaUltimaGanadora;
      Print("‚úì ACTUALIZADO: ", DoubleToString(g_precio_activacion_roll_off, digits));
   }
   else
   {
      Print("‚úì MANTIENE: ", DoubleToString(g_precio_activacion_roll_off, digits));
   }
   
   Print("==========================================");
   Print(">>> Roll-Off completado");
   Print("==========================================");
   
   g_ultimo_roll_off = TimeCurrent();
   
   return true;
}

//+------------------------------------------------------------------+
//| Monitorear ganadoras - VERSI√ìN CORREGIDA                         |
//| - DETECTA NEUTRALIZACI√ìN SIEMPRE (cada tick)                    |
//| - QUITA TPs INMEDIATAMENTE al detectar neutralizaci√≥n           |
//| - TP FIJO cuando NO neutralizado                                |
//+------------------------------------------------------------------+
void MonitorearGanadorasRollOff()
{
   if(!g_roll_off_activo) return;
   if(!g_sistema_activo) return;
   
   CPositionInfo posInfo;
   CTrade tradeMonitor;
   tradeMonitor.SetExpertMagicNumber(g_numero_magico);
   
   // Contar posiciones
   int posicionesAbiertas = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            posicionesAbiertas++;
         }
      }
   }
   
   // Si no hay posiciones, objetivo alcanzado
   if(posicionesAbiertas == 0)
   {
      Print("========================================");
      Print(">>> TP ALCANZADO - OBJETIVO CUMPLIDO <<<");
      Print("========================================");
      
      // Cancelar √≥rdenes
      COrderInfo ordInfo;
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         if(ordInfo.SelectByIndex(i))
         {
            if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
            {
               string com = ordInfo.Comment();
               if(StringFind(com, "RollOff_Proteccion") >= 0)
               {
                  tradeMonitor.OrderDelete(ordInfo.Ticket());
               }
            }
         }
      }
      
      // RESETEAR VARIABLES GLOBALES
      g_roll_off_activo = false;
      g_sistema_activo = false;
      g_nivel_actual = 0;
      g_tiempo_primera_entrada = 0;
      
      Print(">>> Variables reseteadas - Sistema listo");
      
      return;
   }
   
   // ========== DETECCI√ìN DE NEUTRALIZACI√ìN - CR√çTICO ==========
   
   // Variable est√°tica para detectar INCREMENTO de posiciones
   static int posicionesAnteriores = 0;
   
   // Detectar si hubo un INCREMENTO de posiciones (orden neutralizadora activada)
   bool ordenNeutralizadoraActivada = (posicionesAbiertas > posicionesAnteriores);
   
   // Verificar neutralizaci√≥n por vol√∫menes
   bool hayNeutralizacion = VerificarNeutralizacion();
   
   // DETECTAR NEUTRALIZACI√ìN por dos m√©todos:
   // 1. Incremento de posiciones (orden neutralizadora se activ√≥)
   // 2. Verificaci√≥n de vol√∫menes igualados
   bool debeQuitarTPs = (ordenNeutralizadoraActivada || hayNeutralizacion);
   
   if(ordenNeutralizadoraActivada)
   {
      Print("========================================");
      Print(">>> ORDEN NEUTRALIZADORA ACTIVADA <<<");
      Print("Posiciones anteriores: ", posicionesAnteriores);
      Print("Posiciones actuales: ", posicionesAbiertas);
      Print("========================================");
   }
   
   // Actualizar contador
   posicionesAnteriores = posicionesAbiertas;
   
   // Si HAY neutralizaci√≥n O se activ√≥ orden, verificar y quitar TPs INMEDIATAMENTE
   if(debeQuitarTPs)
   {
      // Verificar si hay TPs configurados
      bool hayTPs = false;
      for(int i = 0; i < PositionsTotal(); i++)
      {
         if(posInfo.SelectByIndex(i))
         {
            if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
            {
               double tp = posInfo.TakeProfit();
               if(tp != 0)
               {
                  hayTPs = true;
                  break;
               }
            }
         }
      }
      
      // Si hay TPs, QUITARLOS INMEDIATAMENTE
      if(hayTPs)
      {
         Print("========================================");
         Print(">>> NEUTRALIZACI√ìN DETECTADA <<<");
         Print(">>> QUITANDO TODOS LOS TP/SL <<<");
         Print("========================================");
         
         int tpSlQuitados = 0;
         int intentos = 0;
         
         // Intentar hasta 3 veces para asegurar que se quiten TODOS
         while(intentos < 3)
         {
            tpSlQuitados = 0;
            
            for(int i = 0; i < PositionsTotal(); i++)
            {
               if(posInfo.SelectByIndex(i))
               {
                  if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
                  {
                     ulong ticket = posInfo.Ticket();
                     double tp = posInfo.TakeProfit();
                     double sl = posInfo.StopLoss();
                     
                     if(tp != 0 || sl != 0)
                     {
                        if(tradeMonitor.PositionModify(ticket, 0, 0))
                        {
                           Print("  ‚úì TP/SL quitados #", ticket);
                           tpSlQuitados++;
                           Sleep(50);
                        }
                        else
                        {
                           Print("  ‚úó Error quitando TP/SL #", ticket, " Error:", GetLastError());
                        }
                     }
                  }
               }
            }
            
            // Verificar que TODOS est√°n en 0
            bool todosEn0 = true;
            for(int i = 0; i < PositionsTotal(); i++)
            {
               if(posInfo.SelectByIndex(i))
               {
                  if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
                  {
                     if(posInfo.TakeProfit() != 0 || posInfo.StopLoss() != 0)
                     {
                        todosEn0 = false;
                        break;
                     }
                  }
               }
            }
            
            if(todosEn0)
            {
               Print("‚úì VERIFICADO: Todos los TP/SL en 0");
               break;
            }
            
            intentos++;
            if(intentos < 3)
            {
               Print("‚ö† Reintentando (intento ", (intentos + 1), ")");
               Sleep(100);
            }
         }
         
         Print(">>> TPs quitados: ", tpSlQuitados);
         
         // Cancelar √≥rdenes protecci√≥n
         COrderInfo ordInfo;
         int ordenesCanceladas = 0;
         for(int i = OrdersTotal() - 1; i >= 0; i--)
         {
            if(ordInfo.SelectByIndex(i))
            {
               if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
               {
                  string com = ordInfo.Comment();
                  if(StringFind(com, "RollOff_Proteccion") >= 0)
                  {
                     if(tradeMonitor.OrderDelete(ordInfo.Ticket()))
                     {
                        Print("  ‚úì Orden cancelada #", ordInfo.Ticket());
                        ordenesCanceladas++;
                     }
                  }
               }
            }
         }
         
         Print(">>> √ìrdenes protecci√≥n canceladas: ", ordenesCanceladas);
         Print("========================================");
         
         // FORZAR salida inmediata despu√©s de quitar TPs
         // para que el siguiente tick reporte el estado correcto
         return;
      }
   }
   
   // NO HACER NADA M√ÅS - el TP se mantiene fijo
   // GestionarSistemaRollOff se encargar√° de contar ticks cuando neutralizado
   // y ejecutar nuevo Roll-Off cuando alcance umbral
   
   // Reportar estado cada 10 segundos
   static datetime ultimoReporte = 0;
   if(TimeCurrent() - ultimoReporte > 10)
   {
      int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
      
      Print("--- Roll-Off activo ---");
      Print("Posiciones: ", posicionesAbiertas);
      
      // Usar la variable correcta para mostrar el estado
      bool estadoNeutralizado = VerificarNeutralizacion();
      Print("Estado: ", (estadoNeutralizado ? "NEUTRALIZADO" : "NO neutralizado"));
      
      if(estadoNeutralizado)
      {
         Print("Acci√≥n: Esperando nuevo umbral de ", g_ticks_umbral_roll_off, " ticks");
         Print("Precio referencia: ", DoubleToString(g_precio_activacion_roll_off, digits));
      }
      else
      {
         // Mostrar TP actual
         for(int i = 0; i < PositionsTotal(); i++)
         {
            if(posInfo.SelectByIndex(i))
            {
               if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
               {
                  double tp = posInfo.TakeProfit();
                  if(tp != 0)
                  {
                     Print("TP fijo: ", DoubleToString(tp, digits));
                     break;
                  }
               }
            }
         }
         Print("Acci√≥n: Esperando TP o activaci√≥n orden protecci√≥n");
      }
      
      ultimoReporte = TimeCurrent();
   }
}


//+------------------------------------------------------------------+
//| Gestionar sistema Roll-Off                                      |
//| CORRECCI√ìN: Cuenta ticks SOLO cuando neutralizado               |
//| CORRECCI√ìN: Desde precio de √∫ltima entrada                      |
//+------------------------------------------------------------------+
void GestionarSistemaRollOff()
{
   if(!g_sistema_activo) return;
   
   // Verificar nivel de activaci√≥n
   if(g_nivel_actual < g_nivel_activacion_cierre)
      return;
   
   // Verificar neutralizaci√≥n
   bool hayNeutralizacion = VerificarNeutralizacion();
   
   if(!g_roll_off_activo && hayNeutralizacion)
   {
      // ACTIVAR Roll-Off por PRIMERA VEZ
      g_roll_off_activo = true;
      
      // CORRECCI√ìN 7: Precio de referencia = precio de √∫ltima entrada
      double precioUltimaEntrada = 0;
      CPositionInfo posInfo;
      
      for(int i = 0; i < PositionsTotal(); i++)
      {
         if(posInfo.SelectByIndex(i))
         {
            if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
            {
               string comentario = posInfo.Comment();
               int nivel = 0;
               
               if(StringFind(comentario, "Nivel_") >= 0)
               {
                  nivel = (int)StringToInteger(StringSubstr(comentario, 6));
               }
               
               // Buscar la de mayor nivel (√∫ltima entrada)
               if(nivel >= g_nivel_actual)
               {
                  precioUltimaEntrada = posInfo.PriceOpen();
               }
            }
         }
      }
      
      g_precio_activacion_roll_off = precioUltimaEntrada;
      
      Print("========================================");
      Print(">>> SISTEMA ROLL-OFF ACTIVADO <<<");
      Print(">>> PRIMERA NEUTRALIZACI√ìN DETECTADA");
      Print(">>> Nivel: ", g_nivel_actual);
      Print(">>> Precio referencia (√∫ltima entrada): ", DoubleToString(g_precio_activacion_roll_off, _Digits));
      Print("========================================");
      
      // Quitar TP/SL de todas
      CTrade tradeGestion;
      tradeGestion.SetExpertMagicNumber(g_numero_magico);
      
      int tpSlQuitados = 0;
      for(int i = 0; i < PositionsTotal(); i++)
      {
         if(posInfo.SelectByIndex(i))
         {
            if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
            {
               ulong ticket = posInfo.Ticket();
               double tp = posInfo.TakeProfit();
               double sl = posInfo.StopLoss();
               
               if(tp != 0 || sl != 0)
               {
                  if(tradeGestion.PositionModify(ticket, 0, 0))
                  {
                     Print("  ‚úì TP/SL quitados #", ticket);
                     tpSlQuitados++;
                  }
               }
            }
         }
      }
      
      Print(">>> TP/SL quitados: ", tpSlQuitados);
      Print(">>> Esperando movimiento de ", g_ticks_umbral_roll_off, " ticks");
      Print("========================================");
      
      return;
   }
   
   if(g_roll_off_activo)
   {
      // Monitorear estado
      MonitorearGanadorasRollOff();
      
      // CORRECCI√ìN 6: SOLO CONTAR TICKS SI EST√Å NEUTRALIZADO
      bool neutralizacionActiva = VerificarNeutralizacion();
      
      if(!neutralizacionActiva)
      {
         // NO est√° neutralizado ‚Üí NO contar ticks
         // El sistema tiene TP configurado y orden protecci√≥n, solo esperar
         
         static datetime ultimoReporteNoNeutralizado = 0;
         if(TimeCurrent() - ultimoReporteNoNeutralizado > 30)
         {
            Print("--- Roll-Off activo ---");
            Print("Estado: NO neutralizado");
            Print("Acci√≥n: Esperando TP o activaci√≥n orden protecci√≥n");
            Print("NO se cuentan ticks en este estado");
            ultimoReporteNoNeutralizado = TimeCurrent();
         }
         
         return; // Salir, NO verificar umbral
      }
      
      // S√ç est√° neutralizado ‚Üí Contar ticks desde precio de referencia
      double precioActual = (SymbolInfoDouble(_Symbol, SYMBOL_BID) + 
                            SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / 2;
      
      double punto = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      double movimiento = precioActual - g_precio_activacion_roll_off;
      int ticksMovidos = (int)MathRound(movimiento / punto);
      
      // Verificar umbral
      bool umbralAlcanzado = (MathAbs(ticksMovidos) >= g_ticks_umbral_roll_off);
      
      // EJECUTAR ROLL-OFF SOLO SI:
      // 1. Est√° neutralizado
      // 2. Umbral alcanzado
      // 3. Han pasado 60 segundos desde √∫ltimo Roll-Off
      if(umbralAlcanzado && neutralizacionActiva && (TimeCurrent() - g_ultimo_roll_off) > 60)
      {
         Print("========================================");
         Print(">>> UMBRAL ALCANZADO <<<");
         Print(">>> Movimiento: ", MathAbs(ticksMovidos), " ticks desde √∫ltima entrada");
         Print(">>> Precio referencia: ", DoubleToString(g_precio_activacion_roll_off, _Digits));
         Print(">>> Precio actual: ", DoubleToString(precioActual, _Digits));
         Print(">>> Ejecutando Roll-Off...");
         Print("========================================");
         
         bool exito = EjecutarRollOff();
         
         if(exito)
         {
            Print(">>> Roll-Off completado");
            Print(">>> Nuevo precio referencia establecido en √∫ltima entrada");
         }
      }
      
      // Mostrar estado cada 100 ticks SOLO SI NEUTRALIZADO
      static int contadorTicks = 0;
      contadorTicks++;
      if(contadorTicks >= 100)
      {
         Print("--- Roll-Off activo ---");
         Print("Estado: NEUTRALIZADO");
         Print("Movimiento desde referencia: ", ticksMovidos, " ticks");
         Print("Umbral: ", g_ticks_umbral_roll_off, " ticks");
         Print("Restante: ", (g_ticks_umbral_roll_off - MathAbs(ticksMovidos)), " ticks");
         contadorTicks = 0;
      }
   }
}

//+------------------------------------------------------------------+
//| Calcular comisi√≥n exacta Pepperstone                             |
//+------------------------------------------------------------------+
double CalcularComisionPepperstone(double lotes, string simbolo)
{
   double comision = 0;
   
   if(lotes <= 0.01) comision = 0.06;
   else if(lotes <= 0.02) comision = 0.10;
   else if(lotes <= 0.03) comision = 0.16;
   else if(lotes <= 0.04) comision = 0.20;
   else if(lotes <= 0.05) comision = 0.26;
   else if(lotes <= 0.06) comision = 0.32;
   else if(lotes <= 0.07) comision = 0.36;
   else if(lotes <= 0.08) comision = 0.42;
   else if(lotes <= 0.09) comision = 0.46;
   else if(lotes <= 0.10) comision = 0.52;
   else if(lotes <= 0.11) comision = 0.58;
   else if(lotes <= 0.12) comision = 0.62;
   else if(lotes <= 0.13) comision = 0.68;
   else if(lotes <= 0.14) comision = 0.72;
   else if(lotes <= 0.15) comision = 0.78;
   else if(lotes <= 0.16) comision = 0.84;
   else if(lotes <= 0.17) comision = 0.88;
   else if(lotes <= 0.18) comision = 0.94;
   else if(lotes <= 0.19) comision = 0.98;
   else if(lotes <= 0.20) comision = 1.04;
   else if(lotes <= 0.21) comision = 1.10;
   else if(lotes <= 0.22) comision = 1.14;
   else if(lotes <= 0.23) comision = 1.20;
   else if(lotes <= 0.24) comision = 1.24;
   else if(lotes <= 0.25) comision = 1.30;
   else if(lotes <= 0.26) comision = 1.36;
   else if(lotes <= 0.27) comision = 1.40;
   else if(lotes <= 0.28) comision = 1.46;
   else if(lotes <= 0.29) comision = 1.50;
   else if(lotes <= 0.30) comision = 1.56;
   else
   {
      comision = lotes * 5.2;
   }
   
   return comision;
}

//+------------------------------------------------------------------+
//| Definici√≥n de la clase del panel                                 |
//+------------------------------------------------------------------+
class CPanelTrading : public CAppDialog
{
private:
   CPanel            m_panel_principal;
   CLabel            m_etiqueta_lote;
   CLabel            m_etiqueta_tp1;
   CLabel            m_etiqueta_tp2;
   CLabel            m_etiqueta_dist;
   CLabel            m_etiqueta_cierre;
   CLabel            m_etiqueta_ganancia;
   CEdit             m_entrada_lote;
   CEdit             m_entrada_tp1;
   CEdit             m_entrada_tp2;
   CEdit             m_entrada_dist;
   CEdit             m_entrada_cierre;
   CEdit             m_entrada_ganancia;
   CButton           m_boton_venta;
   CButton           m_boton_compra;

public:
                     CPanelTrading(void);
                    ~CPanelTrading(void);
   
   virtual bool      Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2);
   virtual bool      OnEvent(const int id, const long &lparam, const double &dparam, const string &sparam);
   void              VerificarYGestionarOrdenes();

protected:
   bool              CrearEtiqueta(CLabel &etiqueta, const int x, const int y, const string texto);
   bool              CrearCampoEntrada(CEdit &entrada, const int x, const int y);
   bool              CrearBoton(CButton &boton, const int x, const int y, const int ancho, const int alto, const string texto, const color clr);
   void              AlHacerClickVenta(void);
   void              AlHacerClickCompra(void);
   bool              IniciarSistemaTrading(ENUM_ORDER_TYPE tipoOrden);
   bool              ColocarOrdenMercado(ENUM_ORDER_TYPE tipoOrden, double lotes, double tp_ticks, int nivel);
   bool              ColocarOrdenPendiente(ENUM_ORDER_TYPE tipoOrden, double precio, double lotes, double tp_ticks, int nivel);
   void              CancelarTodasLasOrdenesPendientes();
   void              CerrarOrdenesDeSecuencia();
   double            CalcularTP(double precio_entrada, double tp_ticks, ENUM_ORDER_TYPE tipoOrden);
   double            CalcularLotajeNeutralizacion();
   ENUM_ORDER_TYPE   DeterminarTipoOrdenPorNivel(int nivel);
   bool              VerificarTPAlcanzado();
   bool              VerificarOrdenPendienteActiva();
   double            CalcularComisionTotal();
   void              ActualizarSLTPDinamicos();
};

CPanelTrading::CPanelTrading(void)
{
}

CPanelTrading::~CPanelTrading(void)
{
}

//+------------------------------------------------------------------+
//| Crear el panel de trading                                        |
//+------------------------------------------------------------------+
bool CPanelTrading::Create(const long chart, const string name, const int subwin, const int x1, const int y1, const int x2, const int y2)
{
   if(!CAppDialog::Create(chart, "Cobertura->FIN DEL STOP LOSS", subwin, x1, y1, x2, y2))
      return(false);
   
   if(!m_panel_principal.Create(m_chart_id, m_name+"PanelPrincipal", m_subwin, 0, 0, ClientAreaWidth(), ClientAreaHeight()))
      return(false);
   m_panel_principal.ColorBackground(clrBlack);
   m_panel_principal.ColorBorder(clrDarkGray);
   if(!Add(m_panel_principal))
      return(false);
   
   int desplazamiento_y = 10;
   int etiqueta_x = 10;
   int entrada_x = 120;
   int altura_fila = 30;
   
   CrearEtiqueta(m_etiqueta_lote, etiqueta_x, desplazamiento_y, "Lote Inicial:");
   CrearCampoEntrada(m_entrada_lote, entrada_x, desplazamiento_y);
   m_entrada_lote.Text("0.01");
   
   desplazamiento_y += altura_fila;
   CrearEtiqueta(m_etiqueta_tp1, etiqueta_x, desplazamiento_y, "TP E1:");
   CrearCampoEntrada(m_entrada_tp1, entrada_x, desplazamiento_y);
   m_entrada_tp1.Text("333");
   
   desplazamiento_y += altura_fila;
   CrearEtiqueta(m_etiqueta_tp2, etiqueta_x, desplazamiento_y, "TP E2:");
   CrearCampoEntrada(m_entrada_tp2, entrada_x, desplazamiento_y);
   m_entrada_tp2.Text("333");
   
   desplazamiento_y += altura_fila;
   CrearEtiqueta(m_etiqueta_dist, etiqueta_x, desplazamiento_y, "Dist. E1/E2:");
   CrearCampoEntrada(m_entrada_dist, entrada_x, desplazamiento_y);
   m_entrada_dist.Text("55");
   
   desplazamiento_y += altura_fila;
   CrearEtiqueta(m_etiqueta_cierre, etiqueta_x, desplazamiento_y, "Cierre virtual:");
   CrearCampoEntrada(m_entrada_cierre, entrada_x, desplazamiento_y);
   m_entrada_cierre.Text("4");
   
   desplazamiento_y += altura_fila;
   CrearEtiqueta(m_etiqueta_ganancia, etiqueta_x, desplazamiento_y, "GananciaM:");
   CrearCampoEntrada(m_entrada_ganancia, entrada_x, desplazamiento_y);
   m_entrada_ganancia.Text("0.01");
   
   desplazamiento_y += altura_fila + 20;
   int altura_boton = 35;
   int espacio_botones = 10;
   int ancho_total = (entrada_x + 100) - etiqueta_x;
   int ancho_boton = (ancho_total - espacio_botones) / 2;
   
   CrearBoton(m_boton_venta, etiqueta_x, desplazamiento_y, ancho_boton, altura_boton, "VENTA", clrRed);
   int compra_boton_x = etiqueta_x + ancho_boton + espacio_botones;
   CrearBoton(m_boton_compra, compra_boton_x, desplazamiento_y, ancho_boton, altura_boton, "COMPRA", clrBlue);
   
   return(true);
}

bool CPanelTrading::CrearEtiqueta(CLabel &etiqueta, const int x, const int y, const string texto)
{
   if(!etiqueta.Create(m_chart_id, m_name + texto, m_subwin, x, y, x + 100, y + 20))
      return(false);
   etiqueta.Text(texto);
   etiqueta.Color(clrWhite);
   if(!Add(etiqueta))
      return(false);
   return(true);
}

bool CPanelTrading::CrearCampoEntrada(CEdit &entrada, const int x, const int y)
{
   if(!entrada.Create(m_chart_id, m_name + "Entrada" + IntegerToString(x) + IntegerToString(y), m_subwin, x, y, x + 100, y + 20))
      return(false);
   entrada.TextAlign(ALIGN_CENTER);
   entrada.ColorBackground(clrDarkGray);
   entrada.ColorBorder(clrGray);
   entrada.Color(clrWhite);
   if(!Add(entrada))
      return(false);
   return(true);
}

bool CPanelTrading::CrearBoton(CButton &boton, const int x, const int y, const int ancho, const int alto, const string texto, const color clr)
{
   if(!boton.Create(m_chart_id, m_name + texto, m_subwin, x, y, x + ancho, y + alto))
      return(false);
   boton.Text(texto);
   boton.ColorBackground(clr);
   boton.Color(clrWhite);
   boton.ColorBorder(clr);
   boton.FontSize(10);
   if(!Add(boton))
      return(false);
   return(true);
}

double CPanelTrading::CalcularTP(double precio_entrada, double tp_ticks, ENUM_ORDER_TYPE tipoOrden)
{
   double punto = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   if(tipoOrden == ORDER_TYPE_BUY || tipoOrden == ORDER_TYPE_BUY_LIMIT || tipoOrden == ORDER_TYPE_BUY_STOP)
      return precio_entrada + (tp_ticks * punto);
   else
      return precio_entrada - (tp_ticks * punto);
}

ENUM_ORDER_TYPE CPanelTrading::DeterminarTipoOrdenPorNivel(int nivel)
{
   if(nivel % 2 == 1)
   {
      return g_tipo_inicial;
   }
   else
   {
      return (g_tipo_inicial == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
   }
}

double CPanelTrading::CalcularComisionTotal()
{
   double comisionTotal = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Magic() == g_numero_magico && posicionInfo.Symbol() == _Symbol)
         {
            double lotes = posicionInfo.Volume();
            double comision = CalcularComisionPepperstone(lotes, _Symbol);
            comisionTotal += comision;
         }
      }
   }
   
   return comisionTotal;
}

//+------------------------------------------------------------------+
//| NUEVA FUNCI√ìN: Actualizar SL/TP din√°micos SIEMPRE              |
//+------------------------------------------------------------------+
void CPanelTrading::ActualizarSLTPDinamicos()
{
   if(!g_sistema_activo) return;
   
   Print("--- Actualizando SL/TP Dinamicos (FIJOS) ---");
   Print("Precio Cobertura E#1: ", DoubleToString(g_precio_cobertura_E1, _Digits));
   Print("Precio Cobertura E#2: ", DoubleToString(g_precio_cobertura_E2, _Digits));
   Print("Nivel actual mas alto: ", g_nivel_actual);
   
   // Determinar la paridad del nivel m√°s alto actual
   int paridadActual = (g_nivel_actual % 2); // 1=impar, 0=par
   
   // Seleccionar el precio de cobertura fijo seg√∫n la paridad
   double precioCobertura = (paridadActual == 1) ? g_precio_cobertura_E1 : g_precio_cobertura_E2;
   
   Print("Paridad nivel actual: ", (paridadActual == 1 ? "IMPAR (usa E#1)" : "PAR (usa E#2)"));
   Print("Precio de cobertura a usar: ", DoubleToString(precioCobertura, _Digits));
   
   int posModificadas = 0;
   
   // Recorrer todas las posiciones
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Magic() == g_numero_magico && posicionInfo.Symbol() == _Symbol)
         {
            ulong ticket = posicionInfo.Ticket();
            ENUM_POSITION_TYPE tipo = posicionInfo.PositionType();
            
            string comentario = posicionInfo.Comment();
            int nivelPosicion = 0;
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivelPosicion = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            int paridadPosicion = (nivelPosicion % 2); // 1=impar, 0=par
            
            double nuevoSL = 0;
            double nuevoTP = 0;
            
            // Determinar si es TP o SL seg√∫n paridad
            bool esTP = (paridadPosicion == paridadActual);
            
            // L√ìGICA SIMPLE: usar el mismo precio fijo para BUY y SELL
            // El broker maneja autom√°ticamente BID/ASK
            if(esTP)
            {
               nuevoTP = precioCobertura;
               nuevoSL = 0;
               Print("  ", (tipo == POSITION_TYPE_BUY ? "BUY" : "SELL"), " #", ticket, 
                     " Nivel ", nivelPosicion, " -> TP: ", DoubleToString(nuevoTP, _Digits));
            }
            else
            {
               nuevoSL = precioCobertura;
               nuevoTP = 0;
               Print("  ", (tipo == POSITION_TYPE_BUY ? "BUY" : "SELL"), " #", ticket, 
                     " Nivel ", nivelPosicion, " -> SL: ", DoubleToString(nuevoSL, _Digits));
            }
            
            // Aplicar la modificaci√≥n
            if(trade.PositionModify(ticket, nuevoSL, nuevoTP))
            {
               posModificadas++;
            }
            else
            {
               Print("    Error: ", trade.ResultRetcodeDescription());
            }
         }
      }
   }
   
   Print("Total modificadas: ", posModificadas);
   Print("--------------------------------------");
}

//+------------------------------------------------------------------+
//| Calcular lotaje necesario para neutralizar p√©rdidas             |
//+------------------------------------------------------------------+
double CPanelTrading::CalcularLotajeNeutralizacion()
{
   double volumenBuyTotal = 0;
   double volumenSellTotal = 0;
   
   Print("========== CALCULANDO LOTAJE DE NEUTRALIZACION ==========");
   
   // Calcular vol√∫menes totales de BUY y SELL
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Magic() == g_numero_magico && posicionInfo.Symbol() == _Symbol)
         {
            double volumen = posicionInfo.Volume();
            double precioApertura = posicionInfo.PriceOpen();
            
            string comentario = posicionInfo.Comment();
            int nivel = 0;
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               nivel = (int)StringToInteger(StringSubstr(comentario, 6));
            }
            
            ENUM_ORDER_TYPE tipoReal = DeterminarTipoOrdenPorNivel(nivel);
            
            if(tipoReal == ORDER_TYPE_BUY)
            {
               volumenBuyTotal += volumen;
               Print("  Nivel ", nivel, " BUY: ", DoubleToString(volumen, 2), " @ ", DoubleToString(precioApertura, _Digits));
            }
            else
            {
               volumenSellTotal += volumen;
               Print("  Nivel ", nivel, " SELL: ", DoubleToString(volumen, 2), " @ ", DoubleToString(precioApertura, _Digits));
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("BUY acumulado: ", DoubleToString(volumenBuyTotal, 2), " lotes");
   Print("SELL acumulado: ", DoubleToString(volumenSellTotal, 2), " lotes");
   Print("Nivel de activacion: ", g_nivel_activacion_cierre);
   
   // Determinar el tipo de la pr√≥xima entrada
   ENUM_ORDER_TYPE tipoActivacion = DeterminarTipoOrdenPorNivel(g_nivel_activacion_cierre);
   
   // Calcular lotaje para igualar vol√∫menes
   double lotajeNecesario = 0;
   
   if(tipoActivacion == ORDER_TYPE_BUY)
   {
      // Si vamos a abrir BUY, necesitamos igualar con SELL
      lotajeNecesario = volumenSellTotal - volumenBuyTotal;
      Print("Tipo de entrada neutralizadora: BUY");
      Print(">>> Se necesita BUY de ", DoubleToString(lotajeNecesario, 2), " lotes para igualar con SELL");
   }
   else
   {
      // Si vamos a abrir SELL, necesitamos igualar con BUY
      lotajeNecesario = volumenBuyTotal - volumenSellTotal;
      Print("Tipo de entrada neutralizadora: SELL");
      Print(">>> Se necesita SELL de ", DoubleToString(lotajeNecesario, 2), " lotes para igualar con BUY");
   }
   
   // Normalizar el lotaje a los l√≠mites del s√≠mbolo
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lotajeNecesario = MathMax(lotajeNecesario, minLot);
   lotajeNecesario = MathMin(lotajeNecesario, maxLot);
   lotajeNecesario = MathRound(lotajeNecesario / lotStep) * lotStep;
   
   Print("----------------------------------------------");
   Print("Lotaje calculado (normalizado): ", DoubleToString(lotajeNecesario, 2));
   
   // Verificar resultado final
   if(tipoActivacion == ORDER_TYPE_BUY)
   {
      Print("Volumen final BUY: ", DoubleToString(volumenBuyTotal + lotajeNecesario, 2));
      Print("Volumen final SELL: ", DoubleToString(volumenSellTotal, 2));
      Print("Diferencia: ", DoubleToString(MathAbs((volumenBuyTotal + lotajeNecesario) - volumenSellTotal), 2));
   }
   else
   {
      Print("Volumen final BUY: ", DoubleToString(volumenBuyTotal, 2));
      Print("Volumen final SELL: ", DoubleToString(volumenSellTotal + lotajeNecesario, 2));
      Print("Diferencia: ", DoubleToString(MathAbs(volumenBuyTotal - (volumenSellTotal + lotajeNecesario)), 2));
   }
   
   Print("==========================================================");
   
   return lotajeNecesario;
}

bool CPanelTrading::ColocarOrdenMercado(ENUM_ORDER_TYPE tipoOrden, double lotes, double tp_ticks, int nivel)
{
   double precio = (tipoOrden == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double tp = CalcularTP(precio, tp_ticks, tipoOrden);
   
   trade.SetExpertMagicNumber(g_numero_magico);
   string comentario = "Nivel_" + IntegerToString(nivel);
   
   if(trade.PositionOpen(_Symbol, tipoOrden, lotes, precio, 0, tp, comentario))
   {
      Print("Orden de mercado abierta: Nivel ", nivel, " Tipo: ", 
            (tipoOrden == ORDER_TYPE_BUY ? "COMPRA" : "VENTA"),
            " Precio: ", precio, " Lote: ", lotes, " TP: ", tp);
       return true;
   }
   else
   {
      Print("Error al abrir orden de mercado: ", trade.ResultRetcode());
      return false;
   }
}

bool CPanelTrading::ColocarOrdenPendiente(ENUM_ORDER_TYPE tipoOrden, double precio, double lotes, double tp_ticks, int nivel)
{
   double tp = CalcularTP(precio, tp_ticks, tipoOrden);
   ENUM_ORDER_TYPE tipoPendiente;
   
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double precioMedio = (bid + ask) / 2;
   
   if(tipoOrden == ORDER_TYPE_BUY)
   {
      tipoPendiente = (precio < precioMedio) ? ORDER_TYPE_BUY_LIMIT : ORDER_TYPE_BUY_STOP;
   }
   else
   {
      tipoPendiente = (precio > precioMedio) ? ORDER_TYPE_SELL_LIMIT : ORDER_TYPE_SELL_STOP;
   }
   
   trade.SetExpertMagicNumber(g_numero_magico);
   string comentario = "Nivel_" + IntegerToString(nivel);
   
   if(trade.OrderOpen(_Symbol, tipoPendiente, lotes, 0, precio, 0, tp, ORDER_TIME_GTC, 0, comentario))
   {
      Print("Orden pendiente colocada: Nivel ", nivel, 
            " Tipo: ", EnumToString(tipoPendiente),
            " Direccion: ", (tipoOrden == ORDER_TYPE_BUY ? "COMPRA" : "VENTA"),
            " Precio: ", precio, " Lote: ", lotes, " TP: ", tp);
      return true;
   }
   else
   {
      Print("Error al colocar orden pendiente: ", trade.ResultRetcode());
      return false;
   }
}

//+------------------------------------------------------------------+
//| FUNCI√ìN CORREGIDA: IniciarSistemaTrading                        |
//+------------------------------------------------------------------+
bool CPanelTrading::IniciarSistemaTrading(ENUM_ORDER_TYPE tipoOrden)
{
   g_lote_inicial = StringToDouble(m_entrada_lote.Text());
   g_tp1_ticks = StringToDouble(m_entrada_tp1.Text());
   g_tp2_ticks = StringToDouble(m_entrada_tp2.Text());
   g_distancia_ticks = StringToDouble(m_entrada_dist.Text());
   g_nivel_activacion_cierre = (int)StringToInteger(m_entrada_cierre.Text());
   g_ganancia_objetivo = StringToDouble(m_entrada_ganancia.Text());
   
   if(g_lote_inicial <= 0 || g_tp1_ticks <= 0 || g_tp2_ticks <= 0 || g_distancia_ticks <= 0)
   {
      Print("Error: Valores invalidos en el panel");
      return false;
   }
      
   CancelarTodasLasOrdenesPendientes();
   
   g_tipo_inicial = tipoOrden;
   g_nivel_actual = 1;
   g_sistema_activo = true;
   
   // ========== NUEVO: Marcar inicio de secuencia ==========
   g_tiempo_primera_entrada = TimeCurrent();
   Print(">>> Inicio de secuencia: ", TimeToString(g_tiempo_primera_entrada));
   // ========================================================
   
   Print("=== INICIANDO SISTEMA ===");
   Print("Tipo inicial: ", (tipoOrden == ORDER_TYPE_BUY ? "COMPRA" : "VENTA"));
   Print("Nivel activacion cierre virtual: ", g_nivel_activacion_cierre);
   Print("Ganancia objetivo: ", g_ganancia_objetivo);
   
   double precio = (tipoOrden == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   g_precio_entrada1 = precio;
   
   if(!ColocarOrdenMercado(tipoOrden, g_lote_inicial, g_tp1_ticks, 1))
   {
      g_sistema_activo = false;
      return false;
   }
   
   double punto = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(tipoOrden == ORDER_TYPE_BUY)
   {
      g_precio_entrada2 = g_precio_entrada1 - (g_distancia_ticks * punto);
   }
   else
   {
      g_precio_entrada2 = g_precio_entrada1 + (g_distancia_ticks * punto);
   }
   
   // ========== CALCULAR PRECIOS DE COBERTURA FIJOS ==========
   // Estos precios se calculan UNA SOLA VEZ al inicio
   
   // Precio de cobertura para Entrada#1 (niveles IMPARES)
   if(tipoOrden == ORDER_TYPE_BUY)
   {
      g_precio_cobertura_E1 = g_precio_entrada1 + (g_tp1_ticks * punto);
   }
   else
   {
      g_precio_cobertura_E1 = g_precio_entrada1 - (g_tp1_ticks * punto);
   }
   
   // Precio de cobertura para Entrada#2 (niveles PARES)
   ENUM_ORDER_TYPE tipoNivel2 = DeterminarTipoOrdenPorNivel(2);
   if(tipoNivel2 == ORDER_TYPE_BUY)
   {
      g_precio_cobertura_E2 = g_precio_entrada2 + (g_tp2_ticks * punto);
   }
   else
   {
      g_precio_cobertura_E2 = g_precio_entrada2 - (g_tp2_ticks * punto);
   }
   
   Print(">>> Precio Cobertura E#1 (fijo): ", DoubleToString(g_precio_cobertura_E1, _Digits));
   Print(">>> Precio Cobertura E#2 (fijo): ", DoubleToString(g_precio_cobertura_E2, _Digits));
   // ========== FIN C√ÅLCULO PRECIOS DE COBERTURA ==========
   
   // ========== CALCULAR LOTAJE PARA ENTRADA#2 ==========
   double lotajeNivel2;
   
   // Si el nivel de activaci√≥n es 2, usar neutralizaci√≥n
   if(g_nivel_activacion_cierre == 2)
   {
      // Para nivel 2, igualar con el lote inicial
      lotajeNivel2 = g_lote_inicial;
      
      Print(">>> CIERRE VIRTUAL = 2: Entrada#2 se programa con NEUTRALIZACION");
      Print(">>> Lotaje Entrada#1: ", DoubleToString(g_lote_inicial, 2));
      Print(">>> Lotaje Entrada#2: ", DoubleToString(lotajeNivel2, 2), " (IGUALANDO)");
   }
   else
   {
      // Para otros niveles, usar martingala normal
      lotajeNivel2 = g_lote_inicial * 2;
      Print(">>> Entrada#2 se programa con martingala: ", DoubleToString(lotajeNivel2, 2));
   }
   // ========== FIN C√ÅLCULO LOTAJE ==========
   
   ColocarOrdenPendiente(tipoNivel2, g_precio_entrada2, lotajeNivel2, g_tp2_ticks, 2);
   
   Print("Sistema iniciado - Entrada#1: ", g_precio_entrada1, " Entrada#2: ", g_precio_entrada2);
   Print("Secuencia de tipos: ", (tipoOrden == ORDER_TYPE_BUY ? "BUY-SELL-BUY-SELL..." : "SELL-BUY-SELL-BUY..."));
   
   return true;
}


bool CPanelTrading::VerificarTPAlcanzado()
{
   static int posicionesAnterior = 0;
   int posicionesActual = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Magic() == g_numero_magico && posicionInfo.Symbol() == _Symbol)
         {
            posicionesActual++;
         }
      }
   }
   
   if(g_sistema_activo && posicionesAnterior > posicionesActual && posicionesActual >= 0)
   {
      posicionesAnterior = posicionesActual;
      if(HistorySelect(TimeCurrent() - 60, TimeCurrent()))
      {
         int total = HistoryDealsTotal();
         for(int i = total - 1; i >= 0; i--)
         {
            ulong ticket = HistoryDealGetTicket(i);
            if(HistoryDealGetInteger(ticket, DEAL_MAGIC) == g_numero_magico)
            {
               double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
               if(profit > 0)
               {
                  Print("TP alcanzado - Cerrando todas las ordenes");
                  return true;
               }
            }
         }
      }
   }
   
   posicionesAnterior = posicionesActual;
   return false;
}

bool CPanelTrading::VerificarOrdenPendienteActiva()
{
   for(int i = 0; i < OrdersTotal(); i++)
   {
      if(ordenInfo.SelectByIndex(i))
      {
         if(ordenInfo.Magic() == g_numero_magico && ordenInfo.Symbol() == _Symbol)
         {
            return true;
         }
      }
   }
   return false;
}

//+------------------------------------------------------------------+
//| FUNCI√ìN CORREGIDA: CerrarOrdenesDeSecuencia                     |
//| Resetea variables - SIN ciclos ni acumulados                    |
//+------------------------------------------------------------------+
void CPanelTrading::CerrarOrdenesDeSecuencia()
{
   if(!g_sistema_activo) return;
   
   Print("=== CERRANDO SECUENCIA ===");
   
   // Cerrar todas las posiciones
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Symbol() == _Symbol && posicionInfo.Magic() == g_numero_magico)
         {
            trade.PositionClose(posicionInfo.Ticket());
         }
      }
   }
   
   // Eliminar todas las √≥rdenes pendientes
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(ordenInfo.SelectByIndex(i))
      {
         if(ordenInfo.Symbol() == _Symbol && ordenInfo.Magic() == g_numero_magico)
         {
            trade.OrderDelete(ordenInfo.Ticket());
         }
      }
   }
   
   // Resetear variables del sistema
   g_sistema_activo = false;
   g_nivel_actual = 0;
   g_precio_entrada1 = 0;
   g_precio_entrada2 = 0;
   g_precio_cobertura_E1 = 0;
   g_precio_cobertura_E2 = 0;
   
   // Resetear precios de cobertura fijos
   g_precio_cobertura1_fijo = 0;
   g_precio_cobertura2_fijo = 0;
   Print(">>> Precios de cobertura fijos reseteados");
   
   // ========== Resetear variables Roll-Off ==========
   g_roll_off_activo = false;
   g_precio_activacion_roll_off = 0;
   g_ultimo_roll_off = 0;
   g_tiempo_primera_entrada = 0;  // Resetear marca de inicio
   
   Print(">>> Variables Roll-Off reseteadas");
   // ==================================================
   
   Print("=== CIERRE COMPLETADO ===");
}


void CPanelTrading::CancelarTodasLasOrdenesPendientes()
{
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(ordenInfo.SelectByIndex(i))
      {
         if(ordenInfo.Magic() == g_numero_magico && ordenInfo.Symbol() == _Symbol)
         {
            trade.OrderDelete(ordenInfo.Ticket());
         }
      }
   }
}

//+------------------------------------------------------------------+
// CONTINUACI√ìN - PARTE 3 (FINAL)
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| FUNCI√ìN VerificarYGestionarOrdenes                               |
//+------------------------------------------------------------------+
void CPanelTrading::VerificarYGestionarOrdenes()
{
   if(!g_sistema_activo) return;
   
   // ========== NUEVA L√çNEA: Gestionar sistema Roll-Off ==========
   GestionarSistemaRollOff();
   // ==============================================================
   
   // Verificar si se alcanz√≥ alg√∫n TP
   if(VerificarTPAlcanzado())
   {
      CerrarOrdenesDeSecuencia();
      return;
   }
   
   // Buscar la √∫ltima posici√≥n abierta
   int ultimoNivel = 0;
   double ultimoLote = 0;
   bool hayPosiciones = false;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(posicionInfo.SelectByIndex(i))
      {
         if(posicionInfo.Magic() == g_numero_magico && posicionInfo.Symbol() == _Symbol)
         {
            hayPosiciones = true;
            string comentario = posicionInfo.Comment();
            if(StringFind(comentario, "Nivel_") >= 0)
            {
               int nivel = (int)StringToInteger(StringSubstr(comentario, 6));
               if(nivel > ultimoNivel)
               {
                  ultimoNivel = nivel;
                  ultimoLote = posicionInfo.Volume();
               }
            }
         }
      }
   }
   
   // Si hay una nueva posici√≥n abierta, gestionar sistema
   if(ultimoNivel > g_nivel_actual)
   {
      g_nivel_actual = ultimoNivel;
      
      Print("Nueva posici√≥n abierta - Nivel: ", ultimoNivel);
      
      // Actualizar SL/TP din√°micos para todas las posiciones
      ActualizarSLTPDinamicos();
      
      // Cancelar √≥rdenes pendientes anteriores
      CancelarTodasLasOrdenesPendientes();
      
      // ========== VERIFICACI√ìN CR√çTICA: ANTES DE PROGRAMAR SIGUIENTE ==========
      // Si ya alcanz√≥ el nivel de activaci√≥n del cierre virtual,
      // NO programar m√°s √≥rdenes
      if(ultimoNivel >= g_nivel_activacion_cierre)
      {
         Print("=== CIERRE VIRTUAL ACTIVADO en nivel ", ultimoNivel, " ===");
         Print(">>> NO se programaran mas ordenes pendientes");
         Print(">>> Sistema Roll-Off gestionara los cierres");
         return; // ‚Üê SALIR AQU√ç, ANTES DE PROGRAMAR SIGUIENTE
      }
      // ========== FIN VERIFICACI√ìN ==========
      
      // Si NO alcanz√≥ el nivel de cierre virtual, continuar con martingala normal
      int siguienteNivel = ultimoNivel + 1;
      double siguienteLote;
      
      // Si el siguiente nivel es el nivel de activaci√≥n del cierre virtual,
      // calcular lotaje que neutraliza p√©rdidas (iguala vol√∫menes)
      if(siguienteNivel == g_nivel_activacion_cierre)
      {
         siguienteLote = CalcularLotajeNeutralizacion();
         
         // Si retorna un valor muy peque√±o, usar lotaje m√≠nimo
         double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
         if(siguienteLote < minLot)
         {
            siguienteLote = minLot;
            Print(">>> Lotaje muy peque√±o, usando lotaje minimo: ", DoubleToString(siguienteLote, 2));
         }
         else
         {
            Print(">>> Usando lotaje de NEUTRALIZACION: ", DoubleToString(siguienteLote, 2));
         }
      }
      else
      {
         // Para otros niveles, usar martingala normal
         siguienteLote = ultimoLote * 2;
      }
      
      // Determinar el tipo de orden seg√∫n el patr√≥n establecido
      ENUM_ORDER_TYPE siguienteTipo = DeterminarTipoOrdenPorNivel(siguienteNivel);
      
      // Determinar precio y TP seg√∫n el patr√≥n
      double siguientePrecio;
      double siguienteTP;
      
      if(siguienteNivel % 2 == 1)
      {
         siguientePrecio = g_precio_entrada1;
         siguienteTP = g_tp1_ticks;
      }
      else
      {
         siguientePrecio = g_precio_entrada2;
         siguienteTP = g_tp2_ticks;
      }
      
      // Intentar colocar la nueva orden pendiente
      if(!ColocarOrdenPendiente(siguienteTipo, siguientePrecio, siguienteLote, siguienteTP, siguienteNivel))
      {
         static int intentosFallidos = 0;
         intentosFallidos++;
         
         if(intentosFallidos >= 3)
         {
            Print("Imposible colocar nueva orden - Cerrando secuencia por falta de margen");
            CerrarOrdenesDeSecuencia();
            intentosFallidos = 0;
            return;
         }
      }
      else
      {
         Print("Programando Nivel ", siguienteNivel, 
               " - Tipo: ", (siguienteTipo == ORDER_TYPE_BUY ? "COMPRA" : "VENTA"),
               " - Precio: ", siguientePrecio, " - Lote: ", siguienteLote);
      }
   }
   else if(hayPosiciones && g_nivel_actual > 0)
   {
      // Protecci√≥n para NO actualizar SL/TP si Cierre virtual = 2 y solo hay Entrada#1
      if(g_nivel_activacion_cierre == 2 && g_nivel_actual == 1)
      {
         return; // Mantener el TP original de Entrada#1
      }
      
      // ========== MODIFICACI√ìN: NO actualizar SL/TP si Roll-Off activo ==========
      if(g_roll_off_activo)
      {
         return; // El Roll-Off gestiona los cierres, no los SL/TP din√°micos
      }
      // ===========================================================================
      
      // Actualizar SL/TP en cada tick para ajustar al spread
      // Solo actualizar cada 10 ticks para no saturar
      static int contadorTicks = 0;
      contadorTicks++;
      if(contadorTicks >= 10)
      {
         ActualizarSLTPDinamicos();
         contadorTicks = 0;
      }
   }
   
   // Si ya alcanzamos el nivel de cierre virtual, es NORMAL no tener √≥rdenes pendientes
   if(g_nivel_actual >= g_nivel_activacion_cierre)
   {
      return; // No verificar √≥rdenes pendientes
   }
   
   // Verificar si no hay √≥rdenes pendientes cuando deber√≠a haberlas
   if(hayPosiciones && g_nivel_actual > 0 && !VerificarOrdenPendienteActiva())
   {
      static int ticksSinOrdenPendiente = 0;
      ticksSinOrdenPendiente++;
      
      if(ticksSinOrdenPendiente >= 5)
      {
         Print("No hay ordenes pendientes activas - Cerrando secuencia");
         CerrarOrdenesDeSecuencia();
         ticksSinOrdenPendiente = 0;
      }
   }
}

//+------------------------------------------------------------------+
//| Manejador de eventos                                             |
//+------------------------------------------------------------------+
EVENT_MAP_BEGIN(CPanelTrading)
   ON_EVENT(ON_CLICK, m_boton_venta, AlHacerClickVenta)
   ON_EVENT(ON_CLICK, m_boton_compra, AlHacerClickCompra)
EVENT_MAP_END(CAppDialog)

void CPanelTrading::AlHacerClickVenta(void)
{
   Print("Iniciando sistema con VENTA");
   if(IniciarSistemaTrading(ORDER_TYPE_SELL))
   {
      Print("Sistema de cobertura iniciado con VENTA");
   }
   else
   {
      Print("Error al iniciar el sistema");
   }
}

void CPanelTrading::AlHacerClickCompra(void)
{
   Print("Iniciando sistema con COMPRA");
   if(IniciarSistemaTrading(ORDER_TYPE_BUY))
   {
      Print("Sistema de cobertura iniciado con COMPRA");
   }
   else
   {
      Print("Error al iniciar el sistema");
   }
}

//+------------------------------------------------------------------+
//| Variables globales                                               |
//+------------------------------------------------------------------+
CPanelTrading DialogoExterno;

//+------------------------------------------------------------------+
//| Funci√≥n de inicializaci√≥n del Expert Advisor                     |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(g_numero_magico);
   
   // ========== NUEVO: Inicializar variables Roll-Off ==========
   g_roll_off_activo = false;
   g_precio_activacion_roll_off = 0;
   g_ticks_umbral_roll_off = 77; // 7.7 pips por defecto
   g_ultimo_roll_off = 0;
   
   Print("========================================");
   Print("Sistema Roll-Off inicializado");
   Print("Umbral movimiento: ", g_ticks_umbral_roll_off, " ticks (", 
         g_ticks_umbral_roll_off/10, " pips)");
   Print("========================================");
   // ============================================================
   
   if(!DialogoExterno.Create(0, "CoberturaEspecial", 0, 50, 50, 300, 350))
      return(INIT_FAILED);
   
   if(!DialogoExterno.Run())
      return(INIT_FAILED);
   
   ChartRedraw();
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Funci√≥n de desinicializaci√≥n del Expert Advisor                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   DialogoExterno.Destroy(reason);
}

//+------------------------------------------------------------------+
//| Funci√≥n OnTick                                                   |
//+------------------------------------------------------------------+
void OnTick()
{ 
   DialogoExterno.VerificarYGestionarOrdenes();
}

//+------------------------------------------------------------------+
//| Funci√≥n OnChartEvent                                             |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
{
   DialogoExterno.ChartEvent(id, lparam, dparam, sparam);
}
