//+------------------------------------------------------------------+
//| EjecutarRollOff - VERSIÃ“N CORREGIDA                             |
//| CORRECCIÃ“N CRÃTICA: Usa PositionType() de MT5 para identificar  |
//|                     ganadoras/perdedoras en lugar de nivel      |
//| PROBLEMA: Las posiciones de "RollOff_Proteccion" no tienen      |
//|           "Nivel_" en el comentario, causando clasificaciÃ³n     |
//|           incorrecta y cierre de TODAS las posiciones           |
//+------------------------------------------------------------------+

bool EjecutarRollOff()
{
   Print("========================================");
   Print("========== EJECUTANDO ROLL-OFF ==========");
   
   CTrade tradeRollOff;
   CPositionInfo posInfo;
   tradeRollOff.SetExpertMagicNumber(g_numero_magico);
   
   // Calcular P&L por tipo
   double plBuy = 0, plSell = 0;
   CalcularPLPorTipo(plBuy, plSell);
   
   Print("P&L BUY: ", DoubleToString(plBuy, 2), " | P&L SELL: ", DoubleToString(plSell, 2));
   
   bool buyGanando = (plBuy > plSell);
   Print("Lado ganador: ", (buyGanando ? "BUY" : "SELL"));
   
   // ========== PASO 1: CERRAR PERDEDORAS Y LEER TODA LA SECUENCIA ==========
   Print("========================================");
   Print(">>> PASO 1: CERRANDO PERDEDORAS <<<");
   
   ulong ticketsCerrar[];
   int contadorTickets = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esPerdedora = false;
            
            if(buyGanando)
            {
               esPerdedora = (tipoPosicion == POSITION_TYPE_SELL);
            }
            else
            {
               esPerdedora = (tipoPosicion == POSITION_TYPE_BUY);
            }
            
            if(esPerdedora)
            {
               ulong ticket = posInfo.Ticket();
               double volumen = posInfo.Volume();
               string comentario = posInfo.Comment();
               
               Print("  Identificada PERDEDORA #", ticket, 
                     " Vol:", DoubleToString(volumen, 2),
                     " Tipo:", (tipoPosicion == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                     " Com:", comentario);
               
               ArrayResize(ticketsCerrar, contadorTickets + 1);
               ticketsCerrar[contadorTickets] = ticket;
               contadorTickets++;
            }
            else
            {
               ulong ticket = posInfo.Ticket();
               double volumen = posInfo.Volume();
               string comentario = posInfo.Comment();
               
               Print("  Identificada GANADORA #", ticket, 
                     " Vol:", DoubleToString(volumen, 2),
                     " Tipo:", (tipoPosicion == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                     " Com:", comentario, " â†’ NO SE CIERRA");
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("Perdedoras a cerrar: ", contadorTickets);
   
   for(int i = 0; i < contadorTickets; i++)
   {
      ulong ticket = ticketsCerrar[i];
      
      if(tradeRollOff.PositionClose(ticket))
      {
         Print("  âœ“ Cerrada #", ticket);
         Sleep(100);
      }
   }
   
   Sleep(200);
   
   Print("--- Leyendo TODA la secuencia desde inicio ---");
   
   double profitTodasCerradas = 0;
   int cantidadCerradas = 0;
   
   datetime desde = g_tiempo_primera_entrada;
   datetime hasta = TimeCurrent();
   
   if(HistorySelect(desde, hasta))
   {
      int totalDeals = HistoryDealsTotal();
      
      for(int i = totalDeals - 1; i >= 0; i--)
      {
         ulong dealTicket = HistoryDealGetTicket(i);
         
         if(dealTicket > 0)
         {
            long magic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
            string symbol = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
            long dealEntry = HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
            
            if(magic == g_numero_magico && symbol == _Symbol && dealEntry == DEAL_ENTRY_OUT)
            {
               double profitReal = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
               double swapReal = HistoryDealGetDouble(dealTicket, DEAL_SWAP);
               double volumen = HistoryDealGetDouble(dealTicket, DEAL_VOLUME);
               ulong positionTicket = HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID);
               
               Print("  Deal #", dealTicket, " Pos #", positionTicket);
               Print("    Profit: ", DoubleToString(profitReal, 2));
               Print("    Swap: ", DoubleToString(swapReal, 2));
               Print("    Volumen: ", DoubleToString(volumen, 2));
               
               profitTodasCerradas += profitReal + swapReal;
               cantidadCerradas++;
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("Total entradas cerradas: ", cantidadCerradas);
   Print("PROFIT TODAS CERRADAS: ", DoubleToString(profitTodasCerradas, 2));
   
   Print("--- Leyendo SWAP de todas las entradas abiertas ---");
   
   double swapTodasAbiertas = 0;
   int cantidadAbiertas = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            double swapPos = posInfo.Swap();
            ulong ticket = posInfo.Ticket();
            
            Print("  Swap abierta #", ticket, ": ", DoubleToString(swapPos, 2));
            
            swapTodasAbiertas += swapPos;
            cantidadAbiertas++;
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("Total entradas abiertas: ", cantidadAbiertas);
   Print("SWAP TODAS ABIERTAS: ", DoubleToString(swapTodasAbiertas, 2));
   
   // ========== PASO 2: COMISIONES DE TODA LA SECUENCIA ==========
   Print("========================================");
   Print(">>> PASO 2: COMISIONES TOTALES <<<");
   
   double comisionesTotales = 0;
   
   if(HistorySelect(desde, hasta))
   {
      int totalDeals = HistoryDealsTotal();
      
      for(int i = totalDeals - 1; i >= 0; i--)
      {
         ulong dealTicket = HistoryDealGetTicket(i);
         
         if(dealTicket > 0)
         {
            long magic = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
            string symbol = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
            long dealEntry = HistoryDealGetInteger(dealTicket, DEAL_ENTRY);
            
            if(magic == g_numero_magico && symbol == _Symbol && dealEntry == DEAL_ENTRY_OUT)
            {
               double volumen = HistoryDealGetDouble(dealTicket, DEAL_VOLUME);
               double comision = CalcularComisionPepperstone(volumen, _Symbol);
               comisionesTotales += comision;
               
               ulong positionTicket = HistoryDealGetInteger(dealTicket, DEAL_POSITION_ID);
               Print("  ComisiÃ³n cerrada #", positionTicket, ": ", DoubleToString(comision, 2));
            }
         }
      }
   }
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            double volumen = posInfo.Volume();
            double comision = CalcularComisionPepperstone(volumen, _Symbol);
            comisionesTotales += comision;
            Print("  ComisiÃ³n abierta #", posInfo.Ticket(), ": ", DoubleToString(comision, 2));
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("COMISIONES TOTALES: ", DoubleToString(comisionesTotales, 2));
   
   // ========== PASO 3: CALCULAR P&L TOTAL ==========
   Print("========================================");
   Print(">>> PASO 3: P&L TOTAL <<<");
   
   double plTotal = profitTodasCerradas + swapTodasAbiertas - comisionesTotales;
   
   Print("PROFIT TODAS CERRADAS: ", DoubleToString(profitTodasCerradas, 2));
   Print("SWAP TODAS ABIERTAS: ", DoubleToString(swapTodasAbiertas, 2));
   Print("COMISIONES TOTALES: -", DoubleToString(comisionesTotales, 2));
   Print("----------------------------------------------");
   Print("P&L TOTAL: ", DoubleToString(plTotal, 2));
   
   // ========== PASO 4: CALCULAR TP ==========
   Print("========================================");
   Print(">>> PASO 4: CALCULAR TP <<<");
   
   double gananciaBrutaNecesaria = MathAbs(plTotal) + g_ganancia_objetivo;
   
   Print("P&L TOTAL: ", DoubleToString(plTotal, 2));
   Print("GananciaM: ", DoubleToString(g_ganancia_objetivo, 2));
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   
   COrderInfo ordInfo;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(ordInfo.SelectByIndex(i))
      {
         if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
         {
            string com = ordInfo.Comment();
            if(StringFind(com, "RollOff_Proteccion") >= 0)
            {
               tradeRollOff.OrderDelete(ordInfo.Ticket());
            }
         }
      }
   }
   
   double punto = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   
   double volumenTotalGanadoras = 0;
   ENUM_POSITION_TYPE tipoGanadorasMT5 = POSITION_TYPE_BUY;
   ENUM_ORDER_TYPE tipoGanadoras = ORDER_TYPE_BUY;
   int contadorGanadoras = 0;
   int nivelMasAlto = 0;
   double precioAperturaUltimaGanadora = 0;
   datetime tiempoMasReciente = 0;
   
   Print("--- Analizando ganadoras ---");
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esGanadora = false;
            
            if(buyGanando)
            {
               esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
            }
            else
            {
               esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
            }
            
            if(esGanadora)
            {
               ulong ticket = posInfo.Ticket();
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               datetime tiempoApertura = posInfo.Time();
               string comentario = posInfo.Comment();
               
               int nivel = 0;
               if(StringFind(comentario, "Nivel_") >= 0)
               {
                  nivel = (int)StringToInteger(StringSubstr(comentario, 6));
               }
               
               Print("  Ganadora #", ticket, 
                     " Tipo:", (tipoPosicion == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                     " Nivel:", nivel, 
                     " Vol:", DoubleToString(volumen, 2));
               Print("    Precio apertura: ", DoubleToString(precioApertura, digits));
               
               volumenTotalGanadoras += volumen;
               tipoGanadorasMT5 = tipoPosicion;
               tipoGanadoras = (tipoPosicion == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
               contadorGanadoras++;
               
               if(tiempoApertura > tiempoMasReciente)
               {
                  tiempoMasReciente = tiempoApertura;
                  precioAperturaUltimaGanadora = precioApertura;
                  nivelMasAlto = nivel;
               }
            }
         }
      }
   }
   
   if(contadorGanadoras == 0)
   {
      Print("âœ— ERROR: No hay ganadoras");
      return false;
   }
   
   Print("----------------------------------------------");
   Print("Total ganadoras: ", contadorGanadoras);
   Print("Volumen total ganadoras: ", DoubleToString(volumenTotalGanadoras, 2));
   
   double sumatoriaPrecioVolumen = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esGanadora = false;
            if(buyGanando)
               esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
            else
               esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
            
            if(esGanadora)
            {
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               sumatoriaPrecioVolumen += precioApertura * volumen;
            }
         }
      }
   }
   
   double precioPromedioApertura = sumatoriaPrecioVolumen / volumenTotalGanadoras;
   
   // ========== EXTRAER VALOR DEL PUNTO DESDE POSICIONES REALES ==========
   double valorPuntoPorLote = 0;
   bool valorObtenido = false;
   
   double precioActualCalculo;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      precioActualCalculo = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   else
      precioActualCalculo = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esGanadora = false;
            if(buyGanando)
               esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
            else
               esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
            
            if(esGanadora)
            {
               double volumen = posInfo.Volume();
               double precioApertura = posInfo.PriceOpen();
               double profit = posInfo.Profit();
               
               double diferenciaPrecio;
               if(tipoPosicion == POSITION_TYPE_BUY)
                  diferenciaPrecio = precioActualCalculo - precioApertura;
               else
                  diferenciaPrecio = precioApertura - precioActualCalculo;
               
               double puntos = diferenciaPrecio / punto;
               
               if(MathAbs(puntos) >= 1.0 && MathAbs(profit) >= 0.01)
               {
                  valorPuntoPorLote = profit / puntos / volumen;
                  
                  Print("Extrayendo valor del punto desde posiciÃ³n #", posInfo.Ticket());
                  Print("  Precio apertura: ", DoubleToString(precioApertura, digits));
                  Print("  Precio actual: ", DoubleToString(precioActualCalculo, digits));
                  Print("  Diferencia puntos: ", DoubleToString(puntos, 1));
                  Print("  Profit actual: ", DoubleToString(profit, 2));
                  Print("  Volumen: ", DoubleToString(volumen, 2));
                  Print("  â†’ Valor 1 punto/lote: ", DoubleToString(valorPuntoPorLote, 2));
                  
                  valorObtenido = true;
                  break;
               }
            }
         }
      }
   }
   
   if(!valorObtenido || MathAbs(valorPuntoPorLote) < 0.1)
   {
      Print("âš  WARNING: No se pudo extraer valor del punto");
      Print("âš  Usando valor aproximado: 8.5");
      valorPuntoPorLote = 8.5;
   }
   
   Print("----------------------------------------------");
   Print(">>> VALOR DEL PUNTO <<<");
   Print("Valor 1 punto (1 lote): ", DoubleToString(valorPuntoPorLote, 2));
   
   double puntosNecesarios = gananciaBrutaNecesaria / (volumenTotalGanadoras * valorPuntoPorLote);
   double diferenciaNecesaria = puntosNecesarios * punto;
   
   double precioTP;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      precioTP = precioPromedioApertura + diferenciaNecesaria;
   else
      precioTP = precioPromedioApertura - diferenciaNecesaria;
   
   precioTP = NormalizeDouble(precioTP, digits);
   
   Print("Volumen total ganadoras: ", DoubleToString(volumenTotalGanadoras, 2));
   Print("Precio promedio apertura: ", DoubleToString(precioPromedioApertura, digits));
   Print("Puntos necesarios: ", DoubleToString(puntosNecesarios, 1));
   Print("Diferencia necesaria: ", DoubleToString(diferenciaNecesaria, digits));
   Print("TP calculado: ", DoubleToString(precioTP, digits));
   
   Print("Precio actual: ", DoubleToString(precioActualCalculo, digits));
   
   bool tpYaSuperado = false;
   if(tipoGanadoras == ORDER_TYPE_BUY)
      tpYaSuperado = (precioActualCalculo >= precioTP);
   else
      tpYaSuperado = (precioActualCalculo <= precioTP);
   
   if(tpYaSuperado)
   {
      Print("========================================");
      Print(">>> TP YA SUPERADO <<<");
      Print(">>> Cerrando TODAS las posiciones");
      Print("========================================");
      
      for(int i = PositionsTotal() - 1; i >= 0; i--)
      {
         if(posInfo.SelectByIndex(i))
         {
            if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
            {
               ulong ticket = posInfo.Ticket();
               if(tradeRollOff.PositionClose(ticket))
               {
                  Print("  âœ“ Cerrada #", ticket);
                  Sleep(50);
               }
            }
         }
      }
      
      for(int i = OrdersTotal() - 1; i >= 0; i--)
      {
         if(ordInfo.SelectByIndex(i))
         {
            if(ordInfo.Magic() == g_numero_magico && ordInfo.Symbol() == _Symbol)
            {
               tradeRollOff.OrderDelete(ordInfo.Ticket());
            }
         }
      }
      
      Print(">>> OBJETIVO ALCANZADO");
      return true;
   }
   
   // ========== PASO 5: CONFIGURAR TP ==========
   Print("========================================");
   Print(">>> PASO 5: CONFIGURAR TP <<<");
   
   int tpsConfigurados = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esGanadora = false;
            if(buyGanando)
               esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
            else
               esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
            
            if(esGanadora)
            {
               ulong ticket = posInfo.Ticket();
               
               if(tradeRollOff.PositionModify(ticket, 0, precioTP))
               {
                  Print("  âœ“ TP configurado #", ticket);
                  tpsConfigurados++;
               }
               else
               {
                  Print("  âœ— Error TP #", ticket);
               }
            }
         }
      }
   }
   
   Print("TPs configurados: ", tpsConfigurados);
   
   // ========== PASO 6: AFINAR TP ==========
   Print("========================================");
   Print(">>> PASO 6: AFINAR TP <<<");
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   Print("GananciaM objetivo: ", DoubleToString(g_ganancia_objetivo, 2));
   
   // ========== CORRECCIÃ“N: Usar valorPuntoPorLote extraÃ­do de posiciÃ³n REAL ==========
   // El valor de SYMBOL_TRADE_TICK_VALUE varÃ­a con el tipo de cambio y no es exacto
   // El valorPuntoPorLote se extrajo de la posiciÃ³n real en PASO 4, es el valor REAL
   // =================================================================================
   Print("Valor punto REAL (extraÃ­do): ", DoubleToString(valorPuntoPorLote, 4));
   
   // Calcular profit esperado usando VALOR REAL del punto
   double profitTotalEsperado = 0;
   int posicionesConTP = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(posInfo.SelectByIndex(i))
      {
         if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
         {
            ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
            
            bool esGanadora = false;
            if(buyGanando)
               esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
            else
               esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
            
            if(esGanadora)
            {
               double tp = posInfo.TakeProfit();
               if(tp != 0)
               {
                  double precioApertura = posInfo.PriceOpen();
                  double volumen = posInfo.Volume();
                  
                  double diferenciaTP;
                  if(tipoPosicion == POSITION_TYPE_BUY)
                     diferenciaTP = tp - precioApertura;
                  else
                     diferenciaTP = precioApertura - tp;
                  
                  double puntosTP = diferenciaTP / punto;
                  double profitEsperado = puntosTP * volumen * valorPuntoPorLote;
                  
                  Print("  Pos #", posInfo.Ticket(), " Vol:", DoubleToString(volumen, 2));
                  Print("    TP: ", DoubleToString(tp, digits), " Puntos: ", DoubleToString(puntosTP, 1));
                  Print("    Profit esperado: ", DoubleToString(profitEsperado, 2));
                  
                  profitTotalEsperado += profitEsperado;
                  posicionesConTP++;
               }
            }
         }
      }
   }
   
   Print("----------------------------------------------");
   Print("PROFIT TOTAL esperado (TP actual): ", DoubleToString(profitTotalEsperado, 2));
   Print("Ganancia BRUTA necesaria: ", DoubleToString(gananciaBrutaNecesaria, 2));
   
   double diferencia = profitTotalEsperado - gananciaBrutaNecesaria;
   Print("Diferencia: ", DoubleToString(diferencia, 3));
   
   double resultadoProyectado = g_ganancia_objetivo + diferencia;
   Print("Resultado proyectado: ", DoubleToString(resultadoProyectado, 3));
   
   bool peligroCritico = (resultadoProyectado <= 0.005);
   
   if(peligroCritico)
   {
      Print("========================================");
      Print("ðŸš¨ PELIGRO CRÃTICO DETECTADO");
      Print("   Resultado proyectado: ", DoubleToString(resultadoProyectado, 3));
      Print("   Â¡Resultado serÃ­a NEGATIVO o CERO!");
      Print("   MODO EMERGENCIA: BÃºsqueda exhaustiva");
      Print("========================================");
   }
   
   if(peligroCritico || MathAbs(diferencia) > 0.015)
   {
      Print(">>> Iniciando bÃºsqueda de TP Ã³ptimo...");
      
      double mejorTP = precioTP;
      double mejorResultado = resultadoProyectado;
      int iteracionMejor = 0;
      bool tpSeguroEncontrado = false;
      
      int rangoInicio, rangoFin;
      
      if(peligroCritico)
      {
         rangoInicio = 1;
         rangoFin = 100;
         Print("MODO EMERGENCIA: BÃºsqueda de i=", rangoInicio, " a ", rangoFin);
         Print("Objetivo: Encontrar resultado POSITIVO (> 0.01)");
      }
      else
      {
         rangoInicio = -10;
         rangoFin = 10;
         Print("Modo estÃ¡ndar: BÃºsqueda de i=", rangoInicio, " a ", rangoFin);
      }
      
      for(int i = rangoInicio; i <= rangoFin; i++)
      {
         double tpPrueba;
         if(tipoGanadoras == ORDER_TYPE_BUY)
            tpPrueba = precioTP + (i * punto);
         else
            tpPrueba = precioTP - (i * punto);
         
         tpPrueba = NormalizeDouble(tpPrueba, digits);
         
         double profitConEstTP = 0;
         
         for(int j = 0; j < PositionsTotal(); j++)
         {
            if(posInfo.SelectByIndex(j))
            {
               if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
               {
                  ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
                  
                  bool esGanadora = false;
                  if(buyGanando)
                     esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
                  else
                     esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
                  
                  if(esGanadora)
                  {
                     double precioApertura = posInfo.PriceOpen();
                     double volumen = posInfo.Volume();
                     
                     double diferenciaTP;
                     if(tipoPosicion == POSITION_TYPE_BUY)
                        diferenciaTP = tpPrueba - precioApertura;
                     else
                        diferenciaTP = precioApertura - tpPrueba;
                     
                     double puntosTP = diferenciaTP / punto;
                     double profitEsperado = puntosTP * volumen * valorPuntoPorLote;
                     
                     profitConEstTP += profitEsperado;
                  }
               }
            }
         }
         
         double diferenciaConEstTP = profitConEstTP - gananciaBrutaNecesaria;
         double resultadoConEstTP = g_ganancia_objetivo + diferenciaConEstTP;
         
         if(peligroCritico)
         {
            if(i <= 10 || i % 5 == 0)
            {
               Print("  i=", i, " TP:", DoubleToString(tpPrueba, digits),
                     " Resultado:", DoubleToString(resultadoConEstTP, 3));
            }
         }
         else
         {
            if(i % 5 == 0)
            {
               Print("  i=", i, " TP:", DoubleToString(tpPrueba, digits),
                     " Dif:", DoubleToString(diferenciaConEstTP, 3),
                     " Resultado:", DoubleToString(resultadoConEstTP, 3));
            }
         }
         
         if(peligroCritico)
         {
            if(resultadoConEstTP >= 0.01 && !tpSeguroEncontrado)
            {
               mejorTP = tpPrueba;
               mejorResultado = resultadoConEstTP;
               iteracionMejor = i;
               tpSeguroEncontrado = true;
               
               Print("========================================");
               Print("âœ… TP SEGURO ENCONTRADO");
               Print("   IteraciÃ³n: ", i);
               Print("   TP: ", DoubleToString(mejorTP, digits));
               Print("   Resultado proyectado: ", DoubleToString(mejorResultado, 3));
               Print("========================================");
               
               break;
            }
         }
         else
         {
            if(MathAbs(diferenciaConEstTP) < MathAbs(mejorResultado - g_ganancia_objetivo))
            {
               mejorTP = tpPrueba;
               mejorResultado = resultadoConEstTP;
               iteracionMejor = i;
            }
         }
      }
      
      if(peligroCritico && !tpSeguroEncontrado)
      {
         Print("========================================");
         Print("âš ï¸ ADVERTENCIA CRÃTICA");
         Print("   No se encontrÃ³ TP seguro en 100 puntos");
         Print("   Usando TP extremo como Ãºltimo recurso");
         
         if(tipoGanadoras == ORDER_TYPE_BUY)
            mejorTP = precioTP + (100 * punto);
         else
            mejorTP = precioTP - (100 * punto);
         
         mejorTP = NormalizeDouble(mejorTP, digits);
         
         Print("   TP Ãºltimo recurso: ", DoubleToString(mejorTP, digits));
         Print("   Esto garantiza resultado muy positivo");
         Print("========================================");
      }
      
      Print("----------------------------------------------");
      Print(">>> RESULTADO DE BÃšSQUEDA <<<");
      Print("TP anterior: ", DoubleToString(precioTP, digits));
      Print("TP Ã³ptimo: ", DoubleToString(mejorTP, digits));
      Print("IteraciÃ³n: ", iteracionMejor);
      Print("Resultado FINAL proyectado: ", DoubleToString(mejorResultado, 3));
      
      double cambio = MathAbs(mejorTP - precioTP);
      double cambioEnPuntos = cambio / punto;
      Print("Cambio: ", DoubleToString(cambioEnPuntos, 1), " puntos");
      
      if(mejorTP != precioTP)
      {
         Print(">>> Aplicando TP Ã³ptimo...");
         
         int tpsAjustados = 0;
         for(int i = 0; i < PositionsTotal(); i++)
         {
            if(posInfo.SelectByIndex(i))
            {
               if(posInfo.Magic() == g_numero_magico && posInfo.Symbol() == _Symbol)
               {
                  ENUM_POSITION_TYPE tipoPosicion = posInfo.PositionType();
                  
                  bool esGanadora = false;
                  if(buyGanando)
                     esGanadora = (tipoPosicion == POSITION_TYPE_BUY);
                  else
                     esGanadora = (tipoPosicion == POSITION_TYPE_SELL);
                  
                  if(esGanadora)
                  {
                     ulong ticket = posInfo.Ticket();
                     
                     if(tradeRollOff.PositionModify(ticket, 0, mejorTP))
                     {
                        Print("  âœ“ TP ajustado #", ticket, " â†’ ", DoubleToString(mejorTP, digits));
                        tpsAjustados++;
                     }
                     else
                     {
                        Print("  âœ— Error ajustando #", ticket, " Error:", GetLastError());
                     }
                  }
               }
            }
         }
         
         Print("TPs ajustados: ", tpsAjustados);
         precioTP = mejorTP;
      }
      else
      {
         Print(">>> TP actual es Ã³ptimo");
      }
   }
   else
   {
      Print(">>> Diferencia aceptable, no se requiere ajuste");
      Print(">>> Resultado proyectado: ", DoubleToString(resultadoProyectado, 3), " âœ“");
   }
   
   Print("========================================");
   
   // ORDEN PROTECCIÃ“N
   Print("----------------------------------------------");
   Print(">>> ORDEN PROTECCIÃ“N NEUTRALIZADORA <<<");
   
   double precioOrdenPendiente;
   ENUM_ORDER_TYPE tipoOrdenPendiente;
   int ticksProteccion = 3;
   
   if(tipoGanadoras == ORDER_TYPE_BUY)
   {
      precioOrdenPendiente = precioPromedioApertura + (ticksProteccion * punto);
      tipoOrdenPendiente = ORDER_TYPE_SELL_STOP;
   }
   else
   {
      precioOrdenPendiente = precioPromedioApertura - (ticksProteccion * punto);
      tipoOrdenPendiente = ORDER_TYPE_BUY_STOP;
   }
   
   precioOrdenPendiente = NormalizeDouble(precioOrdenPendiente, digits);
   
   Print("Precio apertura ganadoras: ", DoubleToString(precioPromedioApertura, digits));
   Print("Distancia protecciÃ³n: ", ticksProteccion, " ticks");
   Print("Tipo: ", (tipoOrdenPendiente == ORDER_TYPE_BUY_STOP ? "BUY STOP" : "SELL STOP"));
   Print("Volumen: ", DoubleToString(volumenTotalGanadoras, 2));
   Print("Precio orden: ", DoubleToString(precioOrdenPendiente, digits));
   
   if(tradeRollOff.OrderOpen(_Symbol, tipoOrdenPendiente, volumenTotalGanadoras, 0, 
                      precioOrdenPendiente, 0, 0, 
                      ORDER_TIME_GTC, 0, 
                      "RollOff_Proteccion"))
   {
      Print("âœ“ Orden protecciÃ³n #", tradeRollOff.ResultOrder());
   }
   
   Print("----------------------------------------------");
   Print(">>> PRECIO REFERENCIA <<<");
   
   if(MathAbs(g_precio_activacion_roll_off - precioAperturaUltimaGanadora) > (punto * 2))
   {
      g_precio_activacion_roll_off = precioAperturaUltimaGanadora;
      Print("âœ“ ACTUALIZADO: ", DoubleToString(g_precio_activacion_roll_off, digits));
   }
   else
   {
      Print("âœ“ MANTIENE: ", DoubleToString(g_precio_activacion_roll_off, digits));
   }
   
   Print("==========================================");
   Print(">>> Roll-Off completado");
   Print("==========================================");
   
   g_ultimo_roll_off = TimeCurrent();
   
   return true;
}
