DIALOGOS DE EXPERTO ENTRADA # 4

2025.08.14 09:12:00.941	Monedita de Oro - Coberturas (EURUSD,M1)	Cambio de chart detectado - Asegurando persistencia de √≥rdenes
2025.08.14 09:12:00.942	Monedita de Oro - Coberturas (EURUSD,M1)	Guardado estado de secuencia #890 para persistencia entre timeframes
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Interfaz ya existe, omitiendo creaci√≥n
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurado contador de IDs de secuencia desde cambio de temporalidad: 891
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurando 3 secuencias guardadas
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #890 - Modo: VENTA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #882 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #638 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:00.947	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:01.124	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.195	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.247	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.298	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.373	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.462	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.518	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.607	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.683	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.739	Monedita de Oro - Coberturas (EURUSD,M1)	? Activaci√≥n muy reciente en secuencia #890 - Esperando...
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üîÑ RECALCULANDO PRECIO VIRTUAL - Nueva entrada detectada
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Secuencia #890
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Entradas anteriores: 2
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Entradas actuales: 3
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	===== C√ÅLCULO DE PRECIO VIRTUAL =====
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Secuencia #890
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	  SELL 0.01 @ 1.16447
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	  BUY 0.02 @ 1.16467
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	  SELL 0.04 @ 1.16447
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	BID: 1.16447 / ASK: 1.16447
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Spread: 0 puntos
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Comisiones: ‚Ç¨0.72
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Swaps: ‚Ç¨0.00
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Objetivo: ‚Ç¨0.10
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	PRECIO VIRTUAL CALCULADO: 1.16406
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Direcci√≥n: CORTA (precio debe bajar)
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Ganancia esperada: ‚Ç¨0.11
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	Diferencia con objetivo: ‚Ç¨0.0100
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	‚úÖ Precio virtual: 1.16406
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üí∞ Objetivo: ‚Ç¨0.10
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	üìå La secuencia contin√∫a activa hasta tocar el precio virtual
2025.08.14 09:12:01.740	Monedita de Oro - Coberturas (EURUSD,M1)	?? Activaci√≥n detectada - Programando siguiente entrada
2025.08.14 09:12:01.845	Monedita de Oro - Coberturas (EURUSD,M1)	?? Programando BUY STOP SEC890_ENT4 con TP individual: 1.16567
2025.08.14 09:12:01.845	Monedita de Oro - Coberturas (EURUSD,M1)	Orden #172640805 registrada en secuencia #890
2025.08.14 09:12:01.845	Monedita de Oro - Coberturas (EURUSD,M1)	? SEC890_ENT4 programada exitosamente - Ticket: 172640805 - TP: 1.16567
2025.08.14 09:12:01.845	Monedita de Oro - Coberturas (EURUSD,M1)	?? Nota: Sistema de cierre virtual activo - Se cerrar√° TODO al alcanzar ganancia objetivo
2025.08.14 09:12:01.849	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #882
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #638
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:01.883	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:13.255	Monedita de Oro - Coberturas (EURUSD,M1)	? Activaci√≥n muy reciente en secuencia #890 - Esperando...
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	? Activaci√≥n muy reciente en secuencia #890 - Esperando...
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	üîÑ RECALCULANDO PRECIO VIRTUAL - Nueva entrada detectada
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Secuencia #890
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Entradas anteriores: 3
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	üìç Entradas actuales: 4
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	===== C√ÅLCULO DE PRECIO VIRTUAL =====
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	Secuencia #890
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	  SELL 0.01 @ 1.16447
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	  BUY 0.02 @ 1.16467
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	  SELL 0.04 @ 1.16447
2025.08.14 09:12:13.320	Monedita de Oro - Coberturas (EURUSD,M1)	  BUY 0.08 @ 1.16467
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	BID: 1.16465 / ASK: 1.16465
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Spread: 0 puntos
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Comisiones: ‚Ç¨1.56
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Swaps: ‚Ç¨0.00
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Objetivo: ‚Ç¨0.10
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	PRECIO VIRTUAL CALCULADO: 1.16520
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Direcci√≥n: LARGA (precio debe subir)
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Ganancia esperada: ‚Ç¨0.09
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	Diferencia con objetivo: ‚Ç¨0.0100
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	‚úÖ Precio virtual: 1.16520
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	üí∞ Objetivo: ‚Ç¨0.10
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	üìå La secuencia contin√∫a activa hasta tocar el precio virtual
2025.08.14 09:12:13.321	Monedita de Oro - Coberturas (EURUSD,M1)	?? Activaci√≥n detectada - Programando siguiente entrada
2025.08.14 09:12:13.436	Monedita de Oro - Coberturas (EURUSD,M1)	?? Programando SELL STOP SEC890_ENT5 con TP individual: 1.16347
2025.08.14 09:12:13.436	Monedita de Oro - Coberturas (EURUSD,M1)	Orden #172640834 registrada en secuencia #890
2025.08.14 09:12:13.436	Monedita de Oro - Coberturas (EURUSD,M1)	? SEC890_ENT5 programada exitosamente - Ticket: 172640834 - TP: 1.16347
2025.08.14 09:12:13.436	Monedita de Oro - Coberturas (EURUSD,M1)	?? Nota: Sistema de cierre virtual activo - Se cerrar√° TODO al alcanzar ganancia objetivo
2025.08.14 09:12:23.596	Monedita de Oro - Coberturas (EURUSD,M1)	Cambio de chart detectado - Asegurando persistencia de √≥rdenes
2025.08.14 09:12:23.596	Monedita de Oro - Coberturas (EURUSD,M1)	Guardado estado de secuencia #890 para persistencia entre timeframes
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Interfaz ya existe, omitiendo creaci√≥n
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurado contador de IDs de secuencia desde cambio de temporalidad: 891
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurando 4 secuencias guardadas
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #890 - Modo: VENTA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #882 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #638 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:12:23.601	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:12:24.026	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.321	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.459	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.524	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.583	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.847	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:24.968	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.019	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.088	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.138	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.198	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.786	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:25.964	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:26.442	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:26.504	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:26.912	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:26.973	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:27.822	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:27.871	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:28.066	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:28.122	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:29.525	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:29.618	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:29.737	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:30.021	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:30.253	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:30.508	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:30.830	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:30.992	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:31.127	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:31.399	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:31.972	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #882
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #638
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:12:31.975	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1

HORA EN SE ACANZO EL PRECIO DE CIERRE VIRTUAL:
2025.08.14 09:17:00.931	Monedita de Oro - Coberturas (EURUSD,M1)	Cambio de chart detectado - Asegurando persistencia de √≥rdenes
2025.08.14 09:17:00.936	Monedita de Oro - Coberturas (EURUSD,M1)	Interfaz ya existe, omitiendo creaci√≥n
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurado contador de IDs de secuencia desde cambio de temporalidad: 891
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurando 38 secuencias guardadas
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #890 - Modo: VENTA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #882 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #638 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: S√≠, Cerrada manualmente: S√≠
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: VENTA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: No
2025.08.14 09:17:00.937	Monedita de Oro - Coberturas (EURUSD,M1)	Restaurada secuencia #1 - Modo: COMPRA, Entrada2 pendiente: No, Cerrada manualmente: S√≠
2025.08.14 09:17:03.472	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:17:03.505	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:17:03.616	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:17:04.352	Monedita de Oro - Coberturas (EURUSD,M1)	?? No se recrea orden pendiente ENTRADA #2 para secuencia #638 porque fue cerrada manualmente
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #890
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #882
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #638
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1
2025.08.14 09:17:04.363	Monedita de Oro - Coberturas (EURUSD,M1)	?? Limpiando secuencia fantasma #1

CODIGO COMPLETO DEL BOT CON LA ULTIMA VERSI√ìN:

int GetCurrentDeviation() {
    return 10; // Devolver el valor por defecto
}

//+------------------------------------------------------------------+
//| Funci√≥n para encontrar la secuencia que corresponde a un ticket  |
//+------------------------------------------------------------------+
int EncontrarSecuenciaPorTicket(ulong ticket)
{
    if(ticket == 0) return -1;
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Buscar primero en tickets registrados espec√≠ficos
            if(secuencias[i].ticketEntrada1 == ticket || secuencias[i].ticketEntrada2 == ticket)
                return i;
                
            // Buscar en array de √∫ltimas √≥rdenes
            for(int j = 0; j < secuencias[i].numOrdenes; j++)
            {
                if(secuencias[i].ultimasOrdenes[j] == ticket)
                    return i;
            }
        }
    }
    
    return -1; // No encontrado
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.00"
#property strict

// Incluir archivos necesarios
#include <Trade\Trade.mqh>

// Prefijo para identificar objetos del EA
string EA_OBJ_PREFIX = "EA_SECUENCIAS_";

// Identificadores de objetos
string panelPrincipalID = "PanelPrincipal";
string editLotajeID = "EditLotaje";
string botonCompraID = "BotonCompra";
string botonVentaID = "BotonVenta";
string editTP1ID = "EditTP1";
string editPipsEntrada2ID = "EditPipsEntrada2";
string editTP2ID = "EditTP2";
string editNumEntradaID = "EditNumEntrada"; 
string editMinimaGID = "EditMinimaG"; // Campo para Minima G.
string editNumCerrarID = "EditNumCerrar"; // NUEVO campo para # Cerrar

// Variables globales
double LotajeInicial = 0.01;
int TP1Puntos = 100;
int PipsEntrada2 = 20;
int TP2Puntos = 100;
int NumEntrada = 0; // CAMBIADO: Inicializado en 0 para permitir campo vac√≠o
double MinimaG = 0.0; // Valor para el campo Minima G.
int NumCerrar = 0; // N√∫mero de entrada en el que se cerrar√° toda la secuencia
bool interfazCreada = false;

// Variable para controlar la verificaci√≥n de √≥rdenes pendientes
datetime ultimaVerificacionPendientes = 0;

// Estructura para almacenar datos de secuencia
struct SecuenciaInfo {
    int id;                  // Identificador √∫nico de secuencia
    bool activa;             // Si la secuencia est√° activa
    double precioEntrada1;   // Precio de la entrada 1
    double precioEntrada2;   // Precio de la entrada 2
    double tp1Precio;        // Precio TP de entrada 1
    double tp2Precio;        // Precio TP de entrada 2
    int secuenciaActual;     // N√∫mero actual de entrada en la secuencia
    datetime tiempoInicio;   // Tiempo de inicio
    ulong ultimasOrdenes[10]; // Tickets de las √∫ltimas √≥rdenes en la secuencia
    int numOrdenes;          // Contador de √≥rdenes en ultimasOrdenes
    datetime ultimaVerificacionTP; // √öltimo tiempo de verificaci√≥n de TP
    bool tpAlcanzado;        // Indica si se detect√≥ TP
    bool cerradaCompletamente; // Indica si la secuencia se cerr√≥ completamente
    int intentosCierre;      // Contador de intentos de cierre
    datetime ultimoCierreIntentado; // √öltimo momento en que se intent√≥ cerrar
    bool esModoCompra;       // Indica si es una secuencia iniciada con COMPRA (true) o VENTA (false)
    ulong ticketEntrada1;    // Ticket de la entrada 1
    ulong ticketEntrada2;    // Ticket de la entrada 2
    bool entradaPendienteActiva; // Indica si hay una entrada pendiente activa
    datetime ultimaRecreacionPendiente; // Tiempo de la √∫ltima recreaci√≥n de la orden pendiente
    bool cerradaManualmente; // Indica si la entrada pendiente fue cerrada manualmente
    datetime ultimaVerificacionPendientes; // √öltimo tiempo que se verific√≥ si hay pendientes
    bool sinOrdenesPendientesDetectado; // Flag para saber si ya se detect√≥ que no hay pendientes
    bool tpReubicado;  // Nuevo campo para controlar si ya se reubic√≥ el TP
    int ultimasPosicionesConsideradas; // N√∫mero de posiciones en el √∫ltimo c√°lculo de TP
};

// Array para almacenar m√∫ltiples secuencias sin l√≠mite estricto
SecuenciaInfo secuencias[20]; // Ampliado a 20 secuencias para dar m√°s holgura
int totalSecuencias = 0;
int proximoIDSecuencia = 1;

// Instancia de CTrade
CTrade trade;

// Declaraciones previas de funciones para evitar errores de compilaci√≥n
void CerrarSecuencia(int indice);
void CerrarTodasLasOrdenesDeSecuencia(int indice, bool cierreRapido = false);
void RecuperarOrdenesPendientes();
void CerrarTodasLasSecuencias();
void IniciarSecuencia(bool esCompra);
void IniciarSecuenciaCompra();
void IniciarSecuenciaVenta();
void LimpiarSecuenciasFantasma();
void VerificarOrdenesPendientes();
void VerificarCierrePorFaltaDePendientes();
void VerificarNuevasActivaciones(int indice);
void VerificarCierrePorNumeroEntrada(int indiceSecuencia);
bool RecrearOrdenEntrada2(int indice);
void GuardarEstadoSecuencias();
void GuardarEstadoSecuenciasConID();
void ResetearSecuencia(int indice);
void RestaurarEstadoSecuencias();
void CrearInterfaz();
void CrearPanelPrincipal(int x, int y, int ancho, int alto);
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor);
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor);
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia);
void DiagnosticarSecuencia(int indiceSecuencia);
void LimpiarOrdenesHuerfanas();
void GuardarValores();
void RegistrarOrden(int indice, ulong ticket, string comentario="");
void ProgramarSiguienteEntrada(int indice);
int EncontrarSecuenciaPorTicket(ulong ticket);
void RecalcularTotalSecuencias();
void LimpiarSecuenciasProblematicas();
void ActualizarInformacionSecuencias();
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples);
void EliminarOrdenesPendientesDuplicadas(int indice);
double CalcularComisionPepperstone(double volumen);
double CalcularPLTotalConTP(int indiceSecuencia, double precioTP);
bool VerificarExistenciaOrdenPendiente(ulong ticket);
void ResetearTodasLasSecuencias();
void RestaurarValores();

//+------------------------------------------------------------------+
//| Funci√≥n para capturar eventos de trading (√≥rdenes, posiciones)   |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                       const MqlTradeRequest& request,
                       const MqlTradeResult& result)
{
    // Solo nos interesa detectar eliminaciones de √≥rdenes pendientes
    if(trans.type == TRADE_TRANSACTION_ORDER_DELETE)
    {
        ulong ticketEliminado = trans.order;
        
        // Encontrar a qu√© secuencia pertenece esta orden
        int indiceSecuencia = EncontrarSecuenciaPorTicket(ticketEliminado);
        if(indiceSecuencia >= 0)
        {
            // Verificar si es la orden ENTRADA #2
            if(secuencias[indiceSecuencia].ticketEntrada2 == ticketEliminado)
            {
                // Si la raz√≥n de eliminaci√≥n NO es cambio de timeframe o activaci√≥n,
                // asumimos que fue eliminaci√≥n manual
                if(trans.order_state == ORDER_STATE_CANCELED)
                {
                    Print("??? Detectada eliminaci√≥n manual de orden pendiente #", ticketEliminado, 
                          " para secuencia #", secuencias[indiceSecuencia].id);
                    
                    secuencias[indiceSecuencia].cerradaManualmente = true;
                    secuencias[indiceSecuencia].entradaPendienteActiva = false;
                    
                    // Guardar este estado para persistencia
                    GuardarEstadoSecuencias();
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    // Asegurarse de que la interfaz siempre est√° presente
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Si se detecta un cambio en alg√∫n control de edici√≥n
    if(id == CHARTEVENT_OBJECT_ENDEDIT) 
    {
        // Capturar el valor actualizado cada vez que el usuario edita un campo
        if(sparam == EA_OBJ_PREFIX + editLotajeID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            LotajeInicial = StringToDouble(texto);
            // Guardar inmediatamente
            GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
            Print("Lotaje actualizado a: ", LotajeInicial);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP1ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP1Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
            Print("TP1 actualizado a: ", TP1Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editPipsEntrada2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            PipsEntrada2 = (int)StringToInteger(texto);
            GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
            Print("Pips Entrada2 actualizado a: ", PipsEntrada2);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP2Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
            Print("TP2 actualizado a: ", TP2Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumEntradaID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vac√≠o o "0"
            if(texto == "" || texto == "0")
            {
                NumEntrada = 0;
            }
            else
            {
                NumEntrada = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
            Print("# Reubicar actualizado a: ", NumEntrada);
        }
        else if(sparam == EA_OBJ_PREFIX + editMinimaGID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            MinimaG = StringToDouble(texto);
            GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
            Print("Minima G. actualizada a: ", MinimaG);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumCerrarID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vac√≠o o "0"
            if(texto == "" || texto == "0")
            {
                NumCerrar = 0;
            }
            else
            {
                NumCerrar = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
            Print("# Cerrar actualizado a: ", NumCerrar);
        }
    }
    
    // Si se detecta un cambio de timeframe
    if(id == CHARTEVENT_CHART_CHANGE)
    {
        Print("Cambio de chart detectado - Asegurando persistencia de √≥rdenes");
        
        // Guardar el estado actual de las secuencias antes del cambio, incluyendo ID
        GuardarEstadoSecuenciasConID();
        
        // Guardar los valores actuales de los controles antes de recrear la interfaz
        if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
            LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
            TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
            PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
            TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumEntrada = 0;
            else
                NumEntrada = (int)StringToInteger(texto);
        }
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
            MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumCerrar = 0;
            else
                NumCerrar = (int)StringToInteger(texto);
        }
        
        // Guardar expl√≠citamente estos valores
        GuardarValores();
        
        // Recrear la interfaz si es necesario
        CrearInterfaz();
        
        // Verificar y recrear √≥rdenes pendientes que puedan haberse perdido
        for(int i = 0; i < 10; i++)
        {
            if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
            {
                Print("?? Verificando orden pendiente para secuencia #", secuencias[i].id, " despu√©s de cambio de timeframe");
                secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificaci√≥n inmediata
                RecrearOrdenEntrada2(i);
            }
        }
        
        // Para evitar perder objetos dibujados manualmente, no hacer limpieza general
        return;
    }
    
    // Gesti√≥n de clics en botones
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        // Verificar si se ha hecho clic en uno de nuestros botones
        if(sparam == EA_OBJ_PREFIX + botonCompraID)
        {
            Print("Bot√≥n COMPRA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonCompraID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricci√≥n de l√≠mite
            IniciarSecuenciaCompra();
        }
        else if(sparam == EA_OBJ_PREFIX + botonVentaID)
        {
            Print("Bot√≥n VENTA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonVentaID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricci√≥n de l√≠mite
            IniciarSecuenciaVenta();
        }
    }
}

//+------------------------------------------------------------------+
//| Verificar si se debe cerrar la secuencia por n√∫mero de entrada  |
//+------------------------------------------------------------------+
void VerificarCierrePorNumeroEntrada(int indiceSecuencia)
{
    // Verificar que la secuencia est√© activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
    
    // Obtener el valor del campo "# Cerrar"
    string textoNumCerrar = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
    
    // Si el campo est√° vac√≠o o es "0", no cerrar por n√∫mero de entrada
    if(textoNumCerrar == "" || textoNumCerrar == "0")
        return;
    
    int numeroCerrar = (int)StringToInteger(textoNumCerrar);
    
    // Contar las posiciones activas de esta secuencia
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesActivas = 0;
    
    // Contar posiciones
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesActivas++;
        }
    }
    
    // Si se alcanz√≥ o super√≥ el n√∫mero de entrada configurado, cerrar toda la secuencia
    if(posicionesActivas >= numeroCerrar)
    {
        string tipoSecuencia = secuencias[indiceSecuencia].esModoCompra ? "COMPRA" : "VENTA";
        Print("\n?? CIERRE POR N√öMERO DE ENTRADA #", numeroCerrar, " ALCANZADO");
        Print("?? Secuencia #", secuencias[indiceSecuencia].id, " (", tipoSecuencia, ")");
        Print("?? Posiciones activas: ", posicionesActivas);
        Print("? CERRANDO TODAS LAS √ìRDENES");
        
        // Marcar para cierre
        secuencias[indiceSecuencia].tpAlcanzado = true;
        secuencias[indiceSecuencia].ultimoCierreIntentado = TimeCurrent();
        
        // Cerrar todas las √≥rdenes
        CerrarTodasLasOrdenesDeSecuencia(indiceSecuencia, true);
        CerrarSecuencia(indiceSecuencia);
        
        // Actualizar el estado
        GuardarEstadoSecuencias();
    }
}

//+------------------------------------------------------------------+
//| Limpiar √≥rdenes hu√©rfanas (sin secuencia asociada)              |
//+------------------------------------------------------------------+
void LimpiarOrdenesHuerfanas()
{
    // Esta funci√≥n se ejecuta menos frecuentemente
    static datetime ultimaLimpieza = 0;
    if(TimeCurrent() - ultimaLimpieza < 30) return; // Solo cada 30 segundos
    
    ultimaLimpieza = TimeCurrent();
    
    // Buscar √≥rdenes pendientes con prefijo "SEC" pero sin secuencia activa
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, "SEC") == 0)
        {
            // Extraer el ID de secuencia
            int pos1 = StringFind(comentario, "SEC") + 3;
            int pos2 = StringFind(comentario, "_", pos1);
            if(pos2 == -1) continue;
            
            string idStr = StringSubstr(comentario, pos1, pos2 - pos1);
            int secId = (int)StringToInteger(idStr);
            
            // Verificar si la secuencia est√° activa
            bool secuenciaEncontrada = false;
            for(int j = 0; j < 10; j++)
            {
                if(secuencias[j].activa && secuencias[j].id == secId)
                {
                    secuenciaEncontrada = true;
                    break;
                }
            }
            
            // Si no se encontr√≥ una secuencia activa para esta orden, cerrarla
            if(!secuenciaEncontrada)
            {
                Print("?? Eliminando orden hu√©rfana #", ticket, " - Comentario: ", comentario);
                trade.OrderDelete(ticket);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n para resetear todas las secuencias (emergencia)          |
//+------------------------------------------------------------------+
void ResetearTodasLasSecuencias()
{
    Print("?? REINICIO DE EMERGENCIA - Reseteando todas las secuencias");
    
    // Primero intenta cerrar todas las posiciones activas
    CerrarTodasLasSecuencias();
    
    // Luego resetear el estado de todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        ResetearSecuencia(i);
    }
    
    // Resetear el contador y el ID
    totalSecuencias = 0;
    proximoIDSecuencia = 1;
    
    // Guardar el estado
    GuardarEstadoSecuencias();
    
    Print("? Reinicio de emergencia completado - Todas las secuencias han sido reseteadas");
}

//+------------------------------------------------------------------+
//| Funci√≥n para resetear el contador de secuencias activas         |
//+------------------------------------------------------------------+
void RecalcularTotalSecuencias()
{
    int contador = 0;
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
            contador++;
    }
    
    // Si el contador est√° inconsistente, arreglarlo
    if(contador != totalSecuencias)
    {
        Print("?? Corrigiendo contador de secuencias: de ", totalSecuencias, " a ", contador);
        totalSecuencias = contador;
        GuardarEstadoSecuencias();
    }
}
//+------------------------------------------------------------------+
//| Funci√≥n para limpiar secuencias problem√°ticas                    |
//+------------------------------------------------------------------+
void LimpiarSecuenciasProblematicas()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (√≥rdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar √≥rdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos √≥rdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // √öltimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("?? Limpiando secuencia #", secuencias[i].id, " - No se encontr√≥ actividad asociada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                }
            }
        }
    }
    
    // Guardar el estado actualizado
    GuardarEstadoSecuencias();
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 5: ActualizarInformacionSecuencias() - SIMPLIFICADA     |
//| Elimina todos los textos molestos                               |
//+------------------------------------------------------------------+
void ActualizarInformacionSecuencias()
{
    // Eliminar TODOS los objetos de informaci√≥n
    for(int i = 0; i < 20; i++)
    {
        ObjectDelete(0, EA_OBJ_PREFIX + "SecInfo_" + IntegerToString(i));
        ObjectDelete(0, EA_OBJ_PREFIX + "BtnCerrarSec_" + IntegerToString(i));
    }
    
    // Eliminar t√≠tulo y cualquier otro texto
    ObjectDelete(0, EA_OBJ_PREFIX + "SecInfoTitulo");
    
    // Solo redibujar el gr√°fico
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Funci√≥n mejorada para verificar si una secuencia tiene √≥rdenes      |
//| pendientes evitando duplicados                                      |
//+------------------------------------------------------------------+
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples)
{
    if(!secuencias[indice].activa) return false;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    int contadorOrdenes = 0;
    tieneMultiples = false;
    
    // Comprobar si hay √≥rdenes pendientes para esta secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            contadorOrdenes++;
            if(contadorOrdenes > 1)
            {
                tieneMultiples = true;
                break;
            }
        }
    }
    
    return (contadorOrdenes > 0);
}

//+------------------------------------------------------------------+
//| Nueva funci√≥n para eliminar √≥rdenes pendientes duplicadas         |
//+------------------------------------------------------------------+
void EliminarOrdenesPendientesDuplicadas(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    string entradaActualPattern = "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    
    // Preparar arrays para almacenar tickets de √≥rdenes por tipo
    int maxOrdenesPorTipo = 10; // Ajustar seg√∫n sea necesario
    ulong ticketsENT2[10];      // para √≥rdenes de entrada 2
    ulong ticketsEntradaActual[10]; // para √≥rdenes de la entrada actual 
    int contadorENT2 = 0;
    int contadorEntradaActual = 0;
    
    // Buscar y clasificar todas las √≥rdenes pendientes de la secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        
        // Si pertenece a esta secuencia
        if(StringFind(comentario, secPrefix) == 0)
        {
            // Verificar si es una orden ENT2
            if(StringFind(comentario, "_ENT2") >= 0 && contadorENT2 < maxOrdenesPorTipo)
            {
                ticketsENT2[contadorENT2++] = ticket;
            }
            // Verificar si es una orden de la entrada actual
            else if(StringFind(comentario, entradaActualPattern) >= 0 && contadorEntradaActual < maxOrdenesPorTipo)
            {
                ticketsEntradaActual[contadorEntradaActual++] = ticket;
            }
        }
    }
    
    // Eliminar todas las √≥rdenes ENT2 duplicadas excepto la primera (si hay m√°s de una)
    if(contadorENT2 > 1)
    {
        Print("?? Encontradas ", contadorENT2, " √≥rdenes ENT2 duplicadas para secuencia #", secuencias[indice].id, " - Eliminando extras");
        
        // Solo conservar la primera orden, eliminar las dem√°s
        for(int i = 1; i < contadorENT2; i++)
        {
            if(OrderSelect(ticketsENT2[i]) && trade.OrderDelete(ticketsENT2[i]))
            {
                Print("? Eliminada orden ENT2 duplicada #", ticketsENT2[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("? Error al eliminar orden ENT2 duplicada #", ticketsENT2[i], ": ", GetLastError());
            }
        }
        
        // Actualizar el ticket de entrada2 con el ticket conservado
        if(OrderSelect(ticketsENT2[0]))
        {
            secuencias[indice].ticketEntrada2 = ticketsENT2[0];
            Print("?? Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticketsENT2[0]);
        }
    }
    
    // Eliminar todas las √≥rdenes de la entrada actual duplicadas excepto la primera (si hay m√°s de una)
    if(contadorEntradaActual > 1)
    {
        Print("?? Encontradas ", contadorEntradaActual, " √≥rdenes entrada actual duplicadas para secuencia #", 
              secuencias[indice].id, " (Fase: ", secuencias[indice].secuenciaActual, ") - Eliminando extras");
              // Solo conservar la primera orden, eliminar las dem√°s
        for(int i = 1; i < contadorEntradaActual; i++)
        {
            if(OrderSelect(ticketsEntradaActual[i]) && trade.OrderDelete(ticketsEntradaActual[i]))
            {
                Print("? Eliminada orden entrada duplicada #", ticketsEntradaActual[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("? Error al eliminar orden duplicada #", ticketsEntradaActual[i], ": ", GetLastError());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n para obtener tasa de conversi√≥n USD                     |
//+------------------------------------------------------------------+
double GetUSDConversionRate(string fromCurrency)
{
    // Si la moneda ya es USD, no necesita conversi√≥n
    if(fromCurrency == "USD") return 1.0;
    
    // Para EUR, usar tasa aproximada (deber√≠as obtener la tasa real)
    if(fromCurrency == "EUR") return 0.85;
    
    // Para otras monedas, devolver 1.0 como default
    return 1.0;
}

//+------------------------------------------------------------------+
//| Calcular P&L exacto considerando spread para cada posici√≥n       |
//+------------------------------------------------------------------+
double CalcularPLConSpread(double precioApertura, double precioTP, 
                          int tipoPosicion, double lotes, double spread)
{
    double valorPip = 10.0; // EUR/USD: 1 pip = 10 EUR por lote
    double pl = 0;
    
    if(tipoPosicion == POSITION_TYPE_BUY)
    {
        // BUY se cierra al BID (precio TP)
        pl = (precioTP - precioApertura) / _Point * lotes * valorPip / 10;
    }
    else // SELL
    {
        // SELL se cierra al ASK (precio TP + spread actual)
        double precioCloseSell = precioTP + spread;
        pl = (precioApertura - precioCloseSell) / _Point * lotes * valorPip / 10;
    }
    
    return pl;
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 4: ReubicarTPsParaGarantiaMinimaG() - SIN CAMBIOS       |
//| Mantener como estaba en la versi√≥n anterior                     |
//+------------------------------------------------------------------+
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia)
{
    // Verificar que la secuencia est√© activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
    
    // Obtener el n√∫mero de entrada para activar reubicaci√≥n desde la interfaz
    string textoNumReubicar = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
    
    // Si el campo est√° vac√≠o o es "0", no hacer nada
    if(textoNumReubicar == "" || textoNumReubicar == "0")
        return;
    
    int entradaReubicar = (int)StringToInteger(textoNumReubicar);
    int entradasActuales = ContarEntradasActivas(indiceSecuencia);
    
    // Solo proceder si tenemos el n√∫mero m√≠nimo de entradas
    if(entradasActuales < entradaReubicar)
        return;
    
    // Detectar si necesita rec√°lculo
    bool necesitaRecalculo = false;
    
    if(!secuencias[indiceSecuencia].tpReubicado)
    {
        // Primera activaci√≥n del cierre virtual
        Print("\nüéØ ACTIVANDO SISTEMA DE CIERRE VIRTUAL");
        Print("üìç Secuencia #", secuencias[indiceSecuencia].id);
        Print("üìç Entradas activas: ", entradasActuales);
        Print("üìç Activado en entrada #", entradaReubicar);
        necesitaRecalculo = true;
        secuencias[indiceSecuencia].tpReubicado = true;
        secuencias[indiceSecuencia].ultimaVerificacionTP = TimeCurrent(); // Marcar tiempo de activaci√≥n
    }
    else if(entradasActuales > secuencias[indiceSecuencia].ultimasPosicionesConsideradas)
    {
        // Nueva entrada detectada, recalcular
        Print("\nüîÑ RECALCULANDO PRECIO VIRTUAL - Nueva entrada detectada");
        Print("üìç Secuencia #", secuencias[indiceSecuencia].id);
        Print("üìç Entradas anteriores: ", secuencias[indiceSecuencia].ultimasPosicionesConsideradas);
        Print("üìç Entradas actuales: ", entradasActuales);
        necesitaRecalculo = true;
    }
    
    // Solo recalcular si es necesario
    if(necesitaRecalculo)
    {
        double precioVirtual = CalcularPrecioCierreVirtualMejorado(indiceSecuencia);
        
        if(precioVirtual > 0)
        {
            // Actualizar contador
            secuencias[indiceSecuencia].ultimasPosicionesConsideradas = entradasActuales;
            
            // Dibujar/actualizar l√≠nea amarilla
            string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
            
            // Eliminar l√≠nea anterior si existe
            ObjectDelete(0, nombreLinea);
            ObjectDelete(0, nombreLinea + "_Label");
            
            // Crear nueva l√≠nea
            DibujarLineaVirtual(precioVirtual, nombreLinea);
            
            double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
            
            Print("‚úÖ Precio virtual: ", DoubleToString(precioVirtual, _Digits));
            Print("üí∞ Objetivo: ‚Ç¨", DoubleToString(gananciaObjetivo, 2));
            Print("üìå La secuencia contin√∫a activa hasta tocar el precio virtual");
            
            // Guardar estado
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n para actualizar todos los TPs al precio virtual         |
//+------------------------------------------------------------------+
void ActualizarTakeProfit(int indiceSecuencia, double precioVirtual)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesModificadas = 0;
    
    // Actualizar TPs de todas las posiciones activas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double sl = PositionGetDouble(POSITION_SL);
            
            // Modificar posici√≥n con nuevo TP
            if(trade.PositionModify(ticket, sl, precioVirtual))
            {
                posicionesModificadas++;
            }
            else
            {
                Print("? Error al modificar TP de posici√≥n #", ticket, ": ", GetLastError());
            }
        }
    }
    
    if(posicionesModificadas > 0)
    {
        Print("? Actualizados ", posicionesModificadas, " TPs al precio virtual: ", 
              DoubleToString(precioVirtual, _Digits));
        
        // Marcar que se reubicaron los TPs
        secuencias[indiceSecuencia].tpReubicado = true;
        secuencias[indiceSecuencia].ultimasPosicionesConsideradas = posicionesModificadas;
    }
}

//+------------------------------------------------------------------+
//| FUNCI√ìN AUXILIAR: DibujarLineaVirtual (si no existe)            |
//+------------------------------------------------------------------+
void DibujarLineaVirtual(double precio, string nombre)
{
    // Crear l√≠nea horizontal amarilla
    if(ObjectCreate(0, nombre, OBJ_HLINE, 0, 0, precio))
    {
        ObjectSetInteger(0, nombre, OBJPROP_COLOR, clrYellow);
        ObjectSetInteger(0, nombre, OBJPROP_WIDTH, 2);
        ObjectSetInteger(0, nombre, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, nombre, OBJPROP_RAY, true);
        ObjectSetInteger(0, nombre, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, nombre, OBJPROP_HIDDEN, false);
    }
    else
    {
        // Si ya existe, solo actualizar el precio
        ObjectSetDouble(0, nombre, OBJPROP_PRICE, 0, precio);
    }
    
    // Crear etiqueta
    string etiqueta = nombre + "_Label";
    if(ObjectCreate(0, etiqueta, OBJ_TEXT, 0, TimeCurrent(), precio))
    {
        double gananciaMinima = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
        ObjectSetString(0, etiqueta, OBJPROP_TEXT, 
                      "Virtual: " + DoubleToString(precio, _Digits) + 
                      " | Target: ‚Ç¨" + DoubleToString(gananciaMinima, 2));
        ObjectSetString(0, etiqueta, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, etiqueta, OBJPROP_FONTSIZE, 9);
        ObjectSetInteger(0, etiqueta, OBJPROP_COLOR, clrYellow);
    }
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| FUNCI√ìN AUXILIAR: ContarEntradasActivas (si no existe)          |
//+------------------------------------------------------------------+
int ContarEntradasActivas(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int contador = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            contador++;
        }
    }
    
    return contador;
}

//+------------------------------------------------------------------+
//| Identificar tipo de √∫ltima entrada activa                       |
//+------------------------------------------------------------------+
ENUM_POSITION_TYPE IdentificarTipoUltimaEntrada(int indiceSecuencia)
{
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int numeroEntradaMayor = 0;
    ENUM_POSITION_TYPE tipoUltimaEntrada = POSITION_TYPE_BUY;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            int posENT = StringFind(comentario, "_ENT");
            if(posENT >= 0)
            {
                string numeroStr = StringSubstr(comentario, posENT + 4);
                int numeroEntrada = (int)StringToInteger(numeroStr);
                
                if(numeroEntrada > numeroEntradaMayor)
                {
                    numeroEntradaMayor = numeroEntrada;
                    tipoUltimaEntrada = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                }
            }
        }
    }
    
    return tipoUltimaEntrada;
}

//+------------------------------------------------------------------+
//| NUEVAFunci√≥n de cierre simult√°neo exacto                         |
//+------------------------------------------------------------------+
bool CerrarTodasPosicionesSimultaneo(double precioVirtual) {
    // Estructura para snapshot de posiciones
    struct PosicionSnapshot {
        ulong ticket;
        ENUM_POSITION_TYPE tipo;
        double volumen;
        double precioEntrada;
        double profitVirtual;
    };
    
    PosicionSnapshot snapshots[];
    int totalPosiciones = PositionsTotal();
    ArrayResize(snapshots, totalPosiciones);
    
    // Tomar snapshot en el mismo tick
    MqlTick tickActual;
    if(!SymbolInfoTick(_Symbol, tickActual)) return false;
    
    // Calcular profit virtual para cada posici√≥n
    double profitTotalVirtual = 0.0;
    
    for(int i = 0; i < totalPosiciones; i++) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        snapshots[i].ticket = ticket;
        snapshots[i].tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        snapshots[i].volumen = PositionGetDouble(POSITION_VOLUME);
        snapshots[i].precioEntrada = PositionGetDouble(POSITION_PRICE_OPEN);
        
        // **CLAVE**: Usar precio apropiado seg√∫n tipo
        double precioCierre = (snapshots[i].tipo == POSITION_TYPE_BUY) ? 
                             tickActual.bid : tickActual.ask;
        
        // Calcular profit usando OrderCalcProfit para m√°xima precisi√≥n
        double profit = 0.0;
        ENUM_ORDER_TYPE orderType = (snapshots[i].tipo == POSITION_TYPE_BUY) ? 
                                   ORDER_TYPE_SELL : ORDER_TYPE_BUY;
        
        if(OrderCalcProfit(orderType, _Symbol, snapshots[i].volumen, 
                          snapshots[i].precioEntrada, precioCierre, profit)) {
            snapshots[i].profitVirtual = profit;
            profitTotalVirtual += profit;
        }
    }
    
    // Agregar comisiones y swaps al profit virtual
    for(int i = 0; i < totalPosiciones; i++) {
        if(PositionSelectByTicket(snapshots[i].ticket)) {
            profitTotalVirtual += PositionGetDouble(POSITION_COMMISSION);
            profitTotalVirtual += PositionGetDouble(POSITION_SWAP);
        }
    }
    
    // Log del cierre virtual
    Print("=== CIERRE VIRTUAL EJECUTADO ===");
    Print("Precio Virtual Calculado: ", precioVirtual);
    Print("BID/ASK Actuales: ", tickActual.bid, "/", tickActual.ask);
    Print("Total Posiciones: ", totalPosiciones);
    Print("Profit Virtual Total: ", profitTotalVirtual);
    
    // Ejecutar cierre real si el profit virtual cumple objetivo
    return EjecutarCierreReal();
}

bool EjecutarCierreReal() {
    CTrade trade;
    trade.SetAsyncMode(true); // Modo as√≠ncrono para velocidad
    
    bool todoExitoso = true;
    
    // Cerrar todas las posiciones en orden inverso
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0) {
            if(!trade.PositionClose(ticket)) {
                Print("Error cerrando posici√≥n: ", ticket, " Error: ", GetLastError());
                todoExitoso = false;
            }
        }
    }
    
    return todoExitoso;
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 1: CalcularPrecioCierreVirtualMejorado() - CORREGIDA    |
//| Corrige el c√°lculo del precio para que sea coherente            |
//+------------------------------------------------------------------+
double CalcularPrecioCierreVirtualMejorado(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    // Estructuras para almacenar datos
    struct DatosPosicion {
        double volumen;
        double precioApertura;
        ENUM_POSITION_TYPE tipo;
        double swap;
    };
    
    DatosPosicion posiciones[];
    int numPosiciones = 0;
    double totalComisiones = 0;
    double totalSwaps = 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n===== C√ÅLCULO DE PRECIO VIRTUAL =====");
    Print("Secuencia #", secuencias[indiceSecuencia].id);
    
    // Contar posiciones activas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            numPosiciones++;
        }
    }
    
    if(numPosiciones == 0) return 0;
    
    ArrayResize(posiciones, numPosiciones);
    int index = 0;
    
    // Capturar datos de cada posici√≥n
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posiciones[index].volumen = PositionGetDouble(POSITION_VOLUME);
            posiciones[index].precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            posiciones[index].tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            posiciones[index].swap = PositionGetDouble(POSITION_SWAP);
            
            totalSwaps += posiciones[index].swap;
            
            // Calcular comisiones (apertura + cierre estimado)
            double comisionPorOperacion = CalcularComisionPepperstone(posiciones[index].volumen);
            totalComisiones += comisionPorOperacion * 2; // Ida y vuelta
            
            string tipoStr = (posiciones[index].tipo == POSITION_TYPE_BUY) ? "BUY" : "SELL";
            Print("  ", tipoStr, " ", DoubleToString(posiciones[index].volumen, 2), 
                  " @ ", DoubleToString(posiciones[index].precioApertura, _Digits));
            
            index++;
        }
    }
    
    // Obtener datos del mercado
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = ask - bid;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    // Obtener ganancia objetivo
    double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
    
    // Si la ganancia objetivo es muy peque√±a o cero, usar un m√≠nimo
    if(gananciaObjetivo < 0.01) gananciaObjetivo = 0.10;
    
    Print("BID: ", DoubleToString(bid, _Digits), " / ASK: ", DoubleToString(ask, _Digits));
    Print("Spread: ", (int)(spread / point), " puntos");
    Print("Comisiones: ‚Ç¨", DoubleToString(totalComisiones, 2));
    Print("Swaps: ‚Ç¨", DoubleToString(totalSwaps, 2));
    Print("Objetivo: ‚Ç¨", DoubleToString(gananciaObjetivo, 2));
    
    // C√ÅLCULO CORRECTO DEL PRECIO VIRTUAL
    // Para EUR/USD con cuenta EUR: Profit = (PrecioCierre - PrecioApertura) √ó Volumen √ó 100000
    
    double volumenNetoBuy = 0;
    double volumenNetoSell = 0;
    double costoBuy = 0;
    double costoSell = 0;
    
    for(int i = 0; i < numPosiciones; i++)
    {
        if(posiciones[i].tipo == POSITION_TYPE_BUY)
        {
            volumenNetoBuy += posiciones[i].volumen;
            costoBuy += posiciones[i].volumen * posiciones[i].precioApertura;
        }
        else
        {
            volumenNetoSell += posiciones[i].volumen;
            costoSell += posiciones[i].volumen * posiciones[i].precioApertura;
        }
    }
    
    // Determinar la direcci√≥n neta
    double volumenNeto = volumenNetoBuy - volumenNetoSell;
    
    // CORRECCI√ìN CR√çTICA: El c√°lculo debe considerar correctamente el signo
    // Para posici√≥n neta LARGA (m√°s BUY): precio debe SUBIR para ganar
    // Para posici√≥n neta CORTA (m√°s SELL): precio debe BAJAR para ganar
    
    double precioVirtual;
    
    if(MathAbs(volumenNeto) < 0.0001)
    {
        // Vol√∫menes balanceados - usar m√©todo simplificado
        Print("‚ö†Ô∏è Vol√∫menes balanceados");
        double totalVolumen = volumenNetoBuy + volumenNetoSell;
        if(totalVolumen > 0)
        {
            // Para vol√∫menes balanceados, calcular basado en el spread necesario
            double pipsNecesarios = (gananciaObjetivo + totalComisiones - totalSwaps) / (totalVolumen * 10.0);
            precioVirtual = bid + (pipsNecesarios * point);
        }
        else
        {
            return 0;
        }
    }
    else
    {
        // F√≥rmula corregida considerando que:
        // - Las posiciones BUY ganan cuando el precio SUBE (cierre > apertura)
        // - Las posiciones SELL ganan cuando el precio BAJA (apertura > cierre)
        
        // Ganancia Total = Œ£(BUY: (PrecioCierre - PrecioApertura) √ó Volumen) + 
        //                  Œ£(SELL: (PrecioApertura - PrecioCierre) √ó Volumen) √ó 100000
        
        // Reorganizando para PrecioCierre:
        // (Ganancia + Comisiones - Swaps) / 100000 = 
        //     PrecioCierre √ó (VolumenBuy - VolumenSell) - CostoBuy + CostoSell
        
        double gananciaNetaNecesaria = gananciaObjetivo + totalComisiones - totalSwaps;
        
        // Para BUY: necesitamos PrecioCierre = BID objetivo
        // Para SELL: necesitamos PrecioCierre = ASK objetivo
        
        if(volumenNeto > 0) // Posici√≥n neta LARGA (m√°s BUY que SELL)
        {
            // Para ganar, el precio debe SUBIR
            double numerador = (gananciaNetaNecesaria / 100000) + costoBuy - costoSell;
            
            // Considerar que SELL cierra al ASK (BID + spread)
            if(volumenNetoSell > 0)
            {
                numerador += spread * volumenNetoSell;
            }
            
            precioVirtual = numerador / volumenNeto;
            
            // Verificar que el precio calculado sea mayor que el actual para BUY
            if(precioVirtual <= bid)
            {
                // Si el c√°lculo da un precio menor o igual al actual, ajustar
                double pipsMinimos = 5.0; // M√≠nimo 5 pips de ganancia
                precioVirtual = bid + (pipsMinimos * point);
            }
        }
        else // Posici√≥n neta CORTA (m√°s SELL que BUY)
        {
            // Para ganar, el precio debe BAJAR
            volumenNeto = MathAbs(volumenNeto);
            double numerador = costoSell - costoBuy - (gananciaNetaNecesaria / 100000);
            
            // Considerar que BUY cierra al BID
            if(volumenNetoBuy > 0)
            {
                numerador -= spread * volumenNetoBuy;
            }
            
            precioVirtual = numerador / volumenNeto;
            
            // Verificar que el precio calculado sea menor que el actual para SELL
            if(precioVirtual >= ask)
            {
                // Si el c√°lculo da un precio mayor o igual al actual, ajustar
                double pipsMinimos = 5.0; // M√≠nimo 5 pips de ganancia
                precioVirtual = ask - (pipsMinimos * point);
            }
        }
    }
    
    // Normalizar al n√∫mero de decimales del s√≠mbolo
    precioVirtual = NormalizeDouble(precioVirtual, _Digits);
    
    // Verificaci√≥n del c√°lculo
    double verificacion = 0;
    for(int i = 0; i < numPosiciones; i++)
    {
        if(posiciones[i].tipo == POSITION_TYPE_BUY)
        {
            verificacion += (precioVirtual - posiciones[i].precioApertura) * posiciones[i].volumen * 100000;
        }
        else
        {
            verificacion += (posiciones[i].precioApertura - (precioVirtual + spread)) * posiciones[i].volumen * 100000;
        }
    }
    
    double gananciaEsperada = verificacion - totalComisiones + totalSwaps;
    
    Print("PRECIO VIRTUAL CALCULADO: ", DoubleToString(precioVirtual, _Digits));
    Print("Direcci√≥n: ", (volumenNetoBuy > volumenNetoSell) ? "LARGA (precio debe subir)" : "CORTA (precio debe bajar)");
    Print("Ganancia esperada: ‚Ç¨", DoubleToString(gananciaEsperada, 2));
    Print("Diferencia con objetivo: ‚Ç¨", DoubleToString(MathAbs(gananciaEsperada - gananciaObjetivo), 4));
    
    return precioVirtual;
}

//+------------------------------------------------------------------+
//| Funci√≥n auxiliar para verificar el c√°lculo                      |
//+------------------------------------------------------------------+
void VerificarCalculoPrecioVirtual(int indiceSecuencia, double precioVirtual)
{
    double plTotal = 0;
    double totalComisiones = 0;
    double totalSwap = 0;
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n?? VERIFICACI√ìN DEL C√ÅLCULO DE PRECIO VIRTUAL");
    Print("Precio virtual calculado: ", DoubleToString(precioVirtual, _Digits));
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lots = PositionGetDouble(POSITION_VOLUME);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double swap = PositionGetDouble(POSITION_SWAP);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double comision = CalcularComisionPepperstone(lots);
            totalComisiones += comision;
            totalSwap += swap;
            
            double pl = 0;
            if(tipo == POSITION_TYPE_BUY)
            {
                double pips = (precioVirtual - openPrice) / _Point;
                pl = pips * lots * 10.0 / 10.0;
                Print("  BUY ", DoubleToString(lots, 2), " @ ", DoubleToString(openPrice, _Digits), 
                      " ? P/L: ‚Ç¨", DoubleToString(pl, 2));
            }
            else
            {
                double pips = (openPrice - precioVirtual) / _Point;
                pl = pips * lots * 10.0 / 10.0;
                Print("  SELL ", DoubleToString(lots, 2), " @ ", DoubleToString(openPrice, _Digits), 
                      " ? P/L: ‚Ç¨", DoubleToString(pl, 2));
            }
            
            plTotal += pl;
        }
    }
    
    double gananciaNeta = plTotal - totalComisiones + totalSwap;
    double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
    
    Print("P/L Total: ‚Ç¨", DoubleToString(plTotal, 2));
    Print("Comisiones: ‚Ç¨", DoubleToString(totalComisiones, 2));
    Print("Swap: ‚Ç¨", DoubleToString(totalSwap, 2));
    Print("Ganancia Neta Calculada: ‚Ç¨", DoubleToString(gananciaNeta, 2));
    Print("Ganancia Objetivo: ‚Ç¨", DoubleToString(gananciaObjetivo, 2));
    Print("Diferencia: ‚Ç¨", DoubleToString(gananciaNeta - gananciaObjetivo, 2));
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 2: MonitorearCierrePorGananciaObjetivo() - CORREGIDA    |
//| Evita cierre inmediato y stack overflow                         |
//+------------------------------------------------------------------+
void MonitorearCierrePorGananciaObjetivo()
{
    static datetime ultimaVerificacion = 0;
    
    // Evitar verificaci√≥n muy frecuente
    if(TimeCurrent() - ultimaVerificacion < 1) return;
    ultimaVerificacion = TimeCurrent();
    
    // Obtener precios actuales
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    // Verificar cada secuencia activa
    for(int idx = 0; idx < 20; idx++)
    {
        // Solo procesar secuencias con cierre virtual activado y no marcadas para cierre
        if(!secuencias[idx].activa || !secuencias[idx].tpReubicado || secuencias[idx].tpAlcanzado)
            continue;
        
        // Evitar procesar secuencias reci√©n activadas (dar tiempo para que se dibuje la l√≠nea)
        if(TimeCurrent() - secuencias[idx].ultimaVerificacionTP < 3)
            continue;
        
        // Buscar la l√≠nea del precio virtual
        string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[idx].id);
        
        // Verificar si existe la l√≠nea
        if(ObjectFind(0, nombreLinea) < 0)
            continue;
        
        double precioVirtual = ObjectGetDouble(0, nombreLinea, OBJPROP_PRICE, 0);
        
        if(precioVirtual <= 0)
            continue;
        
        // Determinar direcci√≥n neta de la secuencia
        bool posicionNetaLarga = DeterminarPosicionNeta(idx);
        bool deberCerrar = false;
        
        if(posicionNetaLarga)
        {
            // Posici√≥n neta LARGA - el precio debe SUBIR para ganar
            // Cerrar cuando BID >= precio virtual
            if(bid >= precioVirtual)
            {
                deberCerrar = true;
                Print("üí∞ PRECIO VIRTUAL ALCANZADO (Posici√≥n LARGA)");
                Print("   BID actual: ", DoubleToString(bid, _Digits));
                Print("   Precio virtual: ", DoubleToString(precioVirtual, _Digits));
            }
        }
        else
        {
            // Posici√≥n neta CORTA - el precio debe BAJAR para ganar
            // Cerrar cuando ASK <= precio virtual
            if(ask <= precioVirtual)
            {
                deberCerrar = true;
                Print("üí∞ PRECIO VIRTUAL ALCANZADO (Posici√≥n CORTA)");
                Print("   ASK actual: ", DoubleToString(ask, _Digits));
                Print("   Precio virtual: ", DoubleToString(precioVirtual, _Digits));
            }
        }
        
        if(deberCerrar)
        {
            Print("üéØ EJECUTANDO CIERRE VIRTUAL - Secuencia #", secuencias[idx].id);
            
            // IMPORTANTE: Marcar ANTES de cerrar para evitar re-procesamiento
            secuencias[idx].tpAlcanzado = true;
            secuencias[idx].cerradaCompletamente = true;
            
            // Cerrar todas las √≥rdenes de la secuencia
            CerrarTodasLasOrdenesDeSecuencia(idx, true);
            
            // Limpiar l√≠nea del gr√°fico
            ObjectDelete(0, nombreLinea);
            ObjectDelete(0, nombreLinea + "_Label");
            
            // NO llamar a CerrarSecuencia aqu√≠ si ya se llama en CerrarTodasLasOrdenesDeSecuencia
            // Esto evita el stack overflow
            
            Print("‚úÖ Cierre virtual completado - Secuencia #", secuencias[idx].id);
            
            // Guardar estado
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 3: DeterminarPosicionNeta() - NUEVA                     |
//| Determina si la posici√≥n neta es larga o corta                 |
//+------------------------------------------------------------------+
bool DeterminarPosicionNeta(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return true;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double volumenBuy = 0;
    double volumenSell = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double volumen = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            if(tipo == POSITION_TYPE_BUY)
                volumenBuy += volumen;
            else
                volumenSell += volumen;
        }
    }
    
    // Retornar true si es posici√≥n neta larga (m√°s BUY que SELL)
    return (volumenBuy >= volumenSell);
}

//+------------------------------------------------------------------+
//| FUNCI√ìN AUXILIAR: Calcular ganancia actual de la secuencia      |
//+------------------------------------------------------------------+
double CalcularGananciaActualSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double gananciaTotal = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            double swap = PositionGetDouble(POSITION_SWAP);
            double volumen = PositionGetDouble(POSITION_VOLUME);
            
            // Obtener comisi√≥n con m√©todo alternativo si deprecated
            double commission = 0;
            #ifdef POSITION_COMMISSION
                commission = PositionGetDouble(POSITION_COMMISSION);
            #endif
            
            // Estimar comisi√≥n de cierre
            double comisionCierre = CalcularComisionPepperstone(volumen);
            
            // Ganancia neta
            gananciaTotal += profit + swap + commission - comisionCierre;
        }
    }
    
    return gananciaTotal;
}

//+------------------------------------------------------------------+
//| FUNCI√ìN AUXILIAR: Determinar direcci√≥n predominante             |
//+------------------------------------------------------------------+
bool DeterminarDireccionPredominante(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return true;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double volumenBuy = 0;
    double volumenSell = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double volumen = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            if(tipo == POSITION_TYPE_BUY)
                volumenBuy += volumen;
            else
                volumenSell += volumen;
        }
    }
    
    return (volumenBuy >= volumenSell);
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 3: CerrarTodasPosicionesSecuenciaVirtual() - NUEVA V3   |
//| Cierra sin bloquear los botones                                 |
//+------------------------------------------------------------------+
void CerrarTodasPosicionesSecuenciaVirtual(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int totalCerradas = 0;
    int totalErrores = 0;
    
    // Usar la variable global 'trade' existente
    trade.SetDeviationInPoints(10);
    trade.SetTypeFilling(ORDER_FILLING_FOK);
    
    // Primero, cancelar √≥rdenes pendientes de esta secuencia
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            if(trade.OrderDelete(ticket))
            {
                Print("‚úÖ Orden pendiente ", ticket, " eliminada");
            }
        }
    }
    
    // Cerrar posiciones abiertas
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            if(trade.PositionClose(ticket))
            {
                totalCerradas++;
                Print("‚úÖ Posici√≥n ", ticket, " cerrada por cierre virtual");
            }
            else
            {
                totalErrores++;
                Print("‚ùå Error cerrando posici√≥n ", ticket, ": ", GetLastError());
                
                // Reintento con peque√±a pausa
                Sleep(50);
                if(trade.PositionClose(ticket))
                {
                    totalCerradas++;
                    totalErrores--;
                    Print("‚úÖ Posici√≥n ", ticket, " cerrada en segundo intento");
                }
            }
        }
    }
    
    if(totalCerradas > 0)
    {
        Print("üìä RESUMEN CIERRE VIRTUAL:");
        Print("   Posiciones cerradas: ", totalCerradas);
        Print("   Errores: ", totalErrores);
        
        // Limpiar l√≠nea virtual del gr√°fico
        string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
        ObjectDelete(0, nombreLinea);
        ObjectDelete(0, nombreLinea + "_Label");
        
        // IMPORTANTE: Resetear la secuencia sin afectar la interfaz
        ResetearSecuencia(indiceSecuencia);
        
        // Decrementar contador de secuencias activas
        if(totalSecuencias > 0) totalSecuencias--;
        
        // Guardar estado
        GuardarEstadoSecuencias();
        
        // Actualizar informaci√≥n visual
        ActualizarInformacionSecuencias();
        
        // Forzar redibujado del gr√°fico
        ChartRedraw();
        
        Print("‚úÖ Secuencia #", secuencias[indiceSecuencia].id, " cerrada completamente");
        Print("üîÑ Botones listos para nueva operaci√≥n");
    }
}

//+------------------------------------------------------------------+
//| FUNCI√ìN 4: CerrarTodasPosicionesSecuencia() - CORREGIDA V2      |
//| NO REDECLARA trade - Agregar esta funci√≥n auxiliar              |
//+------------------------------------------------------------------+
void CerrarTodasPosicionesSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int totalCerradas = 0;
    int totalErrores = 0;
    
    // Usar la variable global 'trade' que ya existe, NO redeclarar
    // trade ya est√° definida globalmente como CTrade trade;
    trade.SetDeviationInPoints(10);
    trade.SetTypeFilling(ORDER_FILLING_FOK);
    
    // Cerrar posiciones en orden inverso
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            if(trade.PositionClose(ticket))
            {
                totalCerradas++;
                Print("‚úÖ Posici√≥n ", ticket, " cerrada");
            }
            else
            {
                totalErrores++;
                Print("‚ùå Error cerrando posici√≥n ", ticket, ": ", GetLastError());
                
                // Reintento
                Sleep(100);
                if(trade.PositionClose(ticket))
                {
                    totalCerradas++;
                    totalErrores--;
                    Print("‚úÖ Posici√≥n ", ticket, " cerrada en segundo intento");
                }
            }
        }
    }
    
    if(totalCerradas > 0)
    {
        Print("RESUMEN: ", totalCerradas, " posiciones cerradas, ", totalErrores, " errores");
        
        // Marcar secuencia como cerrada
        secuencias[indiceSecuencia].tpAlcanzado = true;
        secuencias[indiceSecuencia].cerradaCompletamente = true;
        
        // Limpiar l√≠nea virtual del gr√°fico
        string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
        ObjectDelete(0, nombreLinea);
        ObjectDelete(0, nombreLinea + "_Label");
        
        // Cerrar la secuencia
        CerrarSecuencia(indiceSecuencia);
    }
}

//+------------------------------------------------------------------+
//| NUEVA FUNCI√ìN: Cierre con m√°xima prioridad                      |
//| AGREGAR despu√©s de las otras funciones                          |
//+------------------------------------------------------------------+
void CerrarTodasConPrioridad(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // M√ÅXIMA TOLERANCIA para garantizar cierre
    trade.SetDeviationInPoints(100);
    
    // 1. Eliminar TODAS las √≥rdenes pendientes INMEDIATAMENTE
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.OrderDelete(ticket);
            }
        }
    }
    
    // 2. Cerrar TODAS las posiciones SIMULT√ÅNEAMENTE
    int posicionesCerradas = 0;
    
    for(int intento = 0; intento < 3; intento++)
    {
        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    if(trade.PositionClose(ticket))
                    {
                        posicionesCerradas++;
                        Print("? Posici√≥n ", ticket, " cerrada");
                    }
                    else
                    {
                        Print("? Error cerrando ", ticket, ": ", GetLastError());
                    }
                }
            }
        }
        
        // Si todas se cerraron, salir
        if(posicionesCerradas > 0) break;
        
        Sleep(50); // Peque√±a pausa entre intentos
    }
    
    // Marcar secuencia como inactiva
    secuencias[indiceSecuencia].activa = false;
    secuencias[indiceSecuencia].tpReubicado = false;
    totalSecuencias--;
    
    // Restaurar tolerancia normal
    trade.SetDeviationInPoints(10);
    
    Print("? Secuencia #", secuencias[indiceSecuencia].id, " cerrada - Total posiciones cerradas: ", posicionesCerradas);
}



//+------------------------------------------------------------------+
//| Funci√≥n adicional para limpiar l√≠neas al cerrar secuencia       |
//+------------------------------------------------------------------+
void LimpiarLineaCierreVirtual(int indiceSecuencia)
{
    string lineaId = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
    ObjectDelete(0, lineaId);
    ObjectDelete(0, lineaId + "_Label");
    ChartRedraw();
    LimpiarLineaCierreVirtual(indiceSecuencia);
}

//+------------------------------------------------------------------+
//| Funci√≥n EXACTA para calcular comisi√≥n Pepperstone en EUR        |
//| Basada en tabla Excel verificada - 100% precisa                 |
//+------------------------------------------------------------------+
double CalcularComisionPepperstone(double lots)
{
    // Tabla verificada hasta 0.30 lotes (de tu Excel)
    // Los valores son EXACTOS seg√∫n Pepperstone
    if(lots <= 0.01) return 0.06;
    else if(lots <= 0.02) return 0.10;
    else if(lots <= 0.03) return 0.16;
    else if(lots <= 0.04) return 0.20;
    else if(lots <= 0.05) return 0.26;
    else if(lots <= 0.06) return 0.32;
    else if(lots <= 0.07) return 0.36;
    else if(lots <= 0.08) return 0.42;
    else if(lots <= 0.09) return 0.46;
    else if(lots <= 0.10) return 0.52;
    else if(lots <= 0.11) return 0.58;
    else if(lots <= 0.12) return 0.62;
    else if(lots <= 0.13) return 0.68;
    else if(lots <= 0.14) return 0.72;
    else if(lots <= 0.15) return 0.78;
    else if(lots <= 0.16) return 0.84;
    else if(lots <= 0.17) return 0.88;
    else if(lots <= 0.18) return 0.94;
    else if(lots <= 0.19) return 0.98;
    else if(lots <= 0.20) return 1.04;
    else if(lots <= 0.21) return 1.10;
    else if(lots <= 0.22) return 1.14;
    else if(lots <= 0.23) return 1.20;
    else if(lots <= 0.24) return 1.24;
    else if(lots <= 0.25) return 1.30;
    else if(lots <= 0.26) return 1.36;
    else if(lots <= 0.27) return 1.40;
    else if(lots <= 0.28) return 1.46;
    else if(lots <= 0.29) return 1.50;
    else if(lots <= 0.30) return 1.56;
    
    // Para lotes > 0.30, aplicar el patr√≥n observado en la tabla
    // La base es 5.20 EUR por lote, pero con redondeo especial
    
    // Valores espec√≠ficos de la tabla para referencia
    else if(lots <= 0.31) return 1.62;
    else if(lots <= 0.32) return 1.66;  // Mismo que 0.31
    else if(lots <= 0.33) return 1.72;
    else if(lots <= 0.34) return 1.76;
    else if(lots <= 0.35) return 1.82;
    else if(lots <= 0.36) return 1.88;
    else if(lots <= 0.37) return 1.92;
    else if(lots <= 0.38) return 1.98;
    else if(lots <= 0.39) return 2.02;
    else if(lots <= 0.40) return 2.08;
    
    // Para lotes de 0.41 a 1.00, usar los valores de la tabla
    else if(lots <= 0.50) return 2.60;
    else if(lots <= 0.60) return 3.12;
    else if(lots <= 0.61) return 3.18;
    else if(lots <= 0.62) return 3.22;  // Seg√∫n tabla
    else if(lots <= 0.63) return 3.28;
    else if(lots <= 0.64) return 3.32;
    else if(lots <= 0.65) return 3.38;
    else if(lots <= 0.70) return 3.64;
    else if(lots <= 0.80) return 4.16;
    else if(lots <= 0.90) return 4.68;
    else if(lots <= 1.00) return 5.20;
    else if(lots <= 1.01) return 5.26;  // Mismo que 1.00 seg√∫n tabla
    
    // Para lotes mayores, aplicar f√≥rmula con redondeo especial
    else
    {
        double comisionBase = lots * 5.20;
        
        // Pepperstone parece redondear a m√∫ltiplos de 0.02 EUR para comisiones grandes
        // Primero redondear a 2 decimales
        double comisionRedondeada = MathRound(comisionBase * 100) / 100;
        
        // Si el segundo decimal es impar, redondear al par superior
        int centavos = (int)(comisionRedondeada * 100);
        if(centavos % 2 == 1)
        {
            centavos++;
            comisionRedondeada = centavos / 100.0;
        }
        
        return comisionRedondeada;
    }
}


//+------------------------------------------------------------------+
//| Calcular P&L exacto para una posici√≥n                           |
//+------------------------------------------------------------------+
double CalcularPLExacto(double precioApertura, double precioCierre, 
                       ENUM_POSITION_TYPE tipo, double lotes)
{
    double pl = 0;
    
    // Para EUR/USD en cuenta EUR
    double valorPip = 10.0; // 10 EUR por pip por lote est√°ndar
    
    if(tipo == POSITION_TYPE_BUY)
    {
        double pips = (precioCierre - precioApertura) / _Point / 10.0;
        pl = pips * lotes * valorPip;
    }
    else // SELL
    {
        double pips = (precioApertura - precioCierre) / _Point / 10.0;
        pl = pips * lotes * valorPip;
    }
    
    return NormalizeDouble(pl, 2);
}

//+------------------------------------------------------------------+
//| Funci√≥n de diagn√≥stico para verificar c√°lculos                   |
//+------------------------------------------------------------------+
void DiagnosticarSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n========== DIAGN√ìSTICO SECUENCIA #", secuencias[indiceSecuencia].id, " ==========");
    
    // Obtener spread actual
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = ask - bid;
    
    // Recolectar todas las posiciones
    double totalComisiones = 0;
    double totalPL = 0;
    double totalPLConSpread = 0;
    int numPosiciones = 0;
    
    Print("POSICIONES ABIERTAS:");
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lotes = PositionGetDouble(POSITION_VOLUME);
            double precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            double pl = PositionGetDouble(POSITION_PROFIT);
            int tipo = (int)PositionGetInteger(POSITION_TYPE);
            string tipoStr = (tipo == POSITION_TYPE_BUY) ? "BUY" : "SELL";
            
            double comision = CalcularComisionPepperstone(lotes);
            totalComisiones += comision;
            totalPL += pl;
            
            // Calcular P&L proyectado al TP considerando spread
            double plProyectado = CalcularPLConSpread(precioApertura, tp, tipo, lotes, spread);
            totalPLConSpread += plProyectado;
            
            Print("  #", ticket, " ", tipoStr, " ", DoubleToString(lotes, 2), 
                  " @ ", DoubleToString(precioApertura, _Digits),
                  " TP=", DoubleToString(tp, _Digits),
                  " P/L actual=", DoubleToString(pl, 2),
                  " P/L al TP=", DoubleToString(plProyectado, 2),
                  " Comisi√≥n=", DoubleToString(comision, 2));
            
            numPosiciones++;
        }
    }
    
    double gananciaActualNeta = totalPL - totalComisiones;
    double gananciaProyectadaNeta = totalPLConSpread - totalComisiones;
    
    Print("\nRESUMEN:");
    Print("  Posiciones: ", numPosiciones);
    Print("  Spread actual: ", (int)(spread/_Point), " puntos");
    Print("  P/L Bruto actual: ", DoubleToString(totalPL, 2), " EUR");
    Print("  P/L Proyectado al TP: ", DoubleToString(totalPLConSpread, 2), " EUR");
    Print("  Comisiones totales: ", DoubleToString(totalComisiones, 2), " EUR");
    Print("  P/L Neto actual: ", DoubleToString(gananciaActualNeta, 2), " EUR");
    Print("  P/L Neto proyectado: ", DoubleToString(gananciaProyectadaNeta, 2), " EUR");
    Print("  Ganancia objetivo: ", DoubleToString(StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)), 2), " EUR");
    
    // Advertencias
    if(gananciaProyectadaNeta < StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)))
    {
        Print("\n?? ADVERTENCIA: La ganancia proyectada es menor que el objetivo!");
        Print("   Diferencia: ", DoubleToString(gananciaProyectadaNeta - StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)), 2), " EUR");
    }
    
    Print("=====================================\n");
}

//+------------------------------------------------------------------+
//| Funci√≥n para limpiar secuencias fantasma silenciosamente         |
//+------------------------------------------------------------------+
void LimpiarSecuenciasFantasma()
{
    int contadorLimpiadas = 0;
    
    // Primero, recalcular el total para asegurar que es correcto
    RecalcularTotalSecuencias();
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (√≥rdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar √≥rdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos √≥rdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // √öltimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("?? Limpieza autom√°tica: Secuencia #", secuencias[i].id, " sin actividad detectada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                    contadorLimpiadas++;
                }
            }
        }
    }
    
    if(contadorLimpiadas > 0)
    {
        Print("?? Limpiadas ", contadorLimpiadas, " secuencias fantasma. Total activas ahora: ", totalSecuencias);
        GuardarEstadoSecuencias();
    }
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Inicializar con ID 1, pero luego comprobar si hay que restaurar el contador
    proximoIDSecuencia = 1;
    
    // Verificar si el trading est√° permitido
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
    {
        Alert("El trading autom√°tico no est√° permitido en el terminal");
        return INIT_FAILED;
    }
    
    if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT))
    {
        Alert("El trading con EAs no est√° permitido en esta cuenta");
        return INIT_FAILED;
    }
    
    trade.SetDeviationInPoints(10);
    
    // Inicializar la interfaz
    CrearInterfaz();
    
    // Inicializar array de secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        ResetearSecuencia(i);
    }
    
    // Nueva funci√≥n: Restaurar las √≥rdenes pendientes perdidas en cambios de timeframe
    RecuperarOrdenesPendientes();
    
    // Habilitar eventos de gr√°fico para botones (ya est√°n habilitados por defecto)
    ChartRedraw(); // Aseguramos que el gr√°fico se redibuja para mostrar la interfaz
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Guardar valores de los controles antes de destruirlos
    GuardarValores();
    
    // Si la raz√≥n de deinicializaci√≥n es cambio de temporalidad o cierre del gr√°fico,
    // guardar el estado y el contador de secuencias
    if(reason == REASON_CHARTCHANGE || reason == REASON_CHARTCLOSE)
    {
        // No eliminar los objetos, solo guardar el estado
        Print("Cambio de temporalidad detectado - Preservando objetos y contador de secuencias");
        
        // Guardar estado e ID de pr√≥xima secuencia para mantener numeraci√≥n
        GuardarEstadoSecuenciasConID();
        return;
    }
    
    // Si se trata de eliminaci√≥n del EA, limpiar todas las secuencias activas
    // Y no preservar el contador (para que se reinicie la pr√≥xima vez)
    if(reason == REASON_REMOVE)
    {
        Print("Eliminando EA - Cerrando todas las secuencias activas");
        CerrarTodasLasSecuencias();
        
        // Borrar la variable global que guarda el pr√≥ximo ID para forzar reinicio
        GlobalVariableDel("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
    }
    
    // Para otras razones, eliminar solo los objetos del EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    Print("EA deinicializado - Objetos del EA eliminados");
}

//+------------------------------------------------------------------+
//| Guardar estado de secuencias incluyendo el pr√≥ximo ID            |
//+------------------------------------------------------------------+
void GuardarEstadoSecuenciasConID()
{
    // Guardar el n√∫mero total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar el pr√≥ximo ID de secuencia para mantener la numeraci√≥n entre cambios de timeframe
    GlobalVariableSet("EA_PROXIMO_ID_SECUENCIA_" + Symbol(), proximoIDSecuencia);
    
    // Guardar informaci√≥n detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0);
            GlobalVariableSet(baseKey + "ULTIMAS_POS", secuencias[i].ultimasPosicionesConsideradas);
            
            Print("Guardado estado de secuencia #", secuencias[i].id, " para persistencia entre timeframes");
        }
    }
}

//+------------------------------------------------------------------+
//| Guardar estado b√°sico de secuencias sin ID                       |
//+------------------------------------------------------------------+
void GuardarEstadoSecuencias()
{
    // Guardar el n√∫mero total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar informaci√≥n detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0); // A√ëADIR ESTA L√çNEA
            GlobalVariableSet(baseKey + "ULTIMAS_POS", secuencias[i].ultimasPosicionesConsideradas);
        }
    }
}

//+------------------------------------------------------------------+
//| Restaurar estado de las secuencias                               |
//+------------------------------------------------------------------+
void RestaurarEstadoSecuencias()
{
    // Verificar si hay secuencias guardadas
    if(!GlobalVariableCheck("EA_TOTAL_SECUENCIAS_" + Symbol()))
        return;
        
    int totalSecuenciasGuardadas = (int)GlobalVariableGet("EA_TOTAL_SECUENCIAS_" + Symbol());
    
    // Restaurar el pr√≥ximo ID de secuencia solo si fue un cambio de temporalidad
    // (Comprobamos si la variable existe y si hay secuencias que restaurar)
    if(GlobalVariableCheck("EA_PROXIMO_ID_SECUENCIA_" + Symbol()) && totalSecuenciasGuardadas > 0)
    {
        proximoIDSecuencia = (int)GlobalVariableGet("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
        Print("Restaurado contador de IDs de secuencia desde cambio de temporalidad: ", proximoIDSecuencia);
    }
    
    if(totalSecuenciasGuardadas <= 0)
        return;
        
    Print("Restaurando ", totalSecuenciasGuardadas, " secuencias guardadas");
    
    // Restaurar informaci√≥n de cada secuencia guardada
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        // Verificar si esta secuencia estaba activa
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            secuencias[i].id = (int)GlobalVariableGet(baseKey + "ID");
            secuencias[i].activa = true;
            secuencias[i].precioEntrada1 = GlobalVariableGet(baseKey + "PRECIO_E1");
            secuencias[i].precioEntrada2 = GlobalVariableGet(baseKey + "PRECIO_E2");
            secuencias[i].tp1Precio = GlobalVariableGet(baseKey + "TP1");
            secuencias[i].tp2Precio = GlobalVariableGet(baseKey + "TP2");
            secuencias[i].secuenciaActual = (int)GlobalVariableGet(baseKey + "SEQ_ACTUAL");
            secuencias[i].esModoCompra = (GlobalVariableGet(baseKey + "ES_COMPRA") == 1);
            secuencias[i].ticketEntrada1 = (ulong)GlobalVariableGet(baseKey + "TICKET_E1");
            secuencias[i].ticketEntrada2 = (ulong)GlobalVariableGet(baseKey + "TICKET_E2");
            secuencias[i].entradaPendienteActiva = (GlobalVariableGet(baseKey + "PENDIENTE_ACTIVA") == 1);
            secuencias[i].cerradaManualmente = GlobalVariableCheck(baseKey + "CERRADA_MANUAL") ? 
                                              (GlobalVariableGet(baseKey + "CERRADA_MANUAL") == 1) : false;
            secuencias[i].tiempoInicio = TimeCurrent();
            secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificaci√≥n inmediata
            secuencias[i].ultimaVerificacionPendientes = 0; // Inicializar nueva variable
            secuencias[i].sinOrdenesPendientesDetectado = false; // Inicializar nueva variable
            secuencias[i].tpReubicado = GlobalVariableCheck(baseKey + "TP_REUBICADO") ? 
                           (GlobalVariableGet(baseKey + "TP_REUBICADO") == 1) : false;
            secuencias[i].ultimasPosicionesConsideradas = GlobalVariableCheck(baseKey + "ULTIMAS_POS") ? 
                                               (int)GlobalVariableGet(baseKey + "ULTIMAS_POS") : 0;
            // Actualizar proximoIDSecuencia para asegurar que nuevas secuencias tengan IDs √∫nicos
            if(secuencias[i].id >= proximoIDSecuencia)
            {
                proximoIDSecuencia = secuencias[i].id + 1;
                Print("Ajustando ID de pr√≥xima secuencia a: ", proximoIDSecuencia);
            }
            
            totalSecuencias++;
            
            Print("Restaurada secuencia #", secuencias[i].id, " - Modo: ", 
                  secuencias[i].esModoCompra ? "COMPRA" : "VENTA", 
                  ", Entrada2 pendiente: ", secuencias[i].entradaPendienteActiva ? "S√≠" : "No",
                  ", Cerrada manualmente: ", secuencias[i].cerradaManualmente ? "S√≠" : "No");
        }
    }
    
    for(int i = 0; i < 20; i++)
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            // Restauraci√≥n existente...
            secuencias[i].tpReubicado = GlobalVariableCheck(baseKey + "TP_REUBICADO") ? 
                                       (GlobalVariableGet(baseKey + "TP_REUBICADO") == 1) : false;
        }
    }
    
}

//+------------------------------------------------------------------+
//| Guardar valores de los controles                                 |
//+------------------------------------------------------------------+
void GuardarValores()
{
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
        LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
        TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
        PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
        TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumEntrada = 0;
        else
            NumEntrada = (int)StringToInteger(texto);
    }
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
        MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumCerrar = 0;
        else
            NumCerrar = (int)StringToInteger(texto);
    }
        
    // Guardar estos valores en variables globales para persistencia entre timeframes
    GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
    GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
    GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
    GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
    GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
    GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
    GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
}

//+------------------------------------------------------------------+
//| Restaurar valores guardados                                      |
//+------------------------------------------------------------------+
void RestaurarValores()
{
    // Solo restaurar valores si los controles no tienen valores ya
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            // Intentar recuperar desde variables globales solo si el campo est√° vac√≠o
            if(GlobalVariableCheck("EA_LOTAJE_" + Symbol()))
                LotajeInicial = GlobalVariableGet("EA_LOTAJE_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT, DoubleToString(LotajeInicial, 2));
        }
        else
        {
            // Si hay texto ya en el campo, usarlo para actualizar la variable
            LotajeInicial = StringToDouble(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP1_" + Symbol()))
                TP1Puntos = (int)GlobalVariableGet("EA_TP1_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT, IntegerToString(TP1Puntos));
        }
        else
        {
            TP1Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_PIPS_E2_" + Symbol()))
                PipsEntrada2 = (int)GlobalVariableGet("EA_PIPS_E2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT, IntegerToString(PipsEntrada2));
        }
        else
        {
            PipsEntrada2 = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP2_" + Symbol()))
                TP2Puntos = (int)GlobalVariableGet("EA_TP2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT, IntegerToString(TP2Puntos));
        }
        else
        {
            TP2Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_ENTRADA_" + Symbol()))
            {
                NumEntrada = (int)GlobalVariableGet("EA_NUM_ENTRADA_" + Symbol());
                // Si es 0, mostrar campo vac√≠o
                if(NumEntrada == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, IntegerToString(NumEntrada));
            }
            else
            {
                // Si no hay valor guardado, dejar vac√≠o
                ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumEntrada = (int)StringToInteger(textoActual);
        }
    }
    
    // Restaurar valor para Minima G.
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            if(GlobalVariableCheck("EA_MINIMA_G_" + Symbol()))
                MinimaG = GlobalVariableGet("EA_MINIMA_G_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT, DoubleToString(MinimaG, 2));
        }
        else
        {
            MinimaG = StringToDouble(textoActual);
        }
    }
    
    // Restaurar valor para # Cerrar (NUEVO)
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_CERRAR_" + Symbol()))
            {
                NumCerrar = (int)GlobalVariableGet("EA_NUM_CERRAR_" + Symbol());
                // Si es 0, mostrar campo vac√≠o
                if(NumCerrar == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, IntegerToString(NumCerrar));
            }
            else
            {
                // Si no hay valor guardado, dejar vac√≠o
                ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumCerrar = (int)StringToInteger(textoActual);
        }
    }
}

//+------------------------------------------------------------------+
//| Resetear una secuencia                                           |
//+------------------------------------------------------------------+
void ResetearSecuencia(int indice)
{
    secuencias[indice].activa = false;
    secuencias[indice].numOrdenes = 0;
    secuencias[indice].tpAlcanzado = false;
    secuencias[indice].ultimaVerificacionTP = 0;
    secuencias[indice].cerradaCompletamente = false;
    secuencias[indice].intentosCierre = 0;
    secuencias[indice].ultimoCierreIntentado = 0;
    secuencias[indice].esModoCompra = true;
    secuencias[indice].ticketEntrada1 = 0;
    secuencias[indice].ticketEntrada2 = 0;
    secuencias[indice].entradaPendienteActiva = false;
    secuencias[indice].ultimaRecreacionPendiente = 0;
    secuencias[indice].cerradaManualmente = false;
    secuencias[indice].ultimaVerificacionPendientes = 0; // Nueva variable
    secuencias[indice].sinOrdenesPendientesDetectado = false; // Nueva variable
    secuencias[indice].tpReubicado = false;
    secuencias[indice].ultimasPosicionesConsideradas = 0;
    
    // Limpiar array de √≥rdenes
    for(int i = 0; i < 10; i++)
    {
        secuencias[indice].ultimasOrdenes[i] = 0;
    }
}

//+------------------------------------------------------------------+
//| Verificar existencia de una orden pendiente                      |
//+------------------------------------------------------------------+
bool VerificarExistenciaOrdenPendiente(ulong ticket)
{
    if(ticket == 0) return false;
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ordenTicket = OrderGetTicket(i);
        if(ordenTicket == ticket && OrderSelect(ordenTicket))
        {
            return true;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Versi√≥n mejorada de recrear orden entrada #2 para evitar duplicados|
//+------------------------------------------------------------------+
bool RecrearOrdenEntrada2(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) 
        return false;
    
    // Si la orden fue cerrada manualmente, no la recreamos
    if(secuencias[indice].cerradaManualmente)
    {
        Print("?? No se recrea orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id, " porque fue cerrada manualmente");
        return false;
    }
    
    // Verificar si ya existen √≥rdenes pendientes para esta secuencia y eliminar duplicados
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    // Si hay m√∫ltiples √≥rdenes pendientes, limpiar las duplicadas
    if(tieneMultiples)
    {
        Print("?? Detectadas √≥rdenes pendientes duplicadas para secuencia #", secuencias[indice].id, " - Limpiando");
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    // Verificar si la orden pendiente de Entrada #2 espec√≠fica existe
    if(VerificarExistenciaOrdenPendiente(secuencias[indice].ticketEntrada2))
    {
        secuencias[indice].entradaPendienteActiva = true;
        return true; // La orden ya existe, no necesita recreaci√≥n
    }
    
    // Si ya hay alguna orden pendiente de esta secuencia pero no es la ENT2 espec√≠fica,
    // vamos a verificar si hay otra orden ENT2 con otro ticket
    if(tieneOrdenPendiente)
    {
        string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT2";
        
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                // Encontramos una orden ENT2 diferente a la que ten√≠amos registrada
                secuencias[indice].ticketEntrada2 = ticket;
                secuencias[indice].entradaPendienteActiva = true;
                Print("?? Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticket);
                return true;
            }
        }
    }
    // Evitar recreaciones demasiado frecuentes (m√°ximo una vez cada 5 segundos)
    if(TimeCurrent() - secuencias[indice].ultimaRecreacionPendiente < 5)
        return false;
    
    secuencias[indice].ultimaRecreacionPendiente = TimeCurrent();
    
    // Solo recrear si estamos en la fase inicial (secuenciaActual <= 2)
    // y la entrada pendiente est√° marcada como activa
    if(secuencias[indice].secuenciaActual <= 2 && secuencias[indice].entradaPendienteActiva)
    {
        string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_";
        string comentarioEnt2 = comentarioBase + "ENT2";
        double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT)) * 2;
        ulong resultTicket = 0;
        
        Print("?? Recreando orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id);
        
        if(secuencias[indice].esModoCompra)
        {
            // ENTRADA #2: SELL STOP
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        else
        {
            // ENTRADA #2: BUY STOP
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        
        if(resultTicket > 0)
        {
            secuencias[indice].ticketEntrada2 = resultTicket;
            RegistrarOrden(indice, resultTicket, comentarioEnt2);
            Print("? Orden pendiente ENTRADA #2 recreada exitosamente con ticket #", resultTicket);
            return true;
        }
        else
        {
            Print("? Error al recrear orden pendiente ENTRADA #2: ", GetLastError());
            return false;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Funci√≥n para recuperar √≥rdenes pendientes perdidas - mejorada    |
//+------------------------------------------------------------------+
void RecuperarOrdenesPendientes()
{
    // Primero limpiar posibles duplicados en todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            if(tieneMultiples)
            {
                Print("?? Limpiando √≥rdenes duplicadas para secuencia #", secuencias[i].id, " durante recuperaci√≥n");
                EliminarOrdenesPendientesDuplicadas(i);
            }
        }
    }
    
    // Ahora recrear √≥rdenes pendientes si es necesario
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva)
        {
            RecrearOrdenEntrada2(i);
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n modificada para verificar peri√≥dicamente √≥rdenes pendientes |
//+------------------------------------------------------------------+
void VerificarOrdenesPendientes()
{
    // Limitar la frecuencia de verificaci√≥n (cada 5 segundos)
    datetime tiempoActual = TimeCurrent();
    if(tiempoActual - ultimaVerificacionPendientes < 5)
        return;
        
    ultimaVerificacionPendientes = tiempoActual;
    
    // Recorrer todas las secuencias activas
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
        {
            // Verificar si hay √≥rdenes pendientes duplicadas
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            // Si hay m√∫ltiples √≥rdenes pendientes, limpiar las duplicadas
            if(tieneMultiples)
            {
                Print("?? Detectadas √≥rdenes pendientes duplicadas para secuencia #", secuencias[i].id, " - Limpiando");
                EliminarOrdenesPendientesDuplicadas(i);
            }
            
            // Verificar si la orden pendiente Entrada #2 sigue existiendo
            if(!VerificarExistenciaOrdenPendiente(secuencias[i].ticketEntrada2) && !tieneOrdenPendiente)
            {
                // Si no existe, intentar recrearla
                Print("?? Orden pendiente ENTRADA #2 no encontrada para secuencia #", secuencias[i].id, " - Intentando recrear");
                RecrearOrdenEntrada2(i);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n optimizada para cerrar r√°pidamente sin √≥rdenes pendientes|
//+------------------------------------------------------------------+
void VerificarCierrePorFaltaDePendientes()
{
    datetime tiempoActual = TimeCurrent();
    
    for(int i = 0; i < 20; i++)
    {
        // Solo procesar secuencias activas que no est√°n ya marcadas para cierre
        if(!secuencias[i].activa || secuencias[i].tpAlcanzado) 
            continue;
            
        // Verificar si hay posiciones abiertas para esta secuencia
        bool tienePositionesAbiertas = false;
        string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
        int numPosiciones = 0;
        
        for(int p = 0; p < PositionsTotal(); p++)
        {
            ulong ticket = PositionGetTicket(p);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                tienePositionesAbiertas = true;
                numPosiciones++;
            }
        }
        
        // Si no tiene posiciones abiertas, no hay nada que hacer
        if(!tienePositionesAbiertas)
            continue;
        
        // Verificar si hay √≥rdenes pendientes para esta secuencia
        bool tieneMultiples = false;
        bool tienePendientes = TieneOrdenesPendientes(i, tieneMultiples);
        
        // Si hay m√∫ltiples √≥rdenes pendientes, limpiar duplicados primero
        if(tieneMultiples)
        {
            Print("?? Detectadas √≥rdenes duplicadas para secuencia #", secuencias[i].id);
            EliminarOrdenesPendientesDuplicadas(i);
            tienePendientes = true;
        }
        
        // Si hay posiciones pero NO hay √≥rdenes pendientes
        if(!tienePendientes && tienePositionesAbiertas)
        {
            // Verificar si hubo una activaci√≥n MUY reciente (15 segundos)
            bool activacionMuyReciente = false;
            datetime startTime = TimeCurrent() - 15;
            
            if(HistorySelect(startTime, TimeCurrent()))
            {
                for(int h = 0; h < HistoryDealsTotal(); h++)
                {
                    ulong dealTicket = HistoryDealGetTicket(h);
                    if(!HistoryDealSelect(dealTicket)) continue;
                    
                    string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                        {
                            activacionMuyReciente = true;
                            break;
                        }
                    }
                }
            }
            
            // Si hubo activaci√≥n muy reciente, dar una oportunidad m√°s
            if(activacionMuyReciente)
            {
                Print("? Activaci√≥n muy reciente en secuencia #", secuencias[i].id, " - Esperando...");
                continue;
            }
            
            // CIERRE INMEDIATO sin m√°s demoras
            Print("?? ALERTA CR√çTICA: Secuencia #", secuencias[i].id, 
                  " con ", numPosiciones, " posiciones SIN √≥rdenes pendientes - CIERRE INMEDIATO");
            
            // Marcar para cierre inmediato
            secuencias[i].tpAlcanzado = true;
            secuencias[i].ultimoCierreIntentado = TimeCurrent();
            
            // Cierre agresivo inmediato
            CerrarTodasLasOrdenesDeSecuencia(i, true);
            
            // Si no se cerr√≥ completamente en el primer intento, forzar
            if(!secuencias[i].cerradaCompletamente)
            {
                // Segundo intento inmediato
                Sleep(50);
                CerrarTodasLasOrdenesDeSecuencia(i, true);
            }
            
            // Marcar como cerrada aunque queden posiciones (se cerrar√°n en OnTick)
            secuencias[i].activa = false;
            totalSecuencias--;
            
            Print("? Secuencia #", secuencias[i].id, " marcada para cierre por seguridad");
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| Crear panel principal de la interfaz                             |
//+------------------------------------------------------------------+
void CrearPanelPrincipal(int x, int y, int ancho, int alto)
{
    string fullId = EA_OBJ_PREFIX + panelPrincipalID;
    
    // Crear panel de fondo
    if(ObjectFind(0, fullId) < 0) {
        ObjectCreate(0, fullId, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    }
    
    // Configurar propiedades
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, fullId, OBJPROP_WIDTH, 1);
    ObjectSetInteger(0, fullId, OBJPROP_BACK, false);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_SELECTED, false);
    ObjectSetInteger(0, fullId, OBJPROP_HIDDEN, true);
    ObjectSetInteger(0, fullId, OBJPROP_ZORDER, 0);
}

//+------------------------------------------------------------------+
//| Crear interfaz gr√°fica                                           |
//+------------------------------------------------------------------+
void CrearInterfaz()
{
    // Comprobar si la interfaz ya existe antes de crearla de nuevo
    if(ObjectFind(0, EA_OBJ_PREFIX + botonCompraID) >= 0 && 
       ObjectFind(0, EA_OBJ_PREFIX + botonVentaID) >= 0) {
        Print("Interfaz ya existe, omitiendo creaci√≥n");
        interfazCreada = true;
        RestaurarValores();
        
        // Nuevo: Restaurar estado de secuencias si existen
        RestaurarEstadoSecuencias();
        return;
    }
    
    // No eliminar todos los objetos, s√≥lo los pertenecientes al EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    
    // Definir dimensiones del panel y componentes
    int x = 20;
    int y = 20;
    int anchoBotones = 120;
    int altoBoton = 30;
    int anchoPanel = anchoBotones * 2 + 20; // Reducido el espaciado
    int altoPanel = 320; // Aumentado para incluir el nuevo campo # Cerrar
    int espaciado = 10;
    int margenX = 10; // Reducido el margen
    int margenY = 10;
    
    // Crear panel principal
    CrearPanelPrincipal(x, y, anchoPanel, altoPanel);
    
    // Ajustar posiciones para estar dentro del panel
    x += margenX;
    y += margenY;
    
    // Crear controles dentro del panel
    // CAMBIO 1: Botones con posiciones intercambiadas
    CrearBoton(botonVentaID, "VENTA", x, y, anchoBotones, altoBoton, clrRed); // VENTA a la izquierda
    CrearBoton(botonCompraID, "COMPRA", x + anchoBotones + espaciado - 10, y, anchoBotones, altoBoton, clrGreen); // COMPRA a la derecha
    y += altoBoton + espaciado;

    // CAMBIO 2: Campo "Lote inicial" (antes "Lote entrada #1")
    CrearCampoEdicionEstilizado(editLotajeID, "Lote inicial", x, y, anchoBotones * 2, altoBoton, DoubleToString(LotajeInicial, 2));
    y += altoBoton + espaciado;

    // CAMBIO 3 y 4: Campos TP E1 y TP E2 juntos
    CrearCampoEdicionEstilizado(editTP1ID, "TP E1", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP1Puntos));
    y += altoBoton + espaciado;
    
    CrearCampoEdicionEstilizado(editTP2ID, "TP E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP2Puntos));
    y += altoBoton + espaciado;
    
    // CAMBIO 5: Campo "Dist. E1/E2" (antes "Entrada #2")
    CrearCampoEdicionEstilizado(editPipsEntrada2ID, "Dist. E1/E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(PipsEntrada2));
    y += altoBoton + espaciado;
    
    // CAMBIO 6: Campo "Ganancia M." (antes "Minima G.")
    CrearCampoEdicionEstilizado(editMinimaGID, "Ganancia M.", x, y, anchoBotones * 2, altoBoton, DoubleToString(MinimaG, 2));
    y += altoBoton + espaciado;
    
    // CAMBIO 7: Campo "# Reubicar" (antes "No. Entrada")
    CrearCampoEdicionEstilizado(editNumEntradaID, "# Reubicar", x, y, anchoBotones * 2, altoBoton, NumEntrada == 0 ? "" : IntegerToString(NumEntrada));
    y += altoBoton + espaciado;
    
    // CAMBIO 8: Nuevo campo "# Cerrar"
    CrearCampoEdicionEstilizado(editNumCerrarID, "# Cerrar", x, y, anchoBotones * 2, altoBoton, NumCerrar == 0 ? "" : IntegerToString(NumCerrar));
    
    // Restaurar valores despu√©s de crear los objetos
    RestaurarValores();
    
    // Nuevo: Restaurar estado de secuencias si existen
    RestaurarEstadoSecuencias();
    
    interfazCreada = true;
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Crear campos de edici√≥n                                          |
//+------------------------------------------------------------------+
void CrearCampoEdicion(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 3);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrBlack);

    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_LEFT);
}
//+------------------------------------------------------------------+
//| Crear campos de edici√≥n estilizados (fondo negro, texto claro)   |
//+------------------------------------------------------------------+
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    // Crear etiqueta
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 5);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, labelId, OBJPROP_FONTSIZE, 8);
    ObjectSetInteger(0, labelId, OBJPROP_SELECTABLE, false); // No seleccionable
    
    // Crear campo de edici√≥n
    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho - 100);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_CENTER);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrRed);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_READONLY, false);   // Asegurar que se pueda editar
}

//+------------------------------------------------------------------+
//| Crear botones                                                    |
//+------------------------------------------------------------------+
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor)
{
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, fullId, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, texto);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_STATE, false);
}

//+------------------------------------------------------------------+
//| Registrar orden en secuencia                                     |
//+------------------------------------------------------------------+
void RegistrarOrden(int indice, ulong ticket, string comentario="")
{
    if(indice < 0 || indice >= 10 || !secuencias[indice].activa) return;
    
    // Si el array est√° lleno, desplazar hacia abajo
    if(secuencias[indice].numOrdenes >= 10)
    {
        for(int i = 0; i < 9; i++)
        {
            secuencias[indice].ultimasOrdenes[i] = secuencias[indice].ultimasOrdenes[i+1];
        }
        secuencias[indice].ultimasOrdenes[9] = ticket;
    }
    else
    {
        secuencias[indice].ultimasOrdenes[secuencias[indice].numOrdenes] = ticket;
        secuencias[indice].numOrdenes++;
    }
    
    // Guardar los tickets de entrada 1 y 2 espec√≠ficamente
    if(comentario != "")
    {
        if(StringFind(comentario, "ENT1") >= 0 || 
           StringFind(PositionGetString(POSITION_COMMENT), "ENT1") >= 0 ||
           StringFind(OrderGetString(ORDER_COMMENT), "ENT1") >= 0)
        {
            secuencias[indice].ticketEntrada1 = ticket;
            Print("?? Registrada ENTRADA #1 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
        else if(StringFind(comentario, "ENT2") >= 0 || 
                StringFind(PositionGetString(POSITION_COMMENT), "ENT2") >= 0 ||
                StringFind(OrderGetString(ORDER_COMMENT), "ENT2") >= 0)
        {
            secuencias[indice].ticketEntrada2 = ticket;
            secuencias[indice].entradaPendienteActiva = true; // Marcar que hay una entrada pendiente activa
            Print("?? Registrada ENTRADA #2 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
    }
    
    Print("Orden #", ticket, " registrada en secuencia #", secuencias[indice].id);
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de compra                                      |
//+------------------------------------------------------------------+
void IniciarSecuenciaCompra()
{
    IniciarSecuencia(true); // true = modo compra
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de venta                                       |
//+------------------------------------------------------------------+
void IniciarSecuenciaVenta()
{
    IniciarSecuencia(false); // false = modo venta
}

//+------------------------------------------------------------------+
//| Cerrar todas las secuencias                                      |
//+------------------------------------------------------------------+
void CerrarTodasLasSecuencias()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            Print("?? Iniciando cierre de secuencia #", secuencias[i].id);
            CerrarSecuencia(i);
            Sleep(200); // Pausa entre cierres de secuencias
        }
    }
}

//+------------------------------------------------------------------+
//| Cerrar todas las √≥rdenes de una secuencia                        |
//+------------------------------------------------------------------+
void CerrarTodasLasOrdenesDeSecuencia(int indice, bool cierreRapido = false)
{
    if(!secuencias[indice].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    bool errorEnCierre = false;
    
    // Configurar slippage para cierres r√°pidos
    if(cierreRapido) {
        // Guardar la desviaci√≥n actual
        int slippage_original = 10; // Valor predeterminado
        
        // Aumentar el slippage para cierre r√°pido
        trade.SetDeviationInPoints(50);
        Print("? Modo cierre r√°pido activado para secuencia #", secuencias[indice].id, " - Slippage aumentado");
    }
    
    // 1. Guardar todos los tickets de √≥rdenes primero para intentar cerrarlos despu√©s
    int numPosiciones = 0;
    ulong posicionesTickets[50];  // Array para guardar tickets de posiciones
    int numOrdenes = 0;
    ulong ordenesTickets[50];     // Array para guardar tickets de √≥rdenes pendientes
    
    // Obtener todos los tickets de posiciones abiertas de esta secuencia
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesTickets[numPosiciones++] = ticket;
        }
    }
    
    // Obtener todos los tickets de √≥rdenes pendientes de esta secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            ordenesTickets[numOrdenes++] = ticket;
        }
    }
    
    // A√±adir las √≥rdenes espec√≠ficas de entrada 1 y 2 si est√°n registradas
    if(secuencias[indice].ticketEntrada1 > 0)
    {
        bool encontrado = false;
        for(int i = 0; i < numOrdenes; i++)
        {
            if(ordenesTickets[i] == secuencias[indice].ticketEntrada1)
            {
                encontrado = true;
                break;
            }
        }
        if(!encontrado)
        {
            ordenesTickets[numOrdenes++] = secuencias[indice].ticketEntrada1;
            Print("??? A√±adida ENTRADA #1 espec√≠fica ticket #", secuencias[indice].ticketEntrada1, " a la lista para cierre");
        }
    }
    
    if(secuencias[indice].ticketEntrada2 > 0)
    {
        bool encontrado = false;
        for(int i = 0; i < numOrdenes; i++)
        {
            if(ordenesTickets[i] == secuencias[indice].ticketEntrada2)
            {
                encontrado = true;
                break;
            }
        }
        if(!encontrado)
        {
            ordenesTickets[numOrdenes++] = secuencias[indice].ticketEntrada2;
            Print("??? A√±adida ENTRADA #2 espec√≠fica ticket #", secuencias[indice].ticketEntrada2, " a la lista para cierre");
        }
    }
    // 2. Eliminar todas las √≥rdenes pendientes primero (para evitar que se activen durante el cierre)
    for(int i = 0; i < numOrdenes; i++)
    {
        ulong ticket = ordenesTickets[i];
        if(!OrderSelect(ticket)) continue;
        
        Print("?? Eliminando orden pendiente #", ticket, " de secuencia #", secuencias[indice].id);
        if(!trade.OrderDelete(ticket))
        {
            Print("? Error al eliminar orden #", ticket, ": ", GetLastError());
            errorEnCierre = true;
        }
        else
        {
            Print("? Orden #", ticket, " eliminada exitosamente");
        }
        
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(10); // Pausa muy breve
        else
            Sleep(50); // Pausa est√°ndar
    }
    
    // 3. Cerrar todas las posiciones abiertas
    for(int i = 0; i < numPosiciones; i++)
    {
        ulong ticket = posicionesTickets[i];
        if(!PositionSelectByTicket(ticket)) continue;
        
        Print("?? Cerrando posici√≥n #", ticket, " de secuencia #", secuencias[indice].id);
        if(!trade.PositionClose(ticket))
        {
            Print("? Error al cerrar posici√≥n #", ticket, ": ", GetLastError());
            errorEnCierre = true;
        }
        else
        {
            Print("? Posici√≥n #", ticket, " cerrada exitosamente");
        }
        
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(10); // Pausa muy breve
        else
            Sleep(50); // Pausa est√°ndar
    }
    
    // Si hubo errores, un segundo intento m√°s agresivo
    if(errorEnCierre)
    {
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(50); // Pausa breve
        else
            Sleep(200); // Pausa est√°ndar
        
        // Segundo intento para √≥rdenes pendientes
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.OrderDelete(ticket);
                if(cierreRapido)
                    Sleep(5);
                else
                    Sleep(50);
            }
        }
        
        // Segundo intento de cierre de posiciones
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.PositionClose(ticket);
                if(cierreRapido)
                    Sleep(5);
                else
                    Sleep(50);
            }
        }
    }
    
    // Verificaci√≥n final
    bool quedanOrdenes = false;
    
    // Verificar si quedan √≥rdenes pendientes
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                quedanOrdenes = true;
                trade.OrderDelete(ticket); // √öltimo intento
            }
        }
    }
    
    // Verificar si quedan posiciones abiertas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                quedanOrdenes = true;
                trade.PositionClose(ticket); // √öltimo intento
            }
        }
    }
    
    // Restaurar slippage original si se modific√≥
    if(cierreRapido) {
        trade.SetDeviationInPoints(10); // Restaurar al valor predeterminado
    }
    
    if(!quedanOrdenes)
    {
        secuencias[indice].cerradaCompletamente = true;
        Print("? Secuencia #", secuencias[indice].id, " cerrada completamente");
    }
    else if(cierreRapido)
    {
        // En modo r√°pido, intentar un cierre agresivo con retardos m√≠nimos
        Print("? Realizando √∫ltimo intento de cierre agresivo para secuencia #", secuencias[indice].id);
        
        // Cerrar todas las posiciones restantes con m√°xima prioridad
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    trade.SetDeviationInPoints(100); // M√°ximo slippage para forzar cierre
                    trade.PositionClose(ticket);
                    trade.SetDeviationInPoints(10); // Restaurar al valor predeterminado
                }
            }
        }
        
        // Verificar una √∫ltima vez
        quedanOrdenes = false;
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    quedanOrdenes = true;
                    break;
                }
            }
        }
        
        if(!quedanOrdenes)
        {
            secuencias[indice].cerradaCompletamente = true;
            Print("? Secuencia #", secuencias[indice].id, " cerrada completamente despu√©s de intento agresivo");
        }
    }
}

//+------------------------------------------------------------------+
//| FUNCI√ìN VERIFICADA: Cierre sincronizado virtual                 |
//| REEMPLAZA la funci√≥n existente CerrarTodasLasPosicionesVirtual  |
//+------------------------------------------------------------------+
void CerrarTodasLasPosicionesVirtual(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // Obtener tick actual
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick))
    {
        Print("? Error obteniendo tick actual");
        return;
    }
    
    Print("\n?????? EJECUTANDO CIERRE VIRTUAL ??????");
    Print("BID: ", tick.bid, " / ASK: ", tick.ask);
    
    // Calcular ganancia esperada en este momento
    double gananciaTotal = 0;
    double comisionTotal = 0;
    double swapTotal = 0;
    int numPosiciones = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double vol = PositionGetDouble(POSITION_VOLUME);
            double precio = PositionGetDouble(POSITION_PRICE_OPEN);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double ganancia;
            if(tipo == POSITION_TYPE_BUY)
            {
                ganancia = (tick.bid - precio) * vol * 100000;
            }
            else
            {
                ganancia = (precio - tick.ask) * vol * 100000;
            }
            
            gananciaTotal += ganancia;
            comisionTotal += CalcularComisionPepperstone(vol);
            swapTotal += PositionGetDouble(POSITION_SWAP);
            numPosiciones++;
        }
    }
    
    double gananciaNetaEsperada = gananciaTotal - comisionTotal + swapTotal;
    
    Print("?? Posiciones a cerrar: ", numPosiciones);
    Print("?? Ganancia neta esperada: ‚Ç¨", DoubleToString(gananciaNetaEsperada, 2));
    
    // Configurar trade para cierre r√°pido
    CTrade tradeFast;
    tradeFast.SetAsyncMode(true);
    tradeFast.SetDeviationInPoints(50);
    
    // 1. Eliminar √≥rdenes pendientes
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                tradeFast.OrderDelete(ticket);
            }
        }
    }
    
    // 2. Cerrar todas las posiciones
    int cierresExitosos = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                if(tradeFast.PositionClose(ticket))
                {
                    cierresExitosos++;
                }
            }
        }
    }
    
    Print("? Posiciones cerradas: ", cierresExitosos, " de ", numPosiciones);
    
    // Limpiar l√≠nea virtual
    string lineaId = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
    ObjectDelete(0, lineaId);
    ObjectDelete(0, lineaId + "_Label");
    
    // Marcar secuencia como inactiva
    secuencias[indiceSecuencia].activa = false;
    secuencias[indiceSecuencia].tpReubicado = false;
    totalSecuencias--;
    
    GuardarEstadoSecuencias();
    ChartRedraw();
    
    Print("?? CIERRE VIRTUAL COMPLETADO\n");
}

//+------------------------------------------------------------------+
//| Cerrar una secuencia                                             |
//+------------------------------------------------------------------+
void CerrarSecuencia(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string tipoSecuencia = secuencias[indice].esModoCompra ? "COMPRA" : "VENTA";
    Print("?? Cerrando secuencia #", secuencias[indice].id, " (", tipoSecuencia, ")");
    
    // Usar cierre r√°pido para acelerar el proceso
    CerrarTodasLasOrdenesDeSecuencia(indice, true);
    
    // Si se logr√≥ cerrar completamente
    if(secuencias[indice].cerradaCompletamente)
    {
        secuencias[indice].activa = false;
        secuencias[indice].entradaPendienteActiva = false;
        totalSecuencias--;
        Print("?? Secuencia #", secuencias[indice].id, " (", tipoSecuencia, ") finalizada y marcada como inactiva");
    }
    else
    {
        // Si no se cerr√≥ completamente, mantener activa pero marcar TP
        secuencias[indice].tpAlcanzado = true;
        secuencias[indice].intentosCierre++;
        secuencias[indice].ultimoCierreIntentado = TimeCurrent();
        Print("?? Secuencia #", secuencias[indice].id, " pendiente de cierre completo - Intentos: ", secuencias[indice].intentosCierre);
    }
    // AGREGAR ESTA L√çNEA AL FINAL DE LA FUNCI√ìN:
    LimpiarLineaCierreVirtual(indice);
}

//+------------------------------------------------------------------+
//| Verificar nuevas activaciones                                     |
//+------------------------------------------------------------------+
void VerificarNuevasActivaciones(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    bool ordenActivada = false;
    
    // Verificar posiciones abiertas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, comentarioBase) >= 0)
        {
            ordenActivada = true;
            break;
        }
    }
    
    // Verificar historial reciente si no se encontr√≥ en posiciones activas
    if(!ordenActivada)
    {
        datetime startTime = TimeCurrent() - 300; // 5 minutos
        if(HistorySelect(startTime, TimeCurrent()))
        {
            for(int i = 0; i < HistoryDealsTotal(); i++)
            {
                ulong dealTicket = HistoryDealGetTicket(i);
                if(!HistoryDealSelect(dealTicket)) continue;
                
                string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                if(StringFind(comentario, comentarioBase) >= 0)
                {
                    // Si es una operaci√≥n de apertura
                    if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                    {
                        ordenActivada = true;
                        break;
                    }
                }
            }
        }
    }
    
    // Si se activ√≥ una orden y no hay TP alcanzado
    if(ordenActivada && !secuencias[indice].tpAlcanzado)
    {
        // Si es ENTRADA #2, marcar como inactiva para evitar recreaciones
        if(secuencias[indice].secuenciaActual == 2)
        {
            secuencias[indice].entradaPendienteActiva = false;
            Print("?? ENTRADA #2 activada - Secuencia #", secuencias[indice].id);
            
            // IMPORTANTE: Marcar que se debe verificar reubicaci√≥n de TPs
            string textoNumReubicar = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
            if(textoNumReubicar == "2")
            {
                Print("?? ENTRADA #2 ACTIVADA - SE DEBE REUBICAR TPs");
            }
        }
        
        // CR√çTICO: Programar la siguiente entrada INMEDIATAMENTE
        Print("?? Activaci√≥n detectada - Programando siguiente entrada");
        ProgramarSiguienteEntrada(indice);
    }
}

//+------------------------------------------------------------------+
//| Programar siguiente entrada manteniendo TPs originales          |
//+------------------------------------------------------------------+
void ProgramarSiguienteEntrada(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;

    // Verificar y limpiar duplicados si existen
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    if(tieneMultiples)
    {
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    double lotajeBase = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    
    secuencias[indice].secuenciaActual++;
    double lotaje = lotajeBase * MathPow(2, secuencias[indice].secuenciaActual - 1);

    // Validar lotaje m√°ximo
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    if(lotaje > maxVolume)
    {
        lotaje = maxVolume;
    }

    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    ulong resultTicket = 0;
    
    // Verificar si ya existe
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, comentarioBase) == 0)
        {
            Print("?? Ya existe orden ", comentarioBase);
            return;
        }
    }
    
    bool esImpar = secuencias[indice].secuenciaActual % 2 == 1;
    
    // IMPORTANTE: Usar TPs individuales siempre (el cierre virtual se encarga del resto)
    double tpAUsar = 0;
    
    // Calcular TP basado en configuraci√≥n original
    int tp1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
    int tp2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
    
    if(secuencias[indice].esModoCompra)
    {
        if(esImpar) // BUY STOP - usar TP E1
            tpAUsar = secuencias[indice].precioEntrada1 + (tp1Puntos * _Point);
        else // SELL STOP - usar TP E2
            tpAUsar = secuencias[indice].precioEntrada2 - (tp2Puntos * _Point);
    }
    else
    {
        if(esImpar) // SELL STOP - usar TP E1
            tpAUsar = secuencias[indice].precioEntrada1 - (tp1Puntos * _Point);
        else // BUY STOP - usar TP E2
            tpAUsar = secuencias[indice].precioEntrada2 + (tp2Puntos * _Point);
    }
    
    tpAUsar = NormalizeDouble(tpAUsar, _Digits);
    
    // Colocar la orden con TP individual
    if(secuencias[indice].esModoCompra)
    {
        if(esImpar)
        {
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando BUY STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
        else
        {
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando SELL STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
    }
    else
    {
        if(esImpar)
        {
            trade.SellStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando SELL STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
        else
        {
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando BUY STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
    }
    
    resultTicket = trade.ResultOrder();
    
    if(resultTicket == 0)
    {
        int error = GetLastError();
        Print("? Error cr√≠tico al programar ", comentarioBase, ": ", error);
        
        // IMPORTANTE: Dar tiempo de seguridad adicional si falla
        secuencias[indice].ultimaVerificacionPendientes = TimeCurrent() + 30;
        return;
    }
    
    if(resultTicket > 0)
    {
        RegistrarOrden(indice, resultTicket, comentarioBase);
        Print("? ", comentarioBase, " programada exitosamente - Ticket: ", resultTicket, " - TP: ", DoubleToString(tpAUsar, _Digits));
        
        // Si est√° en modo cierre virtual, informar
        if(secuencias[indice].tpReubicado)
        {
            Print("?? Nota: Sistema de cierre virtual activo - Se cerrar√° TODO al alcanzar ganancia objetivo");
        }
        
        // CR√çTICO: Actualizar tiempo de verificaci√≥n para evitar cierre prematuro
        secuencias[indice].ultimaVerificacionPendientes = TimeCurrent();
        
        GuardarEstadoSecuencias();
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n com√∫n para iniciar secuencia (compra o venta)            |
//+------------------------------------------------------------------+
void IniciarSecuencia(bool esCompra)
{
    double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    if(lotaje <= 0)
    {
        Alert("Lotaje inv√°lido");
        return;
    }

    double minVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    lotaje = MathRound(lotaje / volumeStep) * volumeStep;
    
    if(lotaje < minVolume || lotaje > maxVolume)
    {
        Alert("Lotaje debe estar entre " + DoubleToString(minVolume, 2) + " y " + DoubleToString(maxVolume, 2));
        return;
    }

    int tp1 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
    int pipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
    int tp2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));

    if(tp1 <= 0 || pipsEntrada2 <= 0 || tp2 <= 0)
    {
        Alert("Valores de TP o PIPS inv√°lidos");
        return;
    }

    // Encontrar un slot libre para la nueva secuencia
    int slotLibre = -1;
    for(int i = 0; i < 20; i++)
    {
        if(!secuencias[i].activa)
        {
            slotLibre = i;
            break;
        }
    }
    
    if(slotLibre == -1)
    {
        Alert("Error interno: No se encontr√≥ slot libre para la secuencia");
        return;
    }
    
    // Configurar la nueva secuencia
    secuencias[slotLibre].id = proximoIDSecuencia++;
    secuencias[slotLibre].activa = true;
    secuencias[slotLibre].secuenciaActual = 2;
    secuencias[slotLibre].tiempoInicio = TimeCurrent();
    secuencias[slotLibre].numOrdenes = 0;
    secuencias[slotLibre].tpAlcanzado = false;
    secuencias[slotLibre].ultimaVerificacionTP = 0;
    secuencias[slotLibre].cerradaCompletamente = false;
    secuencias[slotLibre].intentosCierre = 0;
    secuencias[slotLibre].ultimoCierreIntentado = 0;
    secuencias[slotLibre].esModoCompra = esCompra;
    secuencias[slotLibre].ticketEntrada1 = 0;
    secuencias[slotLibre].ticketEntrada2 = 0;
    secuencias[slotLibre].entradaPendienteActiva = true;
    secuencias[slotLibre].ultimaRecreacionPendiente = 0;
    secuencias[slotLibre].ultimaVerificacionPendientes = 0;
    secuencias[slotLibre].sinOrdenesPendientesDetectado = false;
    secuencias[slotLibre].tpReubicado = false;
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[slotLibre].id) + "_";
    string comentarioEnt1 = comentarioBase + "ENT1";
    string comentarioEnt2 = comentarioBase + "ENT2";
    ulong resultTicket = 0;
    
    if(esCompra)
    {
        // MODO COMPRA: ENTRADA #1 = BUY con TP E1 INDIVIDUAL
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (tp1 * _Point), _Digits);
        
        // IMPORTANTE: BUY con TP INDIVIDUAL basado en TP E1
        trade.Buy(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (BUY): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: SELL STOP con TP E2 INDIVIDUAL
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 - (tp2 * _Point), _Digits);
        
        trade.SellStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    else
    {
        // MODO VENTA: ENTRADA #1 = SELL con TP E1 INDIVIDUAL
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (tp1 * _Point), _Digits);
        
        // IMPORTANTE: SELL con TP INDIVIDUAL basado en TP E1
        trade.Sell(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (SELL): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: BUY STOP con TP E2 INDIVIDUAL
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 + (tp2 * _Point), _Digits);
        
        trade.BuyStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    
    if(resultTicket == 0)
    {
        Alert("Error al programar ENTRADA #2: ", GetLastError());
        CerrarSecuencia(slotLibre);
        return;
    }
    
    RegistrarOrden(slotLibre, resultTicket, comentarioEnt2);

    totalSecuencias++;
    string tipoSecuencia = esCompra ? "COMPRA" : "VENTA";
    Print("?? Nueva secuencia #", secuencias[slotLibre].id, " iniciada en modo ", tipoSecuencia, 
          " - ENTRADA #1 (TP:", DoubleToString(secuencias[slotLibre].tp1Precio, _Digits), 
          ") y #2 (TP:", DoubleToString(secuencias[slotLibre].tp2Precio, _Digits), ") programadas");
    
    GuardarEstadoSecuencias();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Si la interfaz no est√° creada, recrearla
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Monitorear cierre virtual
    MonitorearCierrePorGananciaObjetivo();
    
    // Verificar √≥rdenes pendientes peri√≥dicamente
    VerificarOrdenesPendientes();
    
    // Verificar secuencias sin √≥rdenes pendientes y cerrarlas
    VerificarCierrePorFaltaDePendientes();
    
    // Procesar cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(!secuencias[i].activa) continue;

        // Si ya se detect√≥ TP, asegurarse de que todas las √≥rdenes est√©n cerradas
        if(secuencias[i].tpAlcanzado)
        {
            // Reintentar cierre si no se ha cerrado completamente
            if(!secuencias[i].cerradaCompletamente)
            {
                // Limitar la frecuencia de reintentos a cada 1 segundo
                if(TimeCurrent() - secuencias[i].ultimoCierreIntentado >= 1)
                {
                    Print("?? Reintentando cierre para secuencia #", secuencias[i].id, 
                          " - Intento #", ++secuencias[i].intentosCierre);
                    secuencias[i].ultimoCierreIntentado = TimeCurrent();
                    
                    CerrarTodasLasOrdenesDeSecuencia(i);
                    
                    // Si ya se intent√≥ cerrar muchas veces, marcarla como cerrada de todos modos
                    if(secuencias[i].intentosCierre >= 5)
                    {
                        Print("?? Alcanzado m√°ximo de intentos para secuencia #", secuencias[i].id, 
                              " - Marcando como cerrada");
                        secuencias[i].cerradaCompletamente = true;
                        secuencias[i].activa = false;
                        totalSecuencias--;
                    }
                }
            }
            continue;
        }
        
        // VERIFICACI√ìN DE TP - cada tick para mayor precisi√≥n
        bool tpAlcanzado = false;
        
        // Verificar TPs en posiciones actuales
        for(int j = 0; j < PositionsTotal(); j++)
        {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Si es una posici√≥n de esta secuencia
            if(StringFind(comentario, secPrefix) == 0)
            {
                double tp = PositionGetDouble(POSITION_TP);
                if(tp == 0) continue;  // Omitir posiciones sin TP
                
                double precioActual = PositionGetDouble(POSITION_PRICE_CURRENT);
                ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                
                // Verificar si est√° muy cerca o ha superado el TP (3 puntos para ser m√°s agresivo)
                if((tipo == POSITION_TYPE_BUY && precioActual >= tp - 3*_Point) ||
                   (tipo == POSITION_TYPE_SELL && precioActual <= tp + 3*_Point))
                {
                    tpAlcanzado = true;
                    Print("? TP alcanzado o cercano en posici√≥n #", ticket, " - Secuencia #", secuencias[i].id);
                    break;
                }
            }
        }
        
        // Verificar historial de operaciones recientes para ver si se cerr√≥ alguna por TP
        if(!tpAlcanzado)
        {
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            datetime startTime = TimeCurrent() - 120; // Buscar en los √∫ltimos 2 minutos
            if(HistorySelect(startTime, TimeCurrent()))
            {
                for(int k = 0; k < HistoryDealsTotal(); k++)
                {
                    ulong dealTicket = HistoryDealGetTicket(k);
                    if(!HistoryDealSelect(dealTicket)) continue;
                    
                    string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        // Verificar si es un cierre de posici√≥n
                        if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
                        {
                            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
                            ENUM_DEAL_REASON razon = (ENUM_DEAL_REASON)HistoryDealGetInteger(dealTicket, DEAL_REASON);
                            
                            // Si se cerr√≥ por TP o con beneficio
                            if(razon == DEAL_REASON_TP || profit > 0)
                            {
                                tpAlcanzado = true;
                                Print("? TP detectado en historial - Deal #", dealTicket, " - Secuencia #", secuencias[i].id);
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        // Si se alcanz√≥ TP, cerrar toda la secuencia
        if(tpAlcanzado)
        {
            secuencias[i].tpAlcanzado = true;
            secuencias[i].ultimoCierreIntentado = TimeCurrent();
            string tipoSecuencia = secuencias[i].esModoCompra ? "COMPRA" : "VENTA";
            Print("?? TAKE PROFIT ALCANZADO - Secuencia #", secuencias[i].id, " (", tipoSecuencia, ") - CERRANDO TODAS LAS √ìRDENES");
            
            // Forzar cierre agresivo de todas las √≥rdenes inmediatamente usando el modo r√°pido
            CerrarTodasLasOrdenesDeSecuencia(i, true);
            CerrarSecuencia(i);
            
            // Actualizar el estado de las secuencias cuando se cierra una
            GuardarEstadoSecuencias();
            
            continue;
        }
        
        // PRIMERO: Si est√° en modo cierre virtual, monitorear constantemente
        if(secuencias[i].tpReubicado && !secuencias[i].tpAlcanzado)
        {
            MonitorearCierrePorGananciaObjetivo();
            
            // Si se cerr√≥, continuar con la siguiente secuencia
            if(secuencias[i].tpAlcanzado || !secuencias[i].activa)
                continue;
        }
        
        // PRIMERO: Si est√° en modo cierre virtual, monitorear constantemente
         if(secuencias[i].tpReubicado && !secuencias[i].tpAlcanzado)
         {
         MonitorearCierrePorGananciaObjetivo();
    
         // Si se cerr√≥, continuar con la siguiente secuencia
         if(secuencias[i].tpAlcanzado || !secuencias[i].activa)
         continue;
         }

         // AQU√ç: Verificar activaci√≥n del sistema de cierre virtual
         ReubicarTPsParaGarantiaMinimaG(i);

        // Si no se alcanz√≥ TP, verificar nuevas activaciones
        if(!secuencias[i].tpAlcanzado)
        {
            VerificarNuevasActivaciones(i);
        }
        
        // Verificar si se debe cerrar por n√∫mero de entrada
        VerificarCierrePorNumeroEntrada(i);
        
        // Verificar si necesitamos recrear la orden pendiente de Entrada #2
        if(secuencias[i].entradaPendienteActiva && secuencias[i].secuenciaActual == 2)
        {
            RecrearOrdenEntrada2(i);
        }
    }
    
    // Tambi√©n buscar √≥rdenes hu√©rfanas (sin secuencia asociada)
    LimpiarOrdenesHuerfanas();
    
    LimpiarSecuenciasInactivas();
}

//+------------------------------------------------------------------+
//| FUNCI√ìN NUEVA: Limpieza de secuencias inactivas                 |
//| AGREGAR al OnTick()                                             |
//+------------------------------------------------------------------+
void LimpiarSecuenciasInactivas()
{
    static datetime ultimaLimpieza = 0;
    
    if(TimeCurrent() - ultimaLimpieza < 10) return;
    ultimaLimpieza = TimeCurrent();
    
    int secuenciasLimpiadas = 0;
    
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            bool tieneActividad = false;
            
            // Verificar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    tieneActividad = true;
                    break;
                }
            }
            
            // Verificar √≥rdenes
            if(!tieneActividad)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        tieneActividad = true;
                        break;
                    }
                }
            }
            
            // Limpiar si no hay actividad
            if(!tieneActividad)
            {
                Print("?? Limpiando secuencia fantasma #", secuencias[i].id);
                secuencias[i].activa = false;
                secuencias[i].tpReubicado = false;
                totalSecuencias--;
                secuenciasLimpiadas++;
                
                // Limpiar l√≠neas
                string lineaId = "VirtualClose_" + IntegerToString(secuencias[i].id);
                ObjectDelete(0, lineaId);
                ObjectDelete(0, lineaId + "_Label");
            }
        }
    }
    
    if(secuenciasLimpiadas > 0)
    {
        GuardarEstadoSecuencias();
        ChartRedraw();
    }
}
