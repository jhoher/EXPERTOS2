int GetCurrentDeviation() {
    return 10; // Devolver el valor por defecto
}

//+------------------------------------------------------------------+
//| Función para encontrar la secuencia que corresponde a un ticket  |
//+------------------------------------------------------------------+
int EncontrarSecuenciaPorTicket(ulong ticket)
{
    if(ticket == 0) return -1;
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
        {
            // Buscar primero en tickets registrados específicos
            if(secuencias[i].ticketEntrada1 == ticket || secuencias[i].ticketEntrada2 == ticket)
                return i;
                
            // Buscar en array de últimas órdenes
            for(int j = 0; j < secuencias[i].numOrdenes; j++)
            {
                if(secuencias[i].ultimasOrdenes[j] == ticket)
                    return i;
            }
        }
    }
    
    return -1; // No encontrado
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.00"
#property strict

// Incluir archivos necesarios
#include <Trade\Trade.mqh>

// Prefijo para identificar objetos del EA
string EA_OBJ_PREFIX = "EA_SECUENCIAS_";

// Identificadores de objetos
string panelPrincipalID = "PanelPrincipal";
string editLotajeID = "EditLotaje";
string botonCompraID = "BotonCompra";
string botonVentaID = "BotonVenta";
string editTP1ID = "EditTP1";
string editPipsEntrada2ID = "EditPipsEntrada2";
string editTP2ID = "EditTP2";
string editNumEntradaID = "EditNumEntrada"; 
string editMinimaGID = "EditMinimaG"; // Campo para Minima G.
string editNumCerrarID = "EditNumCerrar"; // NUEVO campo para # Cerrar

// Variables globales
double LotajeInicial = 0.01;
int TP1Puntos = 100;
int PipsEntrada2 = 20;
int TP2Puntos = 100;
int NumEntrada = 0; // CAMBIADO: Inicializado en 0 para permitir campo vacío
double MinimaG = 0.0; // Valor para el campo Minima G.
int NumCerrar = 0; // Número de entrada en el que se cerrará toda la secuencia
bool interfazCreada = false;

// Variable para controlar la verificación de órdenes pendientes
datetime ultimaVerificacionPendientes = 0;

// Estructura para almacenar datos de secuencia
struct SecuenciaInfo {
    int id;                  // Identificador único de secuencia
    bool activa;             // Si la secuencia está activa
    double precioEntrada1;   // Precio de la entrada 1
    double precioEntrada2;   // Precio de la entrada 2
    double tp1Precio;        // Precio TP de entrada 1
    double tp2Precio;        // Precio TP de entrada 2
    int secuenciaActual;     // Número actual de entrada en la secuencia
    datetime tiempoInicio;   // Tiempo de inicio
    ulong ultimasOrdenes[10]; // Tickets de las últimas órdenes en la secuencia
    int numOrdenes;          // Contador de órdenes en ultimasOrdenes
    datetime ultimaVerificacionTP; // Último tiempo de verificación de TP
    bool tpAlcanzado;        // Indica si se detectó TP
    bool cerradaCompletamente; // Indica si la secuencia se cerró completamente
    int intentosCierre;      // Contador de intentos de cierre
    datetime ultimoCierreIntentado; // Último momento en que se intentó cerrar
    bool esModoCompra;       // Indica si es una secuencia iniciada con COMPRA (true) o VENTA (false)
    ulong ticketEntrada1;    // Ticket de la entrada 1
    ulong ticketEntrada2;    // Ticket de la entrada 2
    bool entradaPendienteActiva; // Indica si hay una entrada pendiente activa
    datetime ultimaRecreacionPendiente; // Tiempo de la última recreación de la orden pendiente
    bool cerradaManualmente; // Indica si la entrada pendiente fue cerrada manualmente
    datetime ultimaVerificacionPendientes; // Último tiempo que se verificó si hay pendientes
    bool sinOrdenesPendientesDetectado; // Flag para saber si ya se detectó que no hay pendientes
    bool tpReubicado;  // Nuevo campo para controlar si ya se reubicó el TP
    int ultimasPosicionesConsideradas; // Número de posiciones en el último cálculo de TP
};

// Array para almacenar múltiples secuencias sin límite estricto
SecuenciaInfo secuencias[20]; // Ampliado a 20 secuencias para dar más holgura
int totalSecuencias = 0;
int proximoIDSecuencia = 1;

// Instancia de CTrade
CTrade trade;

// Declaraciones previas de funciones para evitar errores de compilación
void CerrarSecuencia(int indice);
void CerrarSecuenciaVirtual(int indice, bool cierreRapido = false);
void RecuperarOrdenesPendientes();
void CerrarTodasLasSecuencias();
void IniciarSecuencia(bool esCompra);
void IniciarSecuenciaCompra();
void IniciarSecuenciaVenta();
void LimpiarSecuenciasFantasma();
void VerificarOrdenesPendientes();
void VerificarCierrePorFaltaDePendientes();
void VerificarNuevasActivaciones(int indice);
void VerificarCierrePorNumeroEntrada(int indiceSecuencia);
bool RecrearOrdenEntrada2(int indice);
void GuardarEstadoSecuencias();
void GuardarEstadoSecuenciasConID();
void ResetearSecuencia(int indice);
void RestaurarEstadoSecuencias();
void CrearInterfaz();
void CrearPanelPrincipal(int x, int y, int ancho, int alto);
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor);
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor);
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia);
void DiagnosticarSecuencia(int indiceSecuencia);
void LimpiarOrdenesHuerfanas();
void GuardarValores();
void RegistrarOrden(int indice, ulong ticket, string comentario="");
void ProgramarSiguienteEntrada(int indice);
int EncontrarSecuenciaPorTicket(ulong ticket);
void RecalcularTotalSecuencias();
void LimpiarSecuenciasProblematicas();
void ActualizarInformacionSecuencias();
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples);
void EliminarOrdenesPendientesDuplicadas(int indice);
double CalcularComisionPepperstone(double volumen);
double CalcularPLTotalConTP(int indiceSecuencia, double precioTP);
bool VerificarExistenciaOrdenPendiente(ulong ticket);
void ResetearTodasLasSecuencias();
void RestaurarValores();

//+------------------------------------------------------------------+
//| Función para capturar eventos de trading (órdenes, posiciones)   |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                       const MqlTradeRequest& request,
                       const MqlTradeResult& result)
{
    // Solo nos interesa detectar eliminaciones de órdenes pendientes
    if(trans.type == TRADE_TRANSACTION_ORDER_DELETE)
    {
        ulong ticketEliminado = trans.order;
        
        // Encontrar a qué secuencia pertenece esta orden
        int indiceSecuencia = EncontrarSecuenciaPorTicket(ticketEliminado);
        if(indiceSecuencia >= 0)
        {
            // Verificar si es la orden ENTRADA #2
            if(secuencias[indiceSecuencia].ticketEntrada2 == ticketEliminado)
            {
                // Si la razón de eliminación NO es cambio de timeframe o activación,
                // asumimos que fue eliminación manual
                if(trans.order_state == ORDER_STATE_CANCELED)
                {
                    Print("??? Detectada eliminación manual de orden pendiente #", ticketEliminado, 
                          " para secuencia #", secuencias[indiceSecuencia].id);
                    
                    secuencias[indiceSecuencia].cerradaManualmente = true;
                    secuencias[indiceSecuencia].entradaPendienteActiva = false;
                    
                    // Guardar este estado para persistencia
                    GuardarEstadoSecuencias();
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    // Asegurarse de que la interfaz siempre está presente
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Si se detecta un cambio en algún control de edición
    if(id == CHARTEVENT_OBJECT_ENDEDIT) 
    {
        // Capturar el valor actualizado cada vez que el usuario edita un campo
        if(sparam == EA_OBJ_PREFIX + editLotajeID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            LotajeInicial = StringToDouble(texto);
            // Guardar inmediatamente
            GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
            Print("Lotaje actualizado a: ", LotajeInicial);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP1ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP1Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
            Print("TP1 actualizado a: ", TP1Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editPipsEntrada2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            PipsEntrada2 = (int)StringToInteger(texto);
            GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
            Print("Pips Entrada2 actualizado a: ", PipsEntrada2);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP2Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
            Print("TP2 actualizado a: ", TP2Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumEntradaID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vacío o "0"
            if(texto == "" || texto == "0")
            {
                NumEntrada = 0;
            }
            else
            {
                NumEntrada = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
            Print("# Reubicar actualizado a: ", NumEntrada);
        }
        else if(sparam == EA_OBJ_PREFIX + editMinimaGID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            MinimaG = StringToDouble(texto);
            GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
            Print("Minima G. actualizada a: ", MinimaG);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumCerrarID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vacío o "0"
            if(texto == "" || texto == "0")
            {
                NumCerrar = 0;
            }
            else
            {
                NumCerrar = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
            Print("# Cerrar actualizado a: ", NumCerrar);
        }
    }
    
    // Si se detecta un cambio de timeframe
    if(id == CHARTEVENT_CHART_CHANGE)
    {
        Print("Cambio de chart detectado - Asegurando persistencia de órdenes");
        
        // Guardar el estado actual de las secuencias antes del cambio, incluyendo ID
        GuardarEstadoSecuenciasConID();
        
        // Guardar los valores actuales de los controles antes de recrear la interfaz
        if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
            LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
            TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
            PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
            TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumEntrada = 0;
            else
                NumEntrada = (int)StringToInteger(texto);
        }
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
            MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumCerrar = 0;
            else
                NumCerrar = (int)StringToInteger(texto);
        }
        
        // Guardar explícitamente estos valores
        GuardarValores();
        
        // Recrear la interfaz si es necesario
        CrearInterfaz();
        
        // Verificar y recrear órdenes pendientes que puedan haberse perdido
        for(int i = 0; i < 10; i++)
        {
            if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
            {
                Print("?? Verificando orden pendiente para secuencia #", secuencias[i].id, " después de cambio de timeframe");
                secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificación inmediata
                RecrearOrdenEntrada2(i);
            }
        }
        
        // Para evitar perder objetos dibujados manualmente, no hacer limpieza general
        return;
    }
    
    // Gestión de clics en botones
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        // Verificar si se ha hecho clic en uno de nuestros botones
        if(sparam == EA_OBJ_PREFIX + botonCompraID)
        {
            Print("Botón COMPRA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonCompraID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricción de límite
            IniciarSecuenciaCompra();
        }
        else if(sparam == EA_OBJ_PREFIX + botonVentaID)
        {
            Print("Botón VENTA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonVentaID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricción de límite
            IniciarSecuenciaVenta();
        }
    }
}

//+------------------------------------------------------------------+
//| Verificar si se debe cerrar la secuencia por número de entrada  |
//+------------------------------------------------------------------+
void VerificarCierrePorNumeroEntrada(int indiceSecuencia)
{
    // Verificar que la secuencia esté activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
    
    // Obtener el valor del campo "# Cerrar"
    string textoNumCerrar = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
    
    // Si el campo está vacío o es "0", no cerrar por número de entrada
    if(textoNumCerrar == "" || textoNumCerrar == "0")
        return;
    
    int numeroCerrar = (int)StringToInteger(textoNumCerrar);
    
    // Contar las posiciones activas de esta secuencia
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesActivas = 0;
    
    // Contar posiciones
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesActivas++;
        }
    }
    
    // Si se alcanzó o superó el número de entrada configurado, cerrar toda la secuencia
    if(posicionesActivas >= numeroCerrar)
    {
        string tipoSecuencia = secuencias[indiceSecuencia].esModoCompra ? "COMPRA" : "VENTA";
        Print("\n?? CIERRE POR NÚMERO DE ENTRADA #", numeroCerrar, " ALCANZADO");
        Print("?? Secuencia #", secuencias[indiceSecuencia].id, " (", tipoSecuencia, ")");
        Print("?? Posiciones activas: ", posicionesActivas);
        Print("? CERRANDO TODAS LAS ÓRDENES");
        
        // Marcar para cierre
        secuencias[indiceSecuencia].tpAlcanzado = true;
        secuencias[indiceSecuencia].ultimoCierreIntentado = TimeCurrent();
        
        // Cerrar todas las órdenes
        CerrarSecuenciaVirtual(indiceSecuencia, true);
        CerrarSecuencia(indiceSecuencia);
        
        // Actualizar el estado
        GuardarEstadoSecuencias();
    }
}

//+------------------------------------------------------------------+
//| Limpiar órdenes huérfanas (sin secuencia asociada)              |
//+------------------------------------------------------------------+
void LimpiarOrdenesHuerfanas()
{
    // Esta función se ejecuta menos frecuentemente
    static datetime ultimaLimpieza = 0;
    if(TimeCurrent() - ultimaLimpieza < 30) return; // Solo cada 30 segundos
    
    ultimaLimpieza = TimeCurrent();
    
    // Buscar órdenes pendientes con prefijo "SEC" pero sin secuencia activa
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, "SEC") == 0)
        {
            // Extraer el ID de secuencia
            int pos1 = StringFind(comentario, "SEC") + 3;
            int pos2 = StringFind(comentario, "_", pos1);
            if(pos2 == -1) continue;
            
            string idStr = StringSubstr(comentario, pos1, pos2 - pos1);
            int secId = (int)StringToInteger(idStr);
            
            // Verificar si la secuencia está activa
            bool secuenciaEncontrada = false;
            for(int j = 0; j < 10; j++)
            {
                if(secuencias[j].activa && secuencias[j].id == secId)
                {
                    secuenciaEncontrada = true;
                    break;
                }
            }
            
            // Si no se encontró una secuencia activa para esta orden, cerrarla
            if(!secuenciaEncontrada)
            {
                Print("?? Eliminando orden huérfana #", ticket, " - Comentario: ", comentario);
                trade.OrderDelete(ticket);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Función para resetear todas las secuencias (emergencia)          |
//+------------------------------------------------------------------+
void ResetearTodasLasSecuencias()
{
    Print("?? REINICIO DE EMERGENCIA - Reseteando todas las secuencias");
    
    // Primero intenta cerrar todas las posiciones activas
    CerrarTodasLasSecuencias();
    
    // Luego resetear el estado de todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        ResetearSecuencia(i);
    }
    
    // Resetear el contador y el ID
    totalSecuencias = 0;
    proximoIDSecuencia = 1;
    
    // Guardar el estado
    GuardarEstadoSecuencias();
    
    Print("? Reinicio de emergencia completado - Todas las secuencias han sido reseteadas");
}

//+------------------------------------------------------------------+
//| Función para resetear el contador de secuencias activas         |
//+------------------------------------------------------------------+
void RecalcularTotalSecuencias()
{
    int contador = 0;
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
            contador++;
    }
    
    // Si el contador está inconsistente, arreglarlo
    if(contador != totalSecuencias)
    {
        Print("?? Corrigiendo contador de secuencias: de ", totalSecuencias, " a ", contador);
        totalSecuencias = contador;
        GuardarEstadoSecuencias();
    }
}
//+------------------------------------------------------------------+
//| Función para limpiar secuencias problemáticas                    |
//+------------------------------------------------------------------+
void LimpiarSecuenciasProblematicas()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (órdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar órdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos órdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // Últimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("?? Limpiando secuencia #", secuencias[i].id, " - No se encontró actividad asociada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                }
            }
        }
    }
    
    // Guardar el estado actualizado
    GuardarEstadoSecuencias();
}

//+------------------------------------------------------------------+
//| FUNCIÓN 5: ActualizarInformacionSecuencias() - SIMPLIFICADA     |
//| Elimina todos los textos molestos                               |
//+------------------------------------------------------------------+
void ActualizarInformacionSecuencias()
{
    // Eliminar TODOS los objetos de información
    for(int i = 0; i < 20; i++)
    {
        ObjectDelete(0, EA_OBJ_PREFIX + "SecInfo_" + IntegerToString(i));
        ObjectDelete(0, EA_OBJ_PREFIX + "BtnCerrarSec_" + IntegerToString(i));
    }
    
    // Eliminar título y cualquier otro texto
    ObjectDelete(0, EA_OBJ_PREFIX + "SecInfoTitulo");
    
    // Solo redibujar el gráfico
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Función mejorada para verificar si una secuencia tiene órdenes      |
//| pendientes evitando duplicados                                      |
//+------------------------------------------------------------------+
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples)
{
    if(!secuencias[indice].activa) return false;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    int contadorOrdenes = 0;
    tieneMultiples = false;
    
    // Comprobar si hay órdenes pendientes para esta secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            contadorOrdenes++;
            if(contadorOrdenes > 1)
            {
                tieneMultiples = true;
                break;
            }
        }
    }
    
    return (contadorOrdenes > 0);
}

//+------------------------------------------------------------------+
//| Nueva función para eliminar órdenes pendientes duplicadas         |
//+------------------------------------------------------------------+
void EliminarOrdenesPendientesDuplicadas(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    string entradaActualPattern = "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    
    // Preparar arrays para almacenar tickets de órdenes por tipo
    int maxOrdenesPorTipo = 10; // Ajustar según sea necesario
    ulong ticketsENT2[10];      // para órdenes de entrada 2
    ulong ticketsEntradaActual[10]; // para órdenes de la entrada actual 
    int contadorENT2 = 0;
    int contadorEntradaActual = 0;
    
    // Buscar y clasificar todas las órdenes pendientes de la secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        
        // Si pertenece a esta secuencia
        if(StringFind(comentario, secPrefix) == 0)
        {
            // Verificar si es una orden ENT2
            if(StringFind(comentario, "_ENT2") >= 0 && contadorENT2 < maxOrdenesPorTipo)
            {
                ticketsENT2[contadorENT2++] = ticket;
            }
            // Verificar si es una orden de la entrada actual
            else if(StringFind(comentario, entradaActualPattern) >= 0 && contadorEntradaActual < maxOrdenesPorTipo)
            {
                ticketsEntradaActual[contadorEntradaActual++] = ticket;
            }
        }
    }
    
    // Eliminar todas las órdenes ENT2 duplicadas excepto la primera (si hay más de una)
    if(contadorENT2 > 1)
    {
        Print("?? Encontradas ", contadorENT2, " órdenes ENT2 duplicadas para secuencia #", secuencias[indice].id, " - Eliminando extras");
        
        // Solo conservar la primera orden, eliminar las demás
        for(int i = 1; i < contadorENT2; i++)
        {
            if(OrderSelect(ticketsENT2[i]) && trade.OrderDelete(ticketsENT2[i]))
            {
                Print("? Eliminada orden ENT2 duplicada #", ticketsENT2[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("? Error al eliminar orden ENT2 duplicada #", ticketsENT2[i], ": ", GetLastError());
            }
        }
        
        // Actualizar el ticket de entrada2 con el ticket conservado
        if(OrderSelect(ticketsENT2[0]))
        {
            secuencias[indice].ticketEntrada2 = ticketsENT2[0];
            Print("?? Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticketsENT2[0]);
        }
    }
    
    // Eliminar todas las órdenes de la entrada actual duplicadas excepto la primera (si hay más de una)
    if(contadorEntradaActual > 1)
    {
        Print("?? Encontradas ", contadorEntradaActual, " órdenes entrada actual duplicadas para secuencia #", 
              secuencias[indice].id, " (Fase: ", secuencias[indice].secuenciaActual, ") - Eliminando extras");
              // Solo conservar la primera orden, eliminar las demás
        for(int i = 1; i < contadorEntradaActual; i++)
        {
            if(OrderSelect(ticketsEntradaActual[i]) && trade.OrderDelete(ticketsEntradaActual[i]))
            {
                Print("? Eliminada orden entrada duplicada #", ticketsEntradaActual[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("? Error al eliminar orden duplicada #", ticketsEntradaActual[i], ": ", GetLastError());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Función para obtener tasa de conversión USD                     |
//+------------------------------------------------------------------+
double GetUSDConversionRate(string fromCurrency)
{
    // Si la moneda ya es USD, no necesita conversión
    if(fromCurrency == "USD") return 1.0;
    
    // Para EUR, usar tasa aproximada (deberías obtener la tasa real)
    if(fromCurrency == "EUR") return 0.85;
    
    // Para otras monedas, devolver 1.0 como default
    return 1.0;
}

//+------------------------------------------------------------------+
//| Calcular P&L exacto considerando spread para cada posición       |
//+------------------------------------------------------------------+
double CalcularPLConSpread(double precioApertura, double precioTP, 
                          int tipoPosicion, double lotes, double spread)
{
    double valorPip = 10.0; // EUR/USD: 1 pip = 10 EUR por lote
    double pl = 0;
    
    if(tipoPosicion == POSITION_TYPE_BUY)
    {
        // BUY se cierra al BID (precio TP)
        pl = (precioTP - precioApertura) / _Point * lotes * valorPip / 10;
    }
    else // SELL
    {
        // SELL se cierra al ASK (precio TP + spread actual)
        double precioCloseSell = precioTP + spread;
        pl = (precioApertura - precioCloseSell) / _Point * lotes * valorPip / 10;
    }
    
    return pl;
}

//+------------------------------------------------------------------+
//| FUNCIÓN 4: ReubicarTPsParaGarantiaMinimaG() - SIN CAMBIOS       |
//| Mantener como estaba en la versión anterior                     |
//+------------------------------------------------------------------+
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia)
{
    // Verificar que la secuencia esté activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
    
    // Obtener el número de entrada para activar reubicación desde la interfaz
    string textoNumReubicar = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
    
    // Si el campo está vacío o es "0", no hacer nada
    if(textoNumReubicar == "" || textoNumReubicar == "0")
        return;
    
    int entradaReubicar = (int)StringToInteger(textoNumReubicar);
    int entradasActuales = ContarEntradasActivas(indiceSecuencia);
    
    // Solo proceder si tenemos el número mínimo de entradas
    if(entradasActuales < entradaReubicar)
        return;
    
    // Detectar si necesita recálculo
    bool necesitaRecalculo = false;
    
    if(!secuencias[indiceSecuencia].tpReubicado)
    {
        // Primera activación del cierre virtual
        Print("\n?? ACTIVANDO SISTEMA DE CIERRE VIRTUAL");
        Print("?? Secuencia #", secuencias[indiceSecuencia].id);
        Print("?? Entradas activas: ", entradasActuales);
        Print("?? Activado en entrada #", entradaReubicar);
        necesitaRecalculo = true;
        secuencias[indiceSecuencia].tpReubicado = true;
        secuencias[indiceSecuencia].ultimaVerificacionTP = TimeCurrent(); // Marcar tiempo de activación
    }
    else if(entradasActuales > secuencias[indiceSecuencia].ultimasPosicionesConsideradas)
    {
        // Nueva entrada detectada, recalcular
        Print("\n?? RECALCULANDO PRECIO VIRTUAL - Nueva entrada detectada");
        Print("?? Secuencia #", secuencias[indiceSecuencia].id);
        Print("?? Entradas anteriores: ", secuencias[indiceSecuencia].ultimasPosicionesConsideradas);
        Print("?? Entradas actuales: ", entradasActuales);
        necesitaRecalculo = true;
    }
    
    // Solo recalcular si es necesario
    if(necesitaRecalculo)
    {
        double precioVirtual = CalcularPrecioCierreVirtualMejorado(indiceSecuencia);
        
        if(precioVirtual > 0)
        {
            // Actualizar contador
            secuencias[indiceSecuencia].ultimasPosicionesConsideradas = entradasActuales;
            
            // Dibujar/actualizar línea amarilla
            string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
            
            // Eliminar línea anterior si existe
            ObjectDelete(0, nombreLinea);
            ObjectDelete(0, nombreLinea + "_Label");
            
            // Crear nueva línea
            DibujarLineaVirtual(precioVirtual, nombreLinea);
            
            double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
            
            Print("? Precio virtual: ", DoubleToString(precioVirtual, _Digits));
            Print("?? Objetivo: €", DoubleToString(gananciaObjetivo, 2));
            Print("?? La secuencia continúa activa hasta tocar el precio virtual");
            
            // Guardar estado
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| Función para actualizar todos los TPs al precio virtual         |
//+------------------------------------------------------------------+
void ActualizarTakeProfit(int indiceSecuencia, double precioVirtual)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesModificadas = 0;
    
    // Actualizar TPs de todas las posiciones activas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double sl = PositionGetDouble(POSITION_SL);
            
            // Modificar posición con nuevo TP
            if(trade.PositionModify(ticket, sl, precioVirtual))
            {
                posicionesModificadas++;
            }
            else
            {
                Print("? Error al modificar TP de posición #", ticket, ": ", GetLastError());
            }
        }
    }
    
    if(posicionesModificadas > 0)
    {
        Print("? Actualizados ", posicionesModificadas, " TPs al precio virtual: ", 
              DoubleToString(precioVirtual, _Digits));
        
        // Marcar que se reubicaron los TPs
        secuencias[indiceSecuencia].tpReubicado = true;
        secuencias[indiceSecuencia].ultimasPosicionesConsideradas = posicionesModificadas;
    }
}

//+------------------------------------------------------------------+
//| FUNCIÓN AUXILIAR: DibujarLineaVirtual (si no existe)            |
//+------------------------------------------------------------------+
void DibujarLineaVirtual(double precio, string nombre)
{
    // Crear línea horizontal amarilla
    if(ObjectCreate(0, nombre, OBJ_HLINE, 0, 0, precio))
    {
        ObjectSetInteger(0, nombre, OBJPROP_COLOR, clrYellow);
        ObjectSetInteger(0, nombre, OBJPROP_WIDTH, 2);
        ObjectSetInteger(0, nombre, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, nombre, OBJPROP_RAY, true);
        ObjectSetInteger(0, nombre, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, nombre, OBJPROP_HIDDEN, false);
    }
    else
    {
        // Si ya existe, solo actualizar el precio
        ObjectSetDouble(0, nombre, OBJPROP_PRICE, 0, precio);
    }
    
    // Crear etiqueta
    string etiqueta = nombre + "_Label";
    if(ObjectCreate(0, etiqueta, OBJ_TEXT, 0, TimeCurrent(), precio))
    {
        double gananciaMinima = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
        ObjectSetString(0, etiqueta, OBJPROP_TEXT, 
                      "Virtual: " + DoubleToString(precio, _Digits) + 
                      " | Target: €" + DoubleToString(gananciaMinima, 2));
        ObjectSetString(0, etiqueta, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, etiqueta, OBJPROP_FONTSIZE, 9);
        ObjectSetInteger(0, etiqueta, OBJPROP_COLOR, clrYellow);
    }
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| FUNCIÓN AUXILIAR: ContarEntradasActivas (si no existe)          |
//+------------------------------------------------------------------+
int ContarEntradasActivas(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int contador = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            contador++;
        }
    }
    
    return contador;
}

//+------------------------------------------------------------------+
//| Identificar tipo de última entrada activa                       |
//+------------------------------------------------------------------+
ENUM_POSITION_TYPE IdentificarTipoUltimaEntrada(int indiceSecuencia)
{
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int numeroEntradaMayor = 0;
    ENUM_POSITION_TYPE tipoUltimaEntrada = POSITION_TYPE_BUY;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            int posENT = StringFind(comentario, "_ENT");
            if(posENT >= 0)
            {
                string numeroStr = StringSubstr(comentario, posENT + 4);
                int numeroEntrada = (int)StringToInteger(numeroStr);
                
                if(numeroEntrada > numeroEntradaMayor)
                {
                    numeroEntradaMayor = numeroEntrada;
                    tipoUltimaEntrada = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                }
            }
        }
    }
    
    return tipoUltimaEntrada;
}

//+------------------------------------------------------------------+
//| NUEVAFunción de cierre simultáneo exacto                         |
//+------------------------------------------------------------------+
bool CerrarTodasPosicionesSimultaneo(double precioVirtual) {
    // Estructura para snapshot de posiciones
    struct PosicionSnapshot {
        ulong ticket;
        ENUM_POSITION_TYPE tipo;
        double volumen;
        double precioEntrada;
        double profitVirtual;
    };
    
    PosicionSnapshot snapshots[];
    int totalPosiciones = PositionsTotal();
    ArrayResize(snapshots, totalPosiciones);
    
    // Tomar snapshot en el mismo tick
    MqlTick tickActual;
    if(!SymbolInfoTick(_Symbol, tickActual)) return false;
    
    // Calcular profit virtual para cada posición
    double profitTotalVirtual = 0.0;
    
    for(int i = 0; i < totalPosiciones; i++) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        snapshots[i].ticket = ticket;
        snapshots[i].tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        snapshots[i].volumen = PositionGetDouble(POSITION_VOLUME);
        snapshots[i].precioEntrada = PositionGetDouble(POSITION_PRICE_OPEN);
        
        // **CLAVE**: Usar precio apropiado según tipo
        double precioCierre = (snapshots[i].tipo == POSITION_TYPE_BUY) ? 
                             tickActual.bid : tickActual.ask;
        
        // Calcular profit usando OrderCalcProfit para máxima precisión
        double profit = 0.0;
        ENUM_ORDER_TYPE orderType = (snapshots[i].tipo == POSITION_TYPE_BUY) ? 
                                   ORDER_TYPE_SELL : ORDER_TYPE_BUY;
        
        if(OrderCalcProfit(orderType, _Symbol, snapshots[i].volumen, 
                          snapshots[i].precioEntrada, precioCierre, profit)) {
            snapshots[i].profitVirtual = profit;
            profitTotalVirtual += profit;
        }
    }
    
    // Agregar comisiones y swaps al profit virtual
    for(int i = 0; i < totalPosiciones; i++) {
        if(PositionSelectByTicket(snapshots[i].ticket)) {
            profitTotalVirtual += PositionGetDouble(POSITION_COMMISSION);
            profitTotalVirtual += PositionGetDouble(POSITION_SWAP);
        }
    }
    
    // Log del cierre virtual
    Print("=== CIERRE VIRTUAL EJECUTADO ===");
    Print("Precio Virtual Calculado: ", precioVirtual);
    Print("BID/ASK Actuales: ", tickActual.bid, "/", tickActual.ask);
    Print("Total Posiciones: ", totalPosiciones);
    Print("Profit Virtual Total: ", profitTotalVirtual);
    
    // Ejecutar cierre real si el profit virtual cumple objetivo
    return EjecutarCierreReal();
}

bool EjecutarCierreReal() {
    CTrade trade;
    trade.SetAsyncMode(true); // Modo asíncrono para velocidad
    
    bool todoExitoso = true;
    
    // Cerrar todas las posiciones en orden inverso
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0) {
            if(!trade.PositionClose(ticket)) {
                Print("Error cerrando posición: ", ticket, " Error: ", GetLastError());
                todoExitoso = false;
            }
        }
    }
    
    return todoExitoso;
}

//+------------------------------------------------------------------+
//| FUNCIÓN DEFINITIVA: CalcularPrecioCierreVirtualMejorado()       |
//| Versión 7.0 - Cálculo exacto para 0.03 EUR                      |
//+------------------------------------------------------------------+
double CalcularPrecioCierreVirtualMejorado(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    // Estructuras para almacenar datos
    struct DatosPosicion {
        double volumen;
        double precioApertura;
        ENUM_POSITION_TYPE tipo;
        double swap;
        double comisionReal;
    };
    
    DatosPosicion posiciones[];
    int numPosiciones = 0;
    double totalComisiones = 0;
    double totalSwaps = 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n===== CÁLCULO DE PRECIO VIRTUAL =====");
    Print("Secuencia #", secuencias[indiceSecuencia].id);
    
    // Contar posiciones activas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            numPosiciones++;
        }
    }
    
    if(numPosiciones == 0) return 0;
    
    ArrayResize(posiciones, numPosiciones);
    int index = 0;
    
    // Capturar datos de cada posición
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posiciones[index].volumen = PositionGetDouble(POSITION_VOLUME);
            posiciones[index].precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            posiciones[index].tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            posiciones[index].swap = PositionGetDouble(POSITION_SWAP);
            
            // Comisión correcta
            double comisionTotal = CalcularComisionPepperstone(posiciones[index].volumen);
            posiciones[index].comisionReal = comisionTotal;
            totalComisiones += comisionTotal;
            
            totalSwaps += posiciones[index].swap;
            
            string tipoStr = (posiciones[index].tipo == POSITION_TYPE_BUY) ? "BUY" : "SELL";
            Print("  ", tipoStr, " ", DoubleToString(posiciones[index].volumen, 2), 
                  " @ ", DoubleToString(posiciones[index].precioApertura, _Digits),
                  " | Comisión: €", DoubleToString(comisionTotal, 2));
            
            index++;
        }
    }
    
    // Obtener datos del mercado
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = ask - bid;
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    Print("BID: ", DoubleToString(bid, _Digits), " / ASK: ", DoubleToString(ask, _Digits));
    Print("Spread: ", (int)(spread / point), " puntos");
    Print("Comisiones totales: €", DoubleToString(totalComisiones, 2));
    Print("Swaps: €", DoubleToString(totalSwaps, 2));
    
    // Obtener ganancia objetivo
    double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
    if(gananciaObjetivo < 0.01) gananciaObjetivo = 0.10;
    Print("Objetivo: €", DoubleToString(gananciaObjetivo, 2));
    
    // Calcular volúmenes y precios promedio
    double sumaBuyVolumen = 0;
    double sumaSellVolumen = 0;
    double sumaBuyCosto = 0;
    double sumaSellCosto = 0;
    
    for(int i = 0; i < numPosiciones; i++)
    {
        if(posiciones[i].tipo == POSITION_TYPE_BUY)
        {
            sumaBuyVolumen += posiciones[i].volumen;
            sumaBuyCosto += posiciones[i].volumen * posiciones[i].precioApertura;
        }
        else
        {
            sumaSellVolumen += posiciones[i].volumen;
            sumaSellCosto += posiciones[i].volumen * posiciones[i].precioApertura;
        }
    }
    
    double volumenNeto = sumaBuyVolumen - sumaSellVolumen;
    double precioPromedioBuy = (sumaBuyVolumen > 0) ? sumaBuyCosto / sumaBuyVolumen : 0;
    double precioPromedioSell = (sumaSellVolumen > 0) ? sumaSellCosto / sumaSellVolumen : 0;
    
    // CONSTANTE CORRECTA: 1 punto mueve 1 EUR por lote estándar en EURUSD con cuenta EUR
    double valorPorPunto = 1.0; // EUR por lote estándar por punto
    
    // Ganancia requerida (objetivo + comisiones - swaps)
    double gananciaRequerida = gananciaObjetivo + totalComisiones - totalSwaps;
    
    Print("Volumen Buy: ", DoubleToString(sumaBuyVolumen, 2), " @ ", DoubleToString(precioPromedioBuy, _Digits));
    Print("Volumen Sell: ", DoubleToString(sumaSellVolumen, 2), " @ ", DoubleToString(precioPromedioSell, _Digits));
    Print("Volumen neto: ", DoubleToString(volumenNeto, 2), " lotes");
    Print("Ganancia requerida (con comisiones): €", DoubleToString(gananciaRequerida, 2));
    
    // ALGORITMO DE BÚSQUEDA BINARIA PARA PRECIO EXACTO
    double precioVirtual = 0;
    double precioMin = bid - 100 * point;
    double precioMax = bid + 100 * point;
    double tolerancia = 0.001; // 0.001 EUR de tolerancia
    
    // Búsqueda binaria
    for(int iter = 0; iter < 50; iter++)
    {
        double precioTest = (precioMin + precioMax) / 2;
        double plTotal = 0;
        
        // Calcular P&L con precio de prueba
        for(int i = 0; i < numPosiciones; i++)
        {
            if(posiciones[i].tipo == POSITION_TYPE_BUY)
            {
                // BUY cierra al precio virtual (BID)
                double movimiento = precioTest - posiciones[i].precioApertura;
                double puntos = movimiento / point;
                plTotal += puntos * posiciones[i].volumen * valorPorPunto;
            }
            else
            {
                // SELL cierra al precio virtual + spread (ASK)
                double precioCierreSell = precioTest + spread;
                double movimiento = posiciones[i].precioApertura - precioCierreSell;
                double puntos = movimiento / point;
                plTotal += puntos * posiciones[i].volumen * valorPorPunto;
            }
        }
        
        // Calcular ganancia neta
        double gananciaNetaTest = plTotal - totalComisiones + totalSwaps;
        double error = gananciaNetaTest - gananciaObjetivo;
        
        // Si encontramos el precio exacto
        if(MathAbs(error) < tolerancia)
        {
            precioVirtual = precioTest;
            break;
        }
        
        // Ajustar rango de búsqueda
        if(error < 0) // Ganancia menor al objetivo
        {
            if(volumenNeto > 0) // Posición larga
                precioMin = precioTest; // Necesitamos precio más alto
            else if(volumenNeto < 0) // Posición corta
                precioMax = precioTest; // Necesitamos precio más bajo
            else // Balanceada
            {
                if(precioPromedioBuy < precioPromedioSell)
                    precioMin = precioTest;
                else
                    precioMax = precioTest;
            }
        }
        else // Ganancia mayor al objetivo
        {
            if(volumenNeto > 0) // Posición larga
                precioMax = precioTest; // Reducir precio
            else if(volumenNeto < 0) // Posición corta
                precioMin = precioTest; // Aumentar precio
            else // Balanceada
            {
                if(precioPromedioBuy < precioPromedioSell)
                    precioMax = precioTest;
                else
                    precioMin = precioTest;
            }
        }
        
        // Si es la última iteración, tomar el mejor valor
        if(iter == 49)
            precioVirtual = precioTest;
    }
    
    // Normalizar
    precioVirtual = NormalizeDouble(precioVirtual, _Digits);
    
    // VERIFICACIÓN FINAL Y DEBUG
    double plVerificacion = 0;
    Print("\n=== Verificación por posición ===");
    
    for(int i = 0; i < numPosiciones; i++)
    {
        double pl = 0;
        
        if(posiciones[i].tipo == POSITION_TYPE_BUY)
        {
            double movimiento = precioVirtual - posiciones[i].precioApertura;
            double puntos = movimiento / point;
            pl = puntos * posiciones[i].volumen * valorPorPunto;
            
            Print("  BUY ", DoubleToString(posiciones[i].volumen, 2),
                  ": Entrada=", DoubleToString(posiciones[i].precioApertura, _Digits),
                  " Salida=", DoubleToString(precioVirtual, _Digits),
                  " Puntos=", (int)puntos,
                  " P&L=€", DoubleToString(pl, 2));
        }
        else
        {
            double precioCierreSell = precioVirtual + spread;
            double movimiento = posiciones[i].precioApertura - precioCierreSell;
            double puntos = movimiento / point;
            pl = puntos * posiciones[i].volumen * valorPorPunto;
            
            Print("  SELL ", DoubleToString(posiciones[i].volumen, 2),
                  ": Entrada=", DoubleToString(posiciones[i].precioApertura, _Digits),
                  " Salida=", DoubleToString(precioCierreSell, _Digits),
                  " Puntos=", (int)puntos,
                  " P&L=€", DoubleToString(pl, 2));
        }
        
        plVerificacion += pl;
    }
    
    double gananciaNetaFinal = plVerificacion - totalComisiones + totalSwaps;
    
    Print("\n=== RESULTADO FINAL ===");
    Print("PRECIO VIRTUAL CALCULADO: ", DoubleToString(precioVirtual, _Digits));
    
    string direccion = "";
    if(MathAbs(volumenNeto) < 0.001)
        direccion = "BALANCEADA";
    else if(volumenNeto > 0)
        direccion = "LARGA (precio debe subir)";
    else
        direccion = "CORTA (precio debe bajar)";
    
    Print("Dirección: ", direccion);
    Print("P&L Bruto: €", DoubleToString(plVerificacion, 2));
    Print("Comisiones: €", DoubleToString(totalComisiones, 2));
    Print("Swaps: €", DoubleToString(totalSwaps, 2));
    Print("Ganancia Neta Final: €", DoubleToString(gananciaNetaFinal, 2));
    Print("Diferencia con objetivo: €", DoubleToString(MathAbs(gananciaNetaFinal - gananciaObjetivo), 4));
    
    // Ajuste fino si es necesario (solo si la diferencia es significativa)
    if(MathAbs(gananciaNetaFinal - gananciaObjetivo) > 0.005 && MathAbs(volumenNeto) > 0.001)
    {
        Print("?? Aplicando ajuste fino adicional...");
        
        double errorEUR = gananciaObjetivo - gananciaNetaFinal;
        double ajustePuntos = errorEUR / (MathAbs(volumenNeto) * valorPorPunto);
        
        if(volumenNeto > 0)
            precioVirtual += ajustePuntos * point;
        else
            precioVirtual -= ajustePuntos * point;
        
        precioVirtual = NormalizeDouble(precioVirtual, _Digits);
        
        // Recalcular para verificación
        plVerificacion = 0;
        for(int i = 0; i < numPosiciones; i++)
        {
            if(posiciones[i].tipo == POSITION_TYPE_BUY)
            {
                double movimiento = precioVirtual - posiciones[i].precioApertura;
                plVerificacion += (movimiento / point) * posiciones[i].volumen * valorPorPunto;
            }
            else
            {
                double movimiento = posiciones[i].precioApertura - (precioVirtual + spread);
                plVerificacion += (movimiento / point) * posiciones[i].volumen * valorPorPunto;
            }
        }
        
        double gananciaFinalAjustada = plVerificacion - totalComisiones + totalSwaps;
        Print("Precio final ajustado: ", DoubleToString(precioVirtual, _Digits));
        Print("Ganancia final después del ajuste: €", DoubleToString(gananciaFinalAjustada, 2));
    }
    
    return precioVirtual;
}

//+------------------------------------------------------------------+
//| Función auxiliar para verificar el cálculo                      |
//+------------------------------------------------------------------+
void VerificarCalculoPrecioVirtual(int indiceSecuencia, double precioVirtual)
{
    double plTotal = 0;
    double totalComisiones = 0;
    double totalSwap = 0;
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n?? VERIFICACIÓN DEL CÁLCULO DE PRECIO VIRTUAL");
    Print("Precio virtual calculado: ", DoubleToString(precioVirtual, _Digits));
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lots = PositionGetDouble(POSITION_VOLUME);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double swap = PositionGetDouble(POSITION_SWAP);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double comision = CalcularComisionPepperstone(lots);
            totalComisiones += comision;
            totalSwap += swap;
            
            double pl = 0;
            if(tipo == POSITION_TYPE_BUY)
            {
                double pips = (precioVirtual - openPrice) / _Point;
                pl = pips * lots * 10.0 / 10.0;
                Print("  BUY ", DoubleToString(lots, 2), " @ ", DoubleToString(openPrice, _Digits), 
                      " ? P/L: €", DoubleToString(pl, 2));
            }
            else
            {
                double pips = (openPrice - precioVirtual) / _Point;
                pl = pips * lots * 10.0 / 10.0;
                Print("  SELL ", DoubleToString(lots, 2), " @ ", DoubleToString(openPrice, _Digits), 
                      " ? P/L: €", DoubleToString(pl, 2));
            }
            
            plTotal += pl;
        }
    }
    
    double gananciaNeta = plTotal - totalComisiones + totalSwap;
    double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
    
    Print("P/L Total: €", DoubleToString(plTotal, 2));
    Print("Comisiones: €", DoubleToString(totalComisiones, 2));
    Print("Swap: €", DoubleToString(totalSwap, 2));
    Print("Ganancia Neta Calculada: €", DoubleToString(gananciaNeta, 2));
    Print("Ganancia Objetivo: €", DoubleToString(gananciaObjetivo, 2));
    Print("Diferencia: €", DoubleToString(gananciaNeta - gananciaObjetivo, 2));
}

//+------------------------------------------------------------------+
//| FUNCIÓN MEJORADA: MonitorearCierrePorGananciaObjetivo()         |
//| Con tolerancia ajustable para evitar cierres prematuros         |
//+------------------------------------------------------------------+
void MonitorearCierrePorGananciaObjetivo()
{
    static datetime ultimaVerificacion = 0;
    
    // Evitar verificación muy frecuente
    if(TimeCurrent() - ultimaVerificacion < 1) return;
    ultimaVerificacion = TimeCurrent();
    
    // Obtener precios actuales
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    
    // TOLERANCIA: Esperar a que el precio supere el virtual por al menos 1 punto
    double tolerancia = 1 * point; // 0.1 pip de tolerancia
    
    // Verificar cada secuencia activa
    for(int idx = 0; idx < 20; idx++)
    {
        // Solo procesar secuencias con cierre virtual activado y no marcadas para cierre
        if(!secuencias[idx].activa || !secuencias[idx].tpReubicado || secuencias[idx].tpAlcanzado)
            continue;
        
        // Evitar procesar secuencias recién activadas
        if(TimeCurrent() - secuencias[idx].ultimaVerificacionTP < 3)
            continue;
        
        // Buscar la línea del precio virtual
        string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[idx].id);
        
        // Verificar si existe la línea
        if(ObjectFind(0, nombreLinea) < 0)
            continue;
        
        double precioVirtual = ObjectGetDouble(0, nombreLinea, OBJPROP_PRICE, 0);
        
        if(precioVirtual <= 0)
            continue;
        
        // Determinar dirección neta de la secuencia
        bool posicionNetaLarga = DeterminarPosicionNeta(idx);
        bool deberCerrar = false;
        
        if(posicionNetaLarga)
        {
            // Posición LARGA - cerrar cuando BID >= precio virtual + tolerancia
            if(bid >= precioVirtual + tolerancia)
            {
                deberCerrar = true;
                Print("\n?? PRECIO VIRTUAL ALCANZADO (Posición LARGA)");
                Print("   BID actual: ", DoubleToString(bid, _Digits));
                Print("   Precio virtual: ", DoubleToString(precioVirtual, _Digits));
                Print("   Tolerancia aplicada: ", DoubleToString(tolerancia/_Point, 1), " puntos");
            }
        }
        else
        {
            // Posición CORTA - cerrar cuando ASK <= precio virtual - tolerancia
            if(ask <= precioVirtual - tolerancia)
            {
                deberCerrar = true;
                Print("\n?? PRECIO VIRTUAL ALCANZADO (Posición CORTA)");
                Print("   ASK actual: ", DoubleToString(ask, _Digits));
                Print("   Precio virtual: ", DoubleToString(precioVirtual, _Digits));
                Print("   Tolerancia aplicada: ", DoubleToString(tolerancia/_Point, 1), " puntos");
            }
        }
        
        if(deberCerrar)
        {
            Print("?? EJECUTANDO CIERRE VIRTUAL - Secuencia #", secuencias[idx].id);
            
            // Marcar ANTES de cerrar para evitar re-procesamiento
            secuencias[idx].tpAlcanzado = true;
            
            // Usar la nueva función unificada
            CerrarSecuenciaVirtual(idx);
            
            Print("? Cierre virtual completado - Secuencia #", secuencias[idx].id);
            
            // Guardar estado
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| FUNCIÓN 3: DeterminarPosicionNeta() - NUEVA                     |
//| Determina si la posición neta es larga o corta                 |
//+------------------------------------------------------------------+
bool DeterminarPosicionNeta(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return true;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double volumenBuy = 0;
    double volumenSell = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double volumen = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            if(tipo == POSITION_TYPE_BUY)
                volumenBuy += volumen;
            else
                volumenSell += volumen;
        }
    }
    
    // Retornar true si es posición neta larga (más BUY que SELL)
    return (volumenBuy >= volumenSell);
}

//+------------------------------------------------------------------+
//| FUNCIÓN AUXILIAR: Calcular ganancia actual de la secuencia      |
//+------------------------------------------------------------------+
double CalcularGananciaActualSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return 0;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double gananciaTotal = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            double profit = PositionGetDouble(POSITION_PROFIT);
            double swap = PositionGetDouble(POSITION_SWAP);
            double volumen = PositionGetDouble(POSITION_VOLUME);
            
            // Obtener comisión con método alternativo si deprecated
            double commission = 0;
            #ifdef POSITION_COMMISSION
                commission = PositionGetDouble(POSITION_COMMISSION);
            #endif
            
            // Estimar comisión de cierre
            double comisionCierre = CalcularComisionPepperstone(volumen);
            
            // Ganancia neta
            gananciaTotal += profit + swap + commission - comisionCierre;
        }
    }
    
    return gananciaTotal;
}

//+------------------------------------------------------------------+
//| FUNCIÓN AUXILIAR: Determinar dirección predominante             |
//+------------------------------------------------------------------+
bool DeterminarDireccionPredominante(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return true;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    double volumenBuy = 0;
    double volumenSell = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double volumen = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            if(tipo == POSITION_TYPE_BUY)
                volumenBuy += volumen;
            else
                volumenSell += volumen;
        }
    }
    
    return (volumenBuy >= volumenSell);
}

//+------------------------------------------------------------------+
//| FUNCIÓN 4: CerrarTodasPosicionesSecuencia() - CORREGIDA V2      |
//| NO REDECLARA trade - Agregar esta función auxiliar              |
//+------------------------------------------------------------------+
void CerrarTodasPosicionesSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int totalCerradas = 0;
    int totalErrores = 0;
    
    // Usar la variable global 'trade' que ya existe, NO redeclarar
    // trade ya está definida globalmente como CTrade trade;
    trade.SetDeviationInPoints(10);
    trade.SetTypeFilling(ORDER_FILLING_FOK);
    
    // Cerrar posiciones en orden inverso
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            if(trade.PositionClose(ticket))
            {
                totalCerradas++;
                Print("? Posición ", ticket, " cerrada");
            }
            else
            {
                totalErrores++;
                Print("? Error cerrando posición ", ticket, ": ", GetLastError());
                
                // Reintento
                Sleep(100);
                if(trade.PositionClose(ticket))
                {
                    totalCerradas++;
                    totalErrores--;
                    Print("? Posición ", ticket, " cerrada en segundo intento");
                }
            }
        }
    }
    
    if(totalCerradas > 0)
    {
        Print("RESUMEN: ", totalCerradas, " posiciones cerradas, ", totalErrores, " errores");
        
        // Marcar secuencia como cerrada
        secuencias[indiceSecuencia].tpAlcanzado = true;
        secuencias[indiceSecuencia].cerradaCompletamente = true;
        
        // Limpiar línea virtual del gráfico
        string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
        ObjectDelete(0, nombreLinea);
        ObjectDelete(0, nombreLinea + "_Label");
        
        // Cerrar la secuencia
        CerrarSecuencia(indiceSecuencia);
    }
}

//+------------------------------------------------------------------+
//| NUEVA FUNCIÓN: Cierre con máxima prioridad                      |
//| AGREGAR después de las otras funciones                          |
//+------------------------------------------------------------------+
void CerrarTodasConPrioridad(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // MÁXIMA TOLERANCIA para garantizar cierre
    trade.SetDeviationInPoints(100);
    
    // 1. Eliminar TODAS las órdenes pendientes INMEDIATAMENTE
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.OrderDelete(ticket);
            }
        }
    }
    
    // 2. Cerrar TODAS las posiciones SIMULTÁNEAMENTE
    int posicionesCerradas = 0;
    
    for(int intento = 0; intento < 3; intento++)
    {
        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    if(trade.PositionClose(ticket))
                    {
                        posicionesCerradas++;
                        Print("? Posición ", ticket, " cerrada");
                    }
                    else
                    {
                        Print("? Error cerrando ", ticket, ": ", GetLastError());
                    }
                }
            }
        }
        
        // Si todas se cerraron, salir
        if(posicionesCerradas > 0) break;
        
        Sleep(50); // Pequeña pausa entre intentos
    }
    
    // Marcar secuencia como inactiva
    secuencias[indiceSecuencia].activa = false;
    secuencias[indiceSecuencia].tpReubicado = false;
    totalSecuencias--;
    
    // Restaurar tolerancia normal
    trade.SetDeviationInPoints(10);
    
    Print("? Secuencia #", secuencias[indiceSecuencia].id, " cerrada - Total posiciones cerradas: ", posicionesCerradas);
}



//+------------------------------------------------------------------+
//| Función adicional para limpiar líneas al cerrar secuencia       |
//+------------------------------------------------------------------+
void LimpiarLineaCierreVirtual(int indiceSecuencia)
{
    string lineaId = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
    ObjectDelete(0, lineaId);
    ObjectDelete(0, lineaId + "_Label");
    ChartRedraw();
    LimpiarLineaCierreVirtual(indiceSecuencia);
}

//+------------------------------------------------------------------+
//| Función EXACTA para calcular comisión Pepperstone en EUR        |
//| Basada en tabla Excel verificada - 100% precisa                 |
//+------------------------------------------------------------------+
double CalcularComisionPepperstone(double lots)
{
    // Tabla verificada hasta 0.30 lotes (de tu Excel)
    // Los valores son EXACTOS según Pepperstone
    if(lots <= 0.01) return 0.06;
    else if(lots <= 0.02) return 0.10;
    else if(lots <= 0.03) return 0.16;
    else if(lots <= 0.04) return 0.20;
    else if(lots <= 0.05) return 0.26;
    else if(lots <= 0.06) return 0.32;
    else if(lots <= 0.07) return 0.36;
    else if(lots <= 0.08) return 0.42;
    else if(lots <= 0.09) return 0.46;
    else if(lots <= 0.10) return 0.52;
    else if(lots <= 0.11) return 0.58;
    else if(lots <= 0.12) return 0.62;
    else if(lots <= 0.13) return 0.68;
    else if(lots <= 0.14) return 0.72;
    else if(lots <= 0.15) return 0.78;
    else if(lots <= 0.16) return 0.84;
    else if(lots <= 0.17) return 0.88;
    else if(lots <= 0.18) return 0.94;
    else if(lots <= 0.19) return 0.98;
    else if(lots <= 0.20) return 1.04;
    else if(lots <= 0.21) return 1.10;
    else if(lots <= 0.22) return 1.14;
    else if(lots <= 0.23) return 1.20;
    else if(lots <= 0.24) return 1.24;
    else if(lots <= 0.25) return 1.30;
    else if(lots <= 0.26) return 1.36;
    else if(lots <= 0.27) return 1.40;
    else if(lots <= 0.28) return 1.46;
    else if(lots <= 0.29) return 1.50;
    else if(lots <= 0.30) return 1.56;
    
    // Para lotes > 0.30, aplicar el patrón observado en la tabla
    // La base es 5.20 EUR por lote, pero con redondeo especial
    
    // Valores específicos de la tabla para referencia
    else if(lots <= 0.31) return 1.62;
    else if(lots <= 0.32) return 1.66;  // Mismo que 0.31
    else if(lots <= 0.33) return 1.72;
    else if(lots <= 0.34) return 1.76;
    else if(lots <= 0.35) return 1.82;
    else if(lots <= 0.36) return 1.88;
    else if(lots <= 0.37) return 1.92;
    else if(lots <= 0.38) return 1.98;
    else if(lots <= 0.39) return 2.02;
    else if(lots <= 0.40) return 2.08;
    
    // Para lotes de 0.41 a 1.00, usar los valores de la tabla
    else if(lots <= 0.50) return 2.60;
    else if(lots <= 0.60) return 3.12;
    else if(lots <= 0.61) return 3.18;
    else if(lots <= 0.62) return 3.22;  // Según tabla
    else if(lots <= 0.63) return 3.28;
    else if(lots <= 0.64) return 3.32;
    else if(lots <= 0.65) return 3.38;
    else if(lots <= 0.70) return 3.64;
    else if(lots <= 0.80) return 4.16;
    else if(lots <= 0.90) return 4.68;
    else if(lots <= 1.00) return 5.20;
    else if(lots <= 1.01) return 5.26;  // Mismo que 1.00 según tabla
    
    // Para lotes mayores, aplicar fórmula con redondeo especial
    else
    {
        double comisionBase = lots * 5.20;
        
        // Pepperstone parece redondear a múltiplos de 0.02 EUR para comisiones grandes
        // Primero redondear a 2 decimales
        double comisionRedondeada = MathRound(comisionBase * 100) / 100;
        
        // Si el segundo decimal es impar, redondear al par superior
        int centavos = (int)(comisionRedondeada * 100);
        if(centavos % 2 == 1)
        {
            centavos++;
            comisionRedondeada = centavos / 100.0;
        }
        
        return comisionRedondeada;
    }
}


//+------------------------------------------------------------------+
//| Calcular P&L exacto para una posición                           |
//+------------------------------------------------------------------+
double CalcularPLExacto(double precioApertura, double precioCierre, 
                       ENUM_POSITION_TYPE tipo, double lotes)
{
    double pl = 0;
    
    // Para EUR/USD en cuenta EUR
    double valorPip = 10.0; // 10 EUR por pip por lote estándar
    
    if(tipo == POSITION_TYPE_BUY)
    {
        double pips = (precioCierre - precioApertura) / _Point / 10.0;
        pl = pips * lotes * valorPip;
    }
    else // SELL
    {
        double pips = (precioApertura - precioCierre) / _Point / 10.0;
        pl = pips * lotes * valorPip;
    }
    
    return NormalizeDouble(pl, 2);
}

//+------------------------------------------------------------------+
//| Función de diagnóstico para verificar cálculos                   |
//+------------------------------------------------------------------+
void DiagnosticarSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n========== DIAGNÓSTICO SECUENCIA #", secuencias[indiceSecuencia].id, " ==========");
    
    // Obtener spread actual
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = ask - bid;
    
    // Recolectar todas las posiciones
    double totalComisiones = 0;
    double totalPL = 0;
    double totalPLConSpread = 0;
    int numPosiciones = 0;
    
    Print("POSICIONES ABIERTAS:");
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lotes = PositionGetDouble(POSITION_VOLUME);
            double precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            double pl = PositionGetDouble(POSITION_PROFIT);
            int tipo = (int)PositionGetInteger(POSITION_TYPE);
            string tipoStr = (tipo == POSITION_TYPE_BUY) ? "BUY" : "SELL";
            
            double comision = CalcularComisionPepperstone(lotes);
            totalComisiones += comision;
            totalPL += pl;
            
            // Calcular P&L proyectado al TP considerando spread
            double plProyectado = CalcularPLConSpread(precioApertura, tp, tipo, lotes, spread);
            totalPLConSpread += plProyectado;
            
            Print("  #", ticket, " ", tipoStr, " ", DoubleToString(lotes, 2), 
                  " @ ", DoubleToString(precioApertura, _Digits),
                  " TP=", DoubleToString(tp, _Digits),
                  " P/L actual=", DoubleToString(pl, 2),
                  " P/L al TP=", DoubleToString(plProyectado, 2),
                  " Comisión=", DoubleToString(comision, 2));
            
            numPosiciones++;
        }
    }
    
    double gananciaActualNeta = totalPL - totalComisiones;
    double gananciaProyectadaNeta = totalPLConSpread - totalComisiones;
    
    Print("\nRESUMEN:");
    Print("  Posiciones: ", numPosiciones);
    Print("  Spread actual: ", (int)(spread/_Point), " puntos");
    Print("  P/L Bruto actual: ", DoubleToString(totalPL, 2), " EUR");
    Print("  P/L Proyectado al TP: ", DoubleToString(totalPLConSpread, 2), " EUR");
    Print("  Comisiones totales: ", DoubleToString(totalComisiones, 2), " EUR");
    Print("  P/L Neto actual: ", DoubleToString(gananciaActualNeta, 2), " EUR");
    Print("  P/L Neto proyectado: ", DoubleToString(gananciaProyectadaNeta, 2), " EUR");
    Print("  Ganancia objetivo: ", DoubleToString(StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)), 2), " EUR");
    
    // Advertencias
    if(gananciaProyectadaNeta < StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)))
    {
        Print("\n?? ADVERTENCIA: La ganancia proyectada es menor que el objetivo!");
        Print("   Diferencia: ", DoubleToString(gananciaProyectadaNeta - StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)), 2), " EUR");
    }
    
    Print("=====================================\n");
}

//+------------------------------------------------------------------+
//| Función para limpiar secuencias fantasma silenciosamente         |
//+------------------------------------------------------------------+
void LimpiarSecuenciasFantasma()
{
    int contadorLimpiadas = 0;
    
    // Primero, recalcular el total para asegurar que es correcto
    RecalcularTotalSecuencias();
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (órdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar órdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos órdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // Últimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("?? Limpieza automática: Secuencia #", secuencias[i].id, " sin actividad detectada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                    contadorLimpiadas++;
                }
            }
        }
    }
    
    if(contadorLimpiadas > 0)
    {
        Print("?? Limpiadas ", contadorLimpiadas, " secuencias fantasma. Total activas ahora: ", totalSecuencias);
        GuardarEstadoSecuencias();
    }
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Inicializar con ID 1, pero luego comprobar si hay que restaurar el contador
    proximoIDSecuencia = 1;
    
    // Verificar si el trading está permitido
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
    {
        Alert("El trading automático no está permitido en el terminal");
        return INIT_FAILED;
    }
    
    if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT))
    {
        Alert("El trading con EAs no está permitido en esta cuenta");
        return INIT_FAILED;
    }
    
    trade.SetDeviationInPoints(10);
    
    // Inicializar la interfaz
    CrearInterfaz();
    
    // Inicializar array de secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        ResetearSecuencia(i);
    }
    
    // Nueva función: Restaurar las órdenes pendientes perdidas en cambios de timeframe
    RecuperarOrdenesPendientes();
    
    // Habilitar eventos de gráfico para botones (ya están habilitados por defecto)
    ChartRedraw(); // Aseguramos que el gráfico se redibuja para mostrar la interfaz
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Guardar valores de los controles antes de destruirlos
    GuardarValores();
    
    // Si la razón de deinicialización es cambio de temporalidad o cierre del gráfico,
    // guardar el estado y el contador de secuencias
    if(reason == REASON_CHARTCHANGE || reason == REASON_CHARTCLOSE)
    {
        // No eliminar los objetos, solo guardar el estado
        Print("Cambio de temporalidad detectado - Preservando objetos y contador de secuencias");
        
        // Guardar estado e ID de próxima secuencia para mantener numeración
        GuardarEstadoSecuenciasConID();
        return;
    }
    
    // Si se trata de eliminación del EA, limpiar todas las secuencias activas
    // Y no preservar el contador (para que se reinicie la próxima vez)
    if(reason == REASON_REMOVE)
    {
        Print("Eliminando EA - Cerrando todas las secuencias activas");
        CerrarTodasLasSecuencias();
        
        // Borrar la variable global que guarda el próximo ID para forzar reinicio
        GlobalVariableDel("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
    }
    
    // Para otras razones, eliminar solo los objetos del EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    Print("EA deinicializado - Objetos del EA eliminados");
}

//+------------------------------------------------------------------+
//| Guardar estado de secuencias incluyendo el próximo ID            |
//+------------------------------------------------------------------+
void GuardarEstadoSecuenciasConID()
{
    // Guardar el número total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar el próximo ID de secuencia para mantener la numeración entre cambios de timeframe
    GlobalVariableSet("EA_PROXIMO_ID_SECUENCIA_" + Symbol(), proximoIDSecuencia);
    
    // Guardar información detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0);
            GlobalVariableSet(baseKey + "ULTIMAS_POS", secuencias[i].ultimasPosicionesConsideradas);
            
            Print("Guardado estado de secuencia #", secuencias[i].id, " para persistencia entre timeframes");
        }
    }
}

//+------------------------------------------------------------------+
//| Guardar estado básico de secuencias sin ID                       |
//+------------------------------------------------------------------+
void GuardarEstadoSecuencias()
{
    // Guardar el número total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar información detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0); // AÑADIR ESTA LÍNEA
            GlobalVariableSet(baseKey + "ULTIMAS_POS", secuencias[i].ultimasPosicionesConsideradas);
        }
    }
}

//+------------------------------------------------------------------+
//| Restaurar estado de las secuencias                               |
//+------------------------------------------------------------------+
void RestaurarEstadoSecuencias()
{
    // Verificar si hay secuencias guardadas
    if(!GlobalVariableCheck("EA_TOTAL_SECUENCIAS_" + Symbol()))
        return;
        
    int totalSecuenciasGuardadas = (int)GlobalVariableGet("EA_TOTAL_SECUENCIAS_" + Symbol());
    
    // Restaurar el próximo ID de secuencia solo si fue un cambio de temporalidad
    // (Comprobamos si la variable existe y si hay secuencias que restaurar)
    if(GlobalVariableCheck("EA_PROXIMO_ID_SECUENCIA_" + Symbol()) && totalSecuenciasGuardadas > 0)
    {
        proximoIDSecuencia = (int)GlobalVariableGet("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
        Print("Restaurado contador de IDs de secuencia desde cambio de temporalidad: ", proximoIDSecuencia);
    }
    
    if(totalSecuenciasGuardadas <= 0)
        return;
        
    Print("Restaurando ", totalSecuenciasGuardadas, " secuencias guardadas");
    
    // Restaurar información de cada secuencia guardada
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        // Verificar si esta secuencia estaba activa
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            secuencias[i].id = (int)GlobalVariableGet(baseKey + "ID");
            secuencias[i].activa = true;
            secuencias[i].precioEntrada1 = GlobalVariableGet(baseKey + "PRECIO_E1");
            secuencias[i].precioEntrada2 = GlobalVariableGet(baseKey + "PRECIO_E2");
            secuencias[i].tp1Precio = GlobalVariableGet(baseKey + "TP1");
            secuencias[i].tp2Precio = GlobalVariableGet(baseKey + "TP2");
            secuencias[i].secuenciaActual = (int)GlobalVariableGet(baseKey + "SEQ_ACTUAL");
            secuencias[i].esModoCompra = (GlobalVariableGet(baseKey + "ES_COMPRA") == 1);
            secuencias[i].ticketEntrada1 = (ulong)GlobalVariableGet(baseKey + "TICKET_E1");
            secuencias[i].ticketEntrada2 = (ulong)GlobalVariableGet(baseKey + "TICKET_E2");
            secuencias[i].entradaPendienteActiva = (GlobalVariableGet(baseKey + "PENDIENTE_ACTIVA") == 1);
            secuencias[i].cerradaManualmente = GlobalVariableCheck(baseKey + "CERRADA_MANUAL") ? 
                                              (GlobalVariableGet(baseKey + "CERRADA_MANUAL") == 1) : false;
            secuencias[i].tiempoInicio = TimeCurrent();
            secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificación inmediata
            secuencias[i].ultimaVerificacionPendientes = 0; // Inicializar nueva variable
            secuencias[i].sinOrdenesPendientesDetectado = false; // Inicializar nueva variable
            secuencias[i].tpReubicado = GlobalVariableCheck(baseKey + "TP_REUBICADO") ? 
                           (GlobalVariableGet(baseKey + "TP_REUBICADO") == 1) : false;
            secuencias[i].ultimasPosicionesConsideradas = GlobalVariableCheck(baseKey + "ULTIMAS_POS") ? 
                                               (int)GlobalVariableGet(baseKey + "ULTIMAS_POS") : 0;
            // Actualizar proximoIDSecuencia para asegurar que nuevas secuencias tengan IDs únicos
            if(secuencias[i].id >= proximoIDSecuencia)
            {
                proximoIDSecuencia = secuencias[i].id + 1;
                Print("Ajustando ID de próxima secuencia a: ", proximoIDSecuencia);
            }
            
            totalSecuencias++;
            
            Print("Restaurada secuencia #", secuencias[i].id, " - Modo: ", 
                  secuencias[i].esModoCompra ? "COMPRA" : "VENTA", 
                  ", Entrada2 pendiente: ", secuencias[i].entradaPendienteActiva ? "Sí" : "No",
                  ", Cerrada manualmente: ", secuencias[i].cerradaManualmente ? "Sí" : "No");
        }
    }
    
    for(int i = 0; i < 20; i++)
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            // Restauración existente...
            secuencias[i].tpReubicado = GlobalVariableCheck(baseKey + "TP_REUBICADO") ? 
                                       (GlobalVariableGet(baseKey + "TP_REUBICADO") == 1) : false;
        }
    }
    
}

//+------------------------------------------------------------------+
//| Guardar valores de los controles                                 |
//+------------------------------------------------------------------+
void GuardarValores()
{
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
        LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
        TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
        PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
        TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumEntrada = 0;
        else
            NumEntrada = (int)StringToInteger(texto);
    }
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
        MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumCerrar = 0;
        else
            NumCerrar = (int)StringToInteger(texto);
    }
        
    // Guardar estos valores en variables globales para persistencia entre timeframes
    GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
    GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
    GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
    GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
    GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
    GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
    GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
}

//+------------------------------------------------------------------+
//| Restaurar valores guardados                                      |
//+------------------------------------------------------------------+
void RestaurarValores()
{
    // Solo restaurar valores si los controles no tienen valores ya
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            // Intentar recuperar desde variables globales solo si el campo está vacío
            if(GlobalVariableCheck("EA_LOTAJE_" + Symbol()))
                LotajeInicial = GlobalVariableGet("EA_LOTAJE_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT, DoubleToString(LotajeInicial, 2));
        }
        else
        {
            // Si hay texto ya en el campo, usarlo para actualizar la variable
            LotajeInicial = StringToDouble(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP1_" + Symbol()))
                TP1Puntos = (int)GlobalVariableGet("EA_TP1_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT, IntegerToString(TP1Puntos));
        }
        else
        {
            TP1Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_PIPS_E2_" + Symbol()))
                PipsEntrada2 = (int)GlobalVariableGet("EA_PIPS_E2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT, IntegerToString(PipsEntrada2));
        }
        else
        {
            PipsEntrada2 = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP2_" + Symbol()))
                TP2Puntos = (int)GlobalVariableGet("EA_TP2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT, IntegerToString(TP2Puntos));
        }
        else
        {
            TP2Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_ENTRADA_" + Symbol()))
            {
                NumEntrada = (int)GlobalVariableGet("EA_NUM_ENTRADA_" + Symbol());
                // Si es 0, mostrar campo vacío
                if(NumEntrada == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, IntegerToString(NumEntrada));
            }
            else
            {
                // Si no hay valor guardado, dejar vacío
                ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumEntrada = (int)StringToInteger(textoActual);
        }
    }
    
    // Restaurar valor para Minima G.
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            if(GlobalVariableCheck("EA_MINIMA_G_" + Symbol()))
                MinimaG = GlobalVariableGet("EA_MINIMA_G_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT, DoubleToString(MinimaG, 2));
        }
        else
        {
            MinimaG = StringToDouble(textoActual);
        }
    }
    
    // Restaurar valor para # Cerrar (NUEVO)
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_CERRAR_" + Symbol()))
            {
                NumCerrar = (int)GlobalVariableGet("EA_NUM_CERRAR_" + Symbol());
                // Si es 0, mostrar campo vacío
                if(NumCerrar == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, IntegerToString(NumCerrar));
            }
            else
            {
                // Si no hay valor guardado, dejar vacío
                ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumCerrar = (int)StringToInteger(textoActual);
        }
    }
}

//+------------------------------------------------------------------+
//| Resetear una secuencia                                           |
//+------------------------------------------------------------------+
void ResetearSecuencia(int indice)
{
    secuencias[indice].activa = false;
    secuencias[indice].numOrdenes = 0;
    secuencias[indice].tpAlcanzado = false;
    secuencias[indice].ultimaVerificacionTP = 0;
    secuencias[indice].cerradaCompletamente = false;
    secuencias[indice].intentosCierre = 0;
    secuencias[indice].ultimoCierreIntentado = 0;
    secuencias[indice].esModoCompra = true;
    secuencias[indice].ticketEntrada1 = 0;
    secuencias[indice].ticketEntrada2 = 0;
    secuencias[indice].entradaPendienteActiva = false;
    secuencias[indice].ultimaRecreacionPendiente = 0;
    secuencias[indice].cerradaManualmente = false;
    secuencias[indice].ultimaVerificacionPendientes = 0; // Nueva variable
    secuencias[indice].sinOrdenesPendientesDetectado = false; // Nueva variable
    secuencias[indice].tpReubicado = false;
    secuencias[indice].ultimasPosicionesConsideradas = 0;
    
    // Limpiar array de órdenes
    for(int i = 0; i < 10; i++)
    {
        secuencias[indice].ultimasOrdenes[i] = 0;
    }
}

//+------------------------------------------------------------------+
//| Verificar existencia de una orden pendiente                      |
//+------------------------------------------------------------------+
bool VerificarExistenciaOrdenPendiente(ulong ticket)
{
    if(ticket == 0) return false;
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ordenTicket = OrderGetTicket(i);
        if(ordenTicket == ticket && OrderSelect(ordenTicket))
        {
            return true;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Versión mejorada de recrear orden entrada #2 para evitar duplicados|
//+------------------------------------------------------------------+
bool RecrearOrdenEntrada2(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) 
        return false;
    
    // Si la orden fue cerrada manualmente, no la recreamos
    if(secuencias[indice].cerradaManualmente)
    {
        Print("?? No se recrea orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id, " porque fue cerrada manualmente");
        return false;
    }
    
    // Verificar si ya existen órdenes pendientes para esta secuencia y eliminar duplicados
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    // Si hay múltiples órdenes pendientes, limpiar las duplicadas
    if(tieneMultiples)
    {
        Print("?? Detectadas órdenes pendientes duplicadas para secuencia #", secuencias[indice].id, " - Limpiando");
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    // Verificar si la orden pendiente de Entrada #2 específica existe
    if(VerificarExistenciaOrdenPendiente(secuencias[indice].ticketEntrada2))
    {
        secuencias[indice].entradaPendienteActiva = true;
        return true; // La orden ya existe, no necesita recreación
    }
    
    // Si ya hay alguna orden pendiente de esta secuencia pero no es la ENT2 específica,
    // vamos a verificar si hay otra orden ENT2 con otro ticket
    if(tieneOrdenPendiente)
    {
        string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT2";
        
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                // Encontramos una orden ENT2 diferente a la que teníamos registrada
                secuencias[indice].ticketEntrada2 = ticket;
                secuencias[indice].entradaPendienteActiva = true;
                Print("?? Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticket);
                return true;
            }
        }
    }
    // Evitar recreaciones demasiado frecuentes (máximo una vez cada 5 segundos)
    if(TimeCurrent() - secuencias[indice].ultimaRecreacionPendiente < 5)
        return false;
    
    secuencias[indice].ultimaRecreacionPendiente = TimeCurrent();
    
    // Solo recrear si estamos en la fase inicial (secuenciaActual <= 2)
    // y la entrada pendiente está marcada como activa
    if(secuencias[indice].secuenciaActual <= 2 && secuencias[indice].entradaPendienteActiva)
    {
        string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_";
        string comentarioEnt2 = comentarioBase + "ENT2";
        double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT)) * 2;
        ulong resultTicket = 0;
        
        Print("?? Recreando orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id);
        
        if(secuencias[indice].esModoCompra)
        {
            // ENTRADA #2: SELL STOP
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        else
        {
            // ENTRADA #2: BUY STOP
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        
        if(resultTicket > 0)
        {
            secuencias[indice].ticketEntrada2 = resultTicket;
            RegistrarOrden(indice, resultTicket, comentarioEnt2);
            Print("? Orden pendiente ENTRADA #2 recreada exitosamente con ticket #", resultTicket);
            return true;
        }
        else
        {
            Print("? Error al recrear orden pendiente ENTRADA #2: ", GetLastError());
            return false;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Función para recuperar órdenes pendientes perdidas - mejorada    |
//+------------------------------------------------------------------+
void RecuperarOrdenesPendientes()
{
    // Primero limpiar posibles duplicados en todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
        {
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            if(tieneMultiples)
            {
                Print("?? Limpiando órdenes duplicadas para secuencia #", secuencias[i].id, " durante recuperación");
                EliminarOrdenesPendientesDuplicadas(i);
            }
        }
    }
    
    // Ahora recrear órdenes pendientes si es necesario
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva)
        {
            RecrearOrdenEntrada2(i);
        }
    }
}

//+------------------------------------------------------------------+
//| Función modificada para verificar periódicamente órdenes pendientes |
//+------------------------------------------------------------------+
void VerificarOrdenesPendientes()
{
    // Limitar la frecuencia de verificación (cada 5 segundos)
    datetime tiempoActual = TimeCurrent();
    if(tiempoActual - ultimaVerificacionPendientes < 5)
        return;
        
    ultimaVerificacionPendientes = tiempoActual;
    
    // Recorrer todas las secuencias activas
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
        {
            // Verificar si hay órdenes pendientes duplicadas
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            // Si hay múltiples órdenes pendientes, limpiar las duplicadas
            if(tieneMultiples)
            {
                Print("?? Detectadas órdenes pendientes duplicadas para secuencia #", secuencias[i].id, " - Limpiando");
                EliminarOrdenesPendientesDuplicadas(i);
            }
            
            // Verificar si la orden pendiente Entrada #2 sigue existiendo
            if(!VerificarExistenciaOrdenPendiente(secuencias[i].ticketEntrada2) && !tieneOrdenPendiente)
            {
                // Si no existe, intentar recrearla
                Print("?? Orden pendiente ENTRADA #2 no encontrada para secuencia #", secuencias[i].id, " - Intentando recrear");
                RecrearOrdenEntrada2(i);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Función optimizada para cerrar rápidamente sin órdenes pendientes|
//+------------------------------------------------------------------+
void VerificarCierrePorFaltaDePendientes()
{
    datetime tiempoActual = TimeCurrent();
    
    for(int i = 0; i < 20; i++)
    {
        // Solo procesar secuencias activas que no están ya marcadas para cierre
        if(!secuencias[i].activa || secuencias[i].tpAlcanzado) 
            continue;
            
        // Verificar si hay posiciones abiertas para esta secuencia
        bool tienePositionesAbiertas = false;
        string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
        int numPosiciones = 0;
        
        for(int p = 0; p < PositionsTotal(); p++)
        {
            ulong ticket = PositionGetTicket(p);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                tienePositionesAbiertas = true;
                numPosiciones++;
            }
        }
        
        // Si no tiene posiciones abiertas, no hay nada que hacer
        if(!tienePositionesAbiertas)
            continue;
        
        // Verificar si hay órdenes pendientes para esta secuencia
        bool tieneMultiples = false;
        bool tienePendientes = TieneOrdenesPendientes(i, tieneMultiples);
        
        // Si hay múltiples órdenes pendientes, limpiar duplicados primero
        if(tieneMultiples)
        {
            Print("?? Detectadas órdenes duplicadas para secuencia #", secuencias[i].id);
            EliminarOrdenesPendientesDuplicadas(i);
            tienePendientes = true;
        }
        
        // Si hay posiciones pero NO hay órdenes pendientes
        if(!tienePendientes && tienePositionesAbiertas)
        {
            // Verificar si hubo una activación MUY reciente (15 segundos)
            bool activacionMuyReciente = false;
            datetime startTime = TimeCurrent() - 15;
            
            if(HistorySelect(startTime, TimeCurrent()))
            {
                for(int h = 0; h < HistoryDealsTotal(); h++)
                {
                    ulong dealTicket = HistoryDealGetTicket(h);
                    if(!HistoryDealSelect(dealTicket)) continue;
                    
                    string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                        {
                            activacionMuyReciente = true;
                            break;
                        }
                    }
                }
            }
            
            // Si hubo activación muy reciente, dar una oportunidad más
            if(activacionMuyReciente)
            {
                Print("? Activación muy reciente en secuencia #", secuencias[i].id, " - Esperando...");
                continue;
            }
            
            // CIERRE INMEDIATO sin más demoras
            Print("?? ALERTA CRÍTICA: Secuencia #", secuencias[i].id, 
                  " con ", numPosiciones, " posiciones SIN órdenes pendientes - CIERRE INMEDIATO");
            
            // Marcar para cierre inmediato
            secuencias[i].tpAlcanzado = true;
            secuencias[i].ultimoCierreIntentado = TimeCurrent();
            
            // Cierre agresivo inmediato
            CerrarSecuenciaVirtual(i, true);
            
            // Si no se cerró completamente en el primer intento, forzar
            if(!secuencias[i].cerradaCompletamente)
            {
                // Segundo intento inmediato
                Sleep(50);
                CerrarSecuenciaVirtual(i, true);
            }
            
            // Marcar como cerrada aunque queden posiciones (se cerrarán en OnTick)
            secuencias[i].activa = false;
            totalSecuencias--;
            
            Print("? Secuencia #", secuencias[i].id, " marcada para cierre por seguridad");
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| Crear panel principal de la interfaz                             |
//+------------------------------------------------------------------+
void CrearPanelPrincipal(int x, int y, int ancho, int alto)
{
    string fullId = EA_OBJ_PREFIX + panelPrincipalID;
    
    // Crear panel de fondo
    if(ObjectFind(0, fullId) < 0) {
        ObjectCreate(0, fullId, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    }
    
    // Configurar propiedades
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, fullId, OBJPROP_WIDTH, 1);
    ObjectSetInteger(0, fullId, OBJPROP_BACK, false);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_SELECTED, false);
    ObjectSetInteger(0, fullId, OBJPROP_HIDDEN, true);
    ObjectSetInteger(0, fullId, OBJPROP_ZORDER, 0);
}

//+------------------------------------------------------------------+
//| Crear interfaz gráfica                                           |
//+------------------------------------------------------------------+
void CrearInterfaz()
{
    // Comprobar si la interfaz ya existe antes de crearla de nuevo
    if(ObjectFind(0, EA_OBJ_PREFIX + botonCompraID) >= 0 && 
       ObjectFind(0, EA_OBJ_PREFIX + botonVentaID) >= 0) {
        Print("Interfaz ya existe, omitiendo creación");
        interfazCreada = true;
        RestaurarValores();
        
        // Nuevo: Restaurar estado de secuencias si existen
        RestaurarEstadoSecuencias();
        return;
    }
    
    // No eliminar todos los objetos, sólo los pertenecientes al EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    
    // Definir dimensiones del panel y componentes
    int x = 20;
    int y = 20;
    int anchoBotones = 120;
    int altoBoton = 30;
    int anchoPanel = anchoBotones * 2 + 20; // Reducido el espaciado
    int altoPanel = 320; // Aumentado para incluir el nuevo campo # Cerrar
    int espaciado = 10;
    int margenX = 10; // Reducido el margen
    int margenY = 10;
    
    // Crear panel principal
    CrearPanelPrincipal(x, y, anchoPanel, altoPanel);
    
    // Ajustar posiciones para estar dentro del panel
    x += margenX;
    y += margenY;
    
    // Crear controles dentro del panel
    // CAMBIO 1: Botones con posiciones intercambiadas
    CrearBoton(botonVentaID, "VENTA", x, y, anchoBotones, altoBoton, clrRed); // VENTA a la izquierda
    CrearBoton(botonCompraID, "COMPRA", x + anchoBotones + espaciado - 10, y, anchoBotones, altoBoton, clrGreen); // COMPRA a la derecha
    y += altoBoton + espaciado;

    // CAMBIO 2: Campo "Lote inicial" (antes "Lote entrada #1")
    CrearCampoEdicionEstilizado(editLotajeID, "Lote inicial", x, y, anchoBotones * 2, altoBoton, DoubleToString(LotajeInicial, 2));
    y += altoBoton + espaciado;

    // CAMBIO 3 y 4: Campos TP E1 y TP E2 juntos
    CrearCampoEdicionEstilizado(editTP1ID, "TP E1", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP1Puntos));
    y += altoBoton + espaciado;
    
    CrearCampoEdicionEstilizado(editTP2ID, "TP E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP2Puntos));
    y += altoBoton + espaciado;
    
    // CAMBIO 5: Campo "Dist. E1/E2" (antes "Entrada #2")
    CrearCampoEdicionEstilizado(editPipsEntrada2ID, "Dist. E1/E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(PipsEntrada2));
    y += altoBoton + espaciado;
    
    // CAMBIO 6: Campo "Ganancia M." (antes "Minima G.")
    CrearCampoEdicionEstilizado(editMinimaGID, "Ganancia M.", x, y, anchoBotones * 2, altoBoton, DoubleToString(MinimaG, 2));
    y += altoBoton + espaciado;
    
    // CAMBIO 7: Campo "# Reubicar" (antes "No. Entrada")
    CrearCampoEdicionEstilizado(editNumEntradaID, "# Reubicar", x, y, anchoBotones * 2, altoBoton, NumEntrada == 0 ? "" : IntegerToString(NumEntrada));
    y += altoBoton + espaciado;
    
    // CAMBIO 8: Nuevo campo "# Cerrar"
    CrearCampoEdicionEstilizado(editNumCerrarID, "# Cerrar", x, y, anchoBotones * 2, altoBoton, NumCerrar == 0 ? "" : IntegerToString(NumCerrar));
    
    // Restaurar valores después de crear los objetos
    RestaurarValores();
    
    // Nuevo: Restaurar estado de secuencias si existen
    RestaurarEstadoSecuencias();
    
    interfazCreada = true;
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Crear campos de edición                                          |
//+------------------------------------------------------------------+
void CrearCampoEdicion(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 3);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrBlack);

    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_LEFT);
}
//+------------------------------------------------------------------+
//| Crear campos de edición estilizados (fondo negro, texto claro)   |
//+------------------------------------------------------------------+
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    // Crear etiqueta
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 5);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, labelId, OBJPROP_FONTSIZE, 8);
    ObjectSetInteger(0, labelId, OBJPROP_SELECTABLE, false); // No seleccionable
    
    // Crear campo de edición
    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho - 100);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_CENTER);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrRed);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_READONLY, false);   // Asegurar que se pueda editar
}

//+------------------------------------------------------------------+
//| Crear botones                                                    |
//+------------------------------------------------------------------+
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor)
{
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, fullId, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, texto);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_STATE, false);
}

//+------------------------------------------------------------------+
//| Registrar orden en secuencia                                     |
//+------------------------------------------------------------------+
void RegistrarOrden(int indice, ulong ticket, string comentario="")
{
    if(indice < 0 || indice >= 10 || !secuencias[indice].activa) return;
    
    // Si el array está lleno, desplazar hacia abajo
    if(secuencias[indice].numOrdenes >= 10)
    {
        for(int i = 0; i < 9; i++)
        {
            secuencias[indice].ultimasOrdenes[i] = secuencias[indice].ultimasOrdenes[i+1];
        }
        secuencias[indice].ultimasOrdenes[9] = ticket;
    }
    else
    {
        secuencias[indice].ultimasOrdenes[secuencias[indice].numOrdenes] = ticket;
        secuencias[indice].numOrdenes++;
    }
    
    // Guardar los tickets de entrada 1 y 2 específicamente
    if(comentario != "")
    {
        if(StringFind(comentario, "ENT1") >= 0 || 
           StringFind(PositionGetString(POSITION_COMMENT), "ENT1") >= 0 ||
           StringFind(OrderGetString(ORDER_COMMENT), "ENT1") >= 0)
        {
            secuencias[indice].ticketEntrada1 = ticket;
            Print("?? Registrada ENTRADA #1 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
        else if(StringFind(comentario, "ENT2") >= 0 || 
                StringFind(PositionGetString(POSITION_COMMENT), "ENT2") >= 0 ||
                StringFind(OrderGetString(ORDER_COMMENT), "ENT2") >= 0)
        {
            secuencias[indice].ticketEntrada2 = ticket;
            secuencias[indice].entradaPendienteActiva = true; // Marcar que hay una entrada pendiente activa
            Print("?? Registrada ENTRADA #2 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
    }
    
    Print("Orden #", ticket, " registrada en secuencia #", secuencias[indice].id);
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de compra                                      |
//+------------------------------------------------------------------+
void IniciarSecuenciaCompra()
{
    IniciarSecuencia(true); // true = modo compra
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de venta                                       |
//+------------------------------------------------------------------+
void IniciarSecuenciaVenta()
{
    IniciarSecuencia(false); // false = modo venta
}

//+------------------------------------------------------------------+
//| Cerrar todas las secuencias                                      |
//+------------------------------------------------------------------+
void CerrarTodasLasSecuencias()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tamaño del array
    {
        if(secuencias[i].activa)
        {
            Print("?? Iniciando cierre de secuencia #", secuencias[i].id);
            CerrarSecuencia(i);
            Sleep(200); // Pausa entre cierres de secuencias
        }
    }
}

//+------------------------------------------------------------------+
//| FUNCIÓN UNIFICADA: CerrarSecuenciaVirtual()                     |
//| Reemplaza ambas funciones y garantiza cierre preciso            |
//+------------------------------------------------------------------+
void CerrarSecuenciaVirtual(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // Obtener precio virtual objetivo
    string nombreLinea = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
    double precioVirtual = 0;
    
    if(ObjectFind(0, nombreLinea) >= 0)
    {
        precioVirtual = ObjectGetDouble(0, nombreLinea, OBJPROP_PRICE, 0);
    }
    
    Print("\n=== INICIANDO CIERRE VIRTUAL ===");
    Print("Secuencia #", secuencias[indiceSecuencia].id);
    Print("Precio Virtual Objetivo: ", DoubleToString(precioVirtual, _Digits));
    
    // PASO 1: Eliminar todas las órdenes pendientes INMEDIATAMENTE
    int ordenesPendientesEliminadas = 0;
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            if(trade.OrderDelete(ticket))
            {
                ordenesPendientesEliminadas++;
                Print("✓ Orden pendiente #", ticket, " eliminada");
            }
        }
    }
    
    // PASO 2: Configurar para cierre preciso
    // Usar slippage mínimo para máxima precisión
    trade.SetDeviationInPoints(2); // Solo 2 puntos de desviación (0.2 pips)
    trade.SetTypeFilling(ORDER_FILLING_IOC); // Immediate or Cancel para ejecución rápida
    
    // PASO 3: Obtener precios actuales para verificación
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double spread = ask - bid;
    
    // PASO 4: Cerrar posiciones con verificación de precio
    int posicionesCerradas = 0;
    int intentosFallidos = 0;
    double gananciaRealTotal = 0;
    double comisionTotal = 0;
    
    // Array para almacenar posiciones a cerrar
    struct PosicionInfo {
        ulong ticket;
        double volumen;
        double precioApertura;
        ENUM_POSITION_TYPE tipo;
        double comision;
    };
    
    PosicionInfo posiciones[];
    int numPosiciones = 0;
    
    // Recolectar información de posiciones
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            ArrayResize(posiciones, numPosiciones + 1);
            posiciones[numPosiciones].ticket = ticket;
            posiciones[numPosiciones].volumen = PositionGetDouble(POSITION_VOLUME);
            posiciones[numPosiciones].precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            posiciones[numPosiciones].tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            posiciones[numPosiciones].comision = CalcularComisionPepperstone(posiciones[numPosiciones].volumen);
            numPosiciones++;
        }
    }
    
    // PASO 5: Cerrar posiciones con múltiples intentos si es necesario
    for(int intento = 1; intento <= 3 && posicionesCerradas < numPosiciones; intento++)
    {
        Print("Intento de cierre #", intento);
        
        // Ajustar slippage progresivamente si es necesario
        if(intento == 2) trade.SetDeviationInPoints(5);  // 0.5 pips
        if(intento == 3) trade.SetDeviationInPoints(10); // 1 pip
        
        for(int i = 0; i < numPosiciones; i++)
        {
            if(!PositionSelectByTicket(posiciones[i].ticket)) 
            {
                posicionesCerradas++; // Ya fue cerrada
                continue;
            }
            
            // Verificar precio actual antes de cerrar
            MqlTick tick;
            if(!SymbolInfoTick(_Symbol, tick)) continue;
            
            double precioCierre = 0;
            if(posiciones[i].tipo == POSITION_TYPE_BUY)
                precioCierre = tick.bid; // BUY cierra al BID
            else
                precioCierre = tick.ask; // SELL cierra al ASK
            
            // Calcular ganancia esperada si cerramos ahora
            double gananciaEsperada = 0;
            if(posiciones[i].tipo == POSITION_TYPE_BUY)
            {
                gananciaEsperada = (precioCierre - posiciones[i].precioApertura) / _Point * posiciones[i].volumen;
            }
            else
            {
                gananciaEsperada = (posiciones[i].precioApertura - precioCierre) / _Point * posiciones[i].volumen;
            }
            
            Print("Cerrando ", (posiciones[i].tipo == POSITION_TYPE_BUY ? "BUY" : "SELL"), 
                  " ", DoubleToString(posiciones[i].volumen, 2),
                  " @ ", DoubleToString(precioCierre, _Digits),
                  " | P&L esperado: €", DoubleToString(gananciaEsperada, 2));
            
            // Intentar cerrar
            if(trade.PositionClose(posiciones[i].ticket))
            {
                posicionesCerradas++;
                gananciaRealTotal += gananciaEsperada;
                comisionTotal += posiciones[i].comision;
                Print("✓ Posición #", posiciones[i].ticket, " cerrada exitosamente");
            }
            else
            {
                intentosFallidos++;
                Print("✗ Error cerrando posición #", posiciones[i].ticket, ": ", GetLastError());
                Sleep(10); // Pequeña pausa antes de reintentar
            }
        }
        
        if(posicionesCerradas >= numPosiciones) break;
        
        Sleep(50); // Pausa entre intentos
    }
    
    // PASO 6: Verificación final y reporte
    double gananciaNetaReal = gananciaRealTotal - comisionTotal;
    double gananciaObjetivo = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
    
    Print("\n=== RESUMEN DE CIERRE VIRTUAL ===");
    Print("Posiciones cerradas: ", posicionesCerradas, "/", numPosiciones);
    Print("Órdenes pendientes eliminadas: ", ordenesPendientesEliminadas);
    Print("Intentos fallidos: ", intentosFallidos);
    Print("P&L Bruto Real: €", DoubleToString(gananciaRealTotal, 2));
    Print("Comisiones: €", DoubleToString(comisionTotal, 2));
    Print("Ganancia Neta Real: €", DoubleToString(gananciaNetaReal, 2));
    Print("Ganancia Objetivo: €", DoubleToString(gananciaObjetivo, 2));
    Print("Diferencia: €", DoubleToString(gananciaNetaReal - gananciaObjetivo, 2));
    
    // PASO 7: Limpiar y resetear
    // Eliminar línea virtual del gráfico
    ObjectDelete(0, nombreLinea);
    ObjectDelete(0, nombreLinea + "_Label");
    
    // Resetear secuencia
    secuencias[indiceSecuencia].activa = false;
    secuencias[indiceSecuencia].tpAlcanzado = true;
    secuencias[indiceSecuencia].cerradaCompletamente = true;
    
    // Actualizar contador
    if(totalSecuencias > 0) totalSecuencias--;
    
    // Guardar estado
    GuardarEstadoSecuencias();
    
    // Restaurar configuración de trading
    trade.SetDeviationInPoints(10); // Restaurar valor por defecto
    trade.SetTypeFilling(ORDER_FILLING_FOK); // Restaurar filling por defecto
    
    // Actualizar interfaz
    ActualizarInformacionSecuencias();
    ChartRedraw();
    
    Print("✓ Secuencia #", secuencias[indiceSecuencia].id, " cerrada completamente");
    
    // Alerta si la diferencia es significativa
    if(MathAbs(gananciaNetaReal - gananciaObjetivo) > 0.05)
    {
        Print("⚠️ ADVERTENCIA: Diferencia significativa entre ganancia real y objetivo!");
        Print("   Considerar ajustar el precio virtual o reducir el slippage");
    }
}

//+------------------------------------------------------------------+
//| FUNCIÓN VERIFICADA: Cierre sincronizado virtual                 |
//| REEMPLAZA la función existente CerrarTodasLasPosicionesVirtual  |
//+------------------------------------------------------------------+
void CerrarTodasLasPosicionesVirtual(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // Obtener tick actual
    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick))
    {
        Print("? Error obteniendo tick actual");
        return;
    }
    
    Print("\n?????? EJECUTANDO CIERRE VIRTUAL ??????");
    Print("BID: ", tick.bid, " / ASK: ", tick.ask);
    
    // Calcular ganancia esperada en este momento
    double gananciaTotal = 0;
    double comisionTotal = 0;
    double swapTotal = 0;
    int numPosiciones = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double vol = PositionGetDouble(POSITION_VOLUME);
            double precio = PositionGetDouble(POSITION_PRICE_OPEN);
            ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            double ganancia;
            if(tipo == POSITION_TYPE_BUY)
            {
                ganancia = (tick.bid - precio) * vol * 100000;
            }
            else
            {
                ganancia = (precio - tick.ask) * vol * 100000;
            }
            
            gananciaTotal += ganancia;
            comisionTotal += CalcularComisionPepperstone(vol);
            swapTotal += PositionGetDouble(POSITION_SWAP);
            numPosiciones++;
        }
    }
    
    double gananciaNetaEsperada = gananciaTotal - comisionTotal + swapTotal;
    
    Print("?? Posiciones a cerrar: ", numPosiciones);
    Print("?? Ganancia neta esperada: €", DoubleToString(gananciaNetaEsperada, 2));
    
    // Configurar trade para cierre rápido
    CTrade tradeFast;
    tradeFast.SetAsyncMode(true);
    tradeFast.SetDeviationInPoints(50);
    
    // 1. Eliminar órdenes pendientes
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                tradeFast.OrderDelete(ticket);
            }
        }
    }
    
    // 2. Cerrar todas las posiciones
    int cierresExitosos = 0;
    
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                if(tradeFast.PositionClose(ticket))
                {
                    cierresExitosos++;
                }
            }
        }
    }
    
    Print("? Posiciones cerradas: ", cierresExitosos, " de ", numPosiciones);
    
    // Limpiar línea virtual
    string lineaId = "VirtualClose_" + IntegerToString(secuencias[indiceSecuencia].id);
    ObjectDelete(0, lineaId);
    ObjectDelete(0, lineaId + "_Label");
    
    // Marcar secuencia como inactiva
    secuencias[indiceSecuencia].activa = false;
    secuencias[indiceSecuencia].tpReubicado = false;
    totalSecuencias--;
    
    GuardarEstadoSecuencias();
    ChartRedraw();
    
    Print("?? CIERRE VIRTUAL COMPLETADO\n");
}

//+------------------------------------------------------------------+
//| Cerrar una secuencia                                             |
//+------------------------------------------------------------------+
void CerrarSecuencia(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string tipoSecuencia = secuencias[indice].esModoCompra ? "COMPRA" : "VENTA";
    Print("?? Cerrando secuencia #", secuencias[indice].id, " (", tipoSecuencia, ")");
    
    // Usar cierre rápido para acelerar el proceso
    CerrarSecuenciaVirtual(indice, true);
    
    // Si se logró cerrar completamente
    if(secuencias[indice].cerradaCompletamente)
    {
        secuencias[indice].activa = false;
        secuencias[indice].entradaPendienteActiva = false;
        totalSecuencias--;
        Print("?? Secuencia #", secuencias[indice].id, " (", tipoSecuencia, ") finalizada y marcada como inactiva");
    }
    else
    {
        // Si no se cerró completamente, mantener activa pero marcar TP
        secuencias[indice].tpAlcanzado = true;
        secuencias[indice].intentosCierre++;
        secuencias[indice].ultimoCierreIntentado = TimeCurrent();
        Print("?? Secuencia #", secuencias[indice].id, " pendiente de cierre completo - Intentos: ", secuencias[indice].intentosCierre);
    }
    // AGREGAR ESTA LÍNEA AL FINAL DE LA FUNCIÓN:
    LimpiarLineaCierreVirtual(indice);
}

//+------------------------------------------------------------------+
//| Verificar nuevas activaciones                                     |
//+------------------------------------------------------------------+
void VerificarNuevasActivaciones(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    bool ordenActivada = false;
    
    // Verificar posiciones abiertas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, comentarioBase) >= 0)
        {
            ordenActivada = true;
            break;
        }
    }
    
    // Verificar historial reciente si no se encontró en posiciones activas
    if(!ordenActivada)
    {
        datetime startTime = TimeCurrent() - 300; // 5 minutos
        if(HistorySelect(startTime, TimeCurrent()))
        {
            for(int i = 0; i < HistoryDealsTotal(); i++)
            {
                ulong dealTicket = HistoryDealGetTicket(i);
                if(!HistoryDealSelect(dealTicket)) continue;
                
                string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                if(StringFind(comentario, comentarioBase) >= 0)
                {
                    // Si es una operación de apertura
                    if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                    {
                        ordenActivada = true;
                        break;
                    }
                }
            }
        }
    }
    
    // Si se activó una orden y no hay TP alcanzado
    if(ordenActivada && !secuencias[indice].tpAlcanzado)
    {
        // Si es ENTRADA #2, marcar como inactiva para evitar recreaciones
        if(secuencias[indice].secuenciaActual == 2)
        {
            secuencias[indice].entradaPendienteActiva = false;
            Print("?? ENTRADA #2 activada - Secuencia #", secuencias[indice].id);
            
            // IMPORTANTE: Marcar que se debe verificar reubicación de TPs
            string textoNumReubicar = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
            if(textoNumReubicar == "2")
            {
                Print("?? ENTRADA #2 ACTIVADA - SE DEBE REUBICAR TPs");
            }
        }
        
        // CRÍTICO: Programar la siguiente entrada INMEDIATAMENTE
        Print("?? Activación detectada - Programando siguiente entrada");
        ProgramarSiguienteEntrada(indice);
    }
}

//+------------------------------------------------------------------+
//| Programar siguiente entrada manteniendo TPs originales          |
//+------------------------------------------------------------------+
void ProgramarSiguienteEntrada(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;

    // Verificar y limpiar duplicados si existen
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    if(tieneMultiples)
    {
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    double lotajeBase = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    
    secuencias[indice].secuenciaActual++;
    double lotaje = lotajeBase * MathPow(2, secuencias[indice].secuenciaActual - 1);

    // Validar lotaje máximo
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    if(lotaje > maxVolume)
    {
        lotaje = maxVolume;
    }

    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    ulong resultTicket = 0;
    
    // Verificar si ya existe
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, comentarioBase) == 0)
        {
            Print("?? Ya existe orden ", comentarioBase);
            return;
        }
    }
    
    bool esImpar = secuencias[indice].secuenciaActual % 2 == 1;
    
    // IMPORTANTE: Usar TPs individuales siempre (el cierre virtual se encarga del resto)
    double tpAUsar = 0;
    
    // Calcular TP basado en configuración original
    int tp1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
    int tp2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
    
    if(secuencias[indice].esModoCompra)
    {
        if(esImpar) // BUY STOP - usar TP E1
            tpAUsar = secuencias[indice].precioEntrada1 + (tp1Puntos * _Point);
        else // SELL STOP - usar TP E2
            tpAUsar = secuencias[indice].precioEntrada2 - (tp2Puntos * _Point);
    }
    else
    {
        if(esImpar) // SELL STOP - usar TP E1
            tpAUsar = secuencias[indice].precioEntrada1 - (tp1Puntos * _Point);
        else // BUY STOP - usar TP E2
            tpAUsar = secuencias[indice].precioEntrada2 + (tp2Puntos * _Point);
    }
    
    tpAUsar = NormalizeDouble(tpAUsar, _Digits);
    
    // Colocar la orden con TP individual
    if(secuencias[indice].esModoCompra)
    {
        if(esImpar)
        {
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando BUY STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
        else
        {
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando SELL STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
    }
    else
    {
        if(esImpar)
        {
            trade.SellStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando SELL STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
        else
        {
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, tpAUsar, ORDER_TIME_GTC, 0, comentarioBase);
            Print("?? Programando BUY STOP ", comentarioBase, " con TP individual: ", 
                  DoubleToString(tpAUsar, _Digits));
        }
    }
    
    resultTicket = trade.ResultOrder();
    
    if(resultTicket == 0)
    {
        int error = GetLastError();
        Print("? Error crítico al programar ", comentarioBase, ": ", error);
        
        // IMPORTANTE: Dar tiempo de seguridad adicional si falla
        secuencias[indice].ultimaVerificacionPendientes = TimeCurrent() + 30;
        return;
    }
    
    if(resultTicket > 0)
    {
        RegistrarOrden(indice, resultTicket, comentarioBase);
        Print("? ", comentarioBase, " programada exitosamente - Ticket: ", resultTicket, " - TP: ", DoubleToString(tpAUsar, _Digits));
        
        // Si está en modo cierre virtual, informar
        if(secuencias[indice].tpReubicado)
        {
            Print("?? Nota: Sistema de cierre virtual activo - Se cerrará TODO al alcanzar ganancia objetivo");
        }
        
        // CRÍTICO: Actualizar tiempo de verificación para evitar cierre prematuro
        secuencias[indice].ultimaVerificacionPendientes = TimeCurrent();
        
        GuardarEstadoSecuencias();
    }
}

//+------------------------------------------------------------------+
//| Función común para iniciar secuencia (compra o venta)            |
//+------------------------------------------------------------------+
void IniciarSecuencia(bool esCompra)
{
    double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    if(lotaje <= 0)
    {
        Alert("Lotaje inválido");
        return;
    }

    double minVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    lotaje = MathRound(lotaje / volumeStep) * volumeStep;
    
    if(lotaje < minVolume || lotaje > maxVolume)
    {
        Alert("Lotaje debe estar entre " + DoubleToString(minVolume, 2) + " y " + DoubleToString(maxVolume, 2));
        return;
    }

    int tp1 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
    int pipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
    int tp2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));

    if(tp1 <= 0 || pipsEntrada2 <= 0 || tp2 <= 0)
    {
        Alert("Valores de TP o PIPS inválidos");
        return;
    }

    // Encontrar un slot libre para la nueva secuencia
    int slotLibre = -1;
    for(int i = 0; i < 20; i++)
    {
        if(!secuencias[i].activa)
        {
            slotLibre = i;
            break;
        }
    }
    
    if(slotLibre == -1)
    {
        Alert("Error interno: No se encontró slot libre para la secuencia");
        return;
    }
    
    // Configurar la nueva secuencia
    secuencias[slotLibre].id = proximoIDSecuencia++;
    secuencias[slotLibre].activa = true;
    secuencias[slotLibre].secuenciaActual = 2;
    secuencias[slotLibre].tiempoInicio = TimeCurrent();
    secuencias[slotLibre].numOrdenes = 0;
    secuencias[slotLibre].tpAlcanzado = false;
    secuencias[slotLibre].ultimaVerificacionTP = 0;
    secuencias[slotLibre].cerradaCompletamente = false;
    secuencias[slotLibre].intentosCierre = 0;
    secuencias[slotLibre].ultimoCierreIntentado = 0;
    secuencias[slotLibre].esModoCompra = esCompra;
    secuencias[slotLibre].ticketEntrada1 = 0;
    secuencias[slotLibre].ticketEntrada2 = 0;
    secuencias[slotLibre].entradaPendienteActiva = true;
    secuencias[slotLibre].ultimaRecreacionPendiente = 0;
    secuencias[slotLibre].ultimaVerificacionPendientes = 0;
    secuencias[slotLibre].sinOrdenesPendientesDetectado = false;
    secuencias[slotLibre].tpReubicado = false;
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[slotLibre].id) + "_";
    string comentarioEnt1 = comentarioBase + "ENT1";
    string comentarioEnt2 = comentarioBase + "ENT2";
    ulong resultTicket = 0;
    
    if(esCompra)
    {
        // MODO COMPRA: ENTRADA #1 = BUY con TP E1 INDIVIDUAL
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (tp1 * _Point), _Digits);
        
        // IMPORTANTE: BUY con TP INDIVIDUAL basado en TP E1
        trade.Buy(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (BUY): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: SELL STOP con TP E2 INDIVIDUAL
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 - (tp2 * _Point), _Digits);
        
        trade.SellStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    else
    {
        // MODO VENTA: ENTRADA #1 = SELL con TP E1 INDIVIDUAL
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (tp1 * _Point), _Digits);
        
        // IMPORTANTE: SELL con TP INDIVIDUAL basado en TP E1
        trade.Sell(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (SELL): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: BUY STOP con TP E2 INDIVIDUAL
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 + (tp2 * _Point), _Digits);
        
        trade.BuyStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    
    if(resultTicket == 0)
    {
        Alert("Error al programar ENTRADA #2: ", GetLastError());
        CerrarSecuencia(slotLibre);
        return;
    }
    
    RegistrarOrden(slotLibre, resultTicket, comentarioEnt2);

    totalSecuencias++;
    string tipoSecuencia = esCompra ? "COMPRA" : "VENTA";
    Print("?? Nueva secuencia #", secuencias[slotLibre].id, " iniciada en modo ", tipoSecuencia, 
          " - ENTRADA #1 (TP:", DoubleToString(secuencias[slotLibre].tp1Precio, _Digits), 
          ") y #2 (TP:", DoubleToString(secuencias[slotLibre].tp2Precio, _Digits), ") programadas");
    
    GuardarEstadoSecuencias();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Si la interfaz no está creada, recrearla
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Monitorear cierre virtual
    MonitorearCierrePorGananciaObjetivo();
    
    // Verificar órdenes pendientes periódicamente
    VerificarOrdenesPendientes();
    
    // Verificar secuencias sin órdenes pendientes y cerrarlas
    VerificarCierrePorFaltaDePendientes();
    
    // Procesar cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(!secuencias[i].activa) continue;

        // Si ya se detectó TP, asegurarse de que todas las órdenes estén cerradas
        if(secuencias[i].tpAlcanzado)
        {
            // Reintentar cierre si no se ha cerrado completamente
            if(!secuencias[i].cerradaCompletamente)
            {
                // Limitar la frecuencia de reintentos a cada 1 segundo
                if(TimeCurrent() - secuencias[i].ultimoCierreIntentado >= 1)
                {
                    Print("?? Reintentando cierre para secuencia #", secuencias[i].id, 
                          " - Intento #", ++secuencias[i].intentosCierre);
                    secuencias[i].ultimoCierreIntentado = TimeCurrent();
                    
                    CerrarSecuenciaVirtual(i);
                    
                    // Si ya se intentó cerrar muchas veces, marcarla como cerrada de todos modos
                    if(secuencias[i].intentosCierre >= 5)
                    {
                        Print("?? Alcanzado máximo de intentos para secuencia #", secuencias[i].id, 
                              " - Marcando como cerrada");
                        secuencias[i].cerradaCompletamente = true;
                        secuencias[i].activa = false;
                        totalSecuencias--;
                    }
                }
            }
            continue;
        }
        
        // VERIFICACIÓN DE TP - cada tick para mayor precisión
        bool tpAlcanzado = false;
        
        // Verificar TPs en posiciones actuales
        for(int j = 0; j < PositionsTotal(); j++)
        {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Si es una posición de esta secuencia
            if(StringFind(comentario, secPrefix) == 0)
            {
                double tp = PositionGetDouble(POSITION_TP);
                if(tp == 0) continue;  // Omitir posiciones sin TP
                
                double precioActual = PositionGetDouble(POSITION_PRICE_CURRENT);
                ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                
                // Verificar si está muy cerca o ha superado el TP (3 puntos para ser más agresivo)
                if((tipo == POSITION_TYPE_BUY && precioActual >= tp - 3*_Point) ||
                   (tipo == POSITION_TYPE_SELL && precioActual <= tp + 3*_Point))
                {
                    tpAlcanzado = true;
                    Print("? TP alcanzado o cercano en posición #", ticket, " - Secuencia #", secuencias[i].id);
                    break;
                }
            }
        }
        
        // Verificar historial de operaciones recientes para ver si se cerró alguna por TP
        if(!tpAlcanzado)
        {
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            datetime startTime = TimeCurrent() - 120; // Buscar en los últimos 2 minutos
            if(HistorySelect(startTime, TimeCurrent()))
            {
                for(int k = 0; k < HistoryDealsTotal(); k++)
                {
                    ulong dealTicket = HistoryDealGetTicket(k);
                    if(!HistoryDealSelect(dealTicket)) continue;
                    
                    string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        // Verificar si es un cierre de posición
                        if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
                        {
                            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
                            ENUM_DEAL_REASON razon = (ENUM_DEAL_REASON)HistoryDealGetInteger(dealTicket, DEAL_REASON);
                            
                            // Si se cerró por TP o con beneficio
                            if(razon == DEAL_REASON_TP || profit > 0)
                            {
                                tpAlcanzado = true;
                                Print("? TP detectado en historial - Deal #", dealTicket, " - Secuencia #", secuencias[i].id);
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        // Si se alcanzó TP, cerrar toda la secuencia
        if(tpAlcanzado)
        {
            secuencias[i].tpAlcanzado = true;
            secuencias[i].ultimoCierreIntentado = TimeCurrent();
            string tipoSecuencia = secuencias[i].esModoCompra ? "COMPRA" : "VENTA";
            Print("?? TAKE PROFIT ALCANZADO - Secuencia #", secuencias[i].id, " (", tipoSecuencia, ") - CERRANDO TODAS LAS ÓRDENES");
            
            // Forzar cierre agresivo de todas las órdenes inmediatamente usando el modo rápido
            CerrarSecuenciaVirtual(i, true);
            CerrarSecuencia(i);
            
            // Actualizar el estado de las secuencias cuando se cierra una
            GuardarEstadoSecuencias();
            
            continue;
        }
        
        // PRIMERO: Si está en modo cierre virtual, monitorear constantemente
        if(secuencias[i].tpReubicado && !secuencias[i].tpAlcanzado)
        {
            MonitorearCierrePorGananciaObjetivo();
            
            // Si se cerró, continuar con la siguiente secuencia
            if(secuencias[i].tpAlcanzado || !secuencias[i].activa)
                continue;
        }
        
        // PRIMERO: Si está en modo cierre virtual, monitorear constantemente
         if(secuencias[i].tpReubicado && !secuencias[i].tpAlcanzado)
         {
         MonitorearCierrePorGananciaObjetivo();
    
         // Si se cerró, continuar con la siguiente secuencia
         if(secuencias[i].tpAlcanzado || !secuencias[i].activa)
         continue;
         }

         // AQUÍ: Verificar activación del sistema de cierre virtual
         ReubicarTPsParaGarantiaMinimaG(i);

        // Si no se alcanzó TP, verificar nuevas activaciones
        if(!secuencias[i].tpAlcanzado)
        {
            VerificarNuevasActivaciones(i);
        }
        
        // Verificar si se debe cerrar por número de entrada
        VerificarCierrePorNumeroEntrada(i);
        
        // Verificar si necesitamos recrear la orden pendiente de Entrada #2
        if(secuencias[i].entradaPendienteActiva && secuencias[i].secuenciaActual == 2)
        {
            RecrearOrdenEntrada2(i);
        }
    }
    
    // También buscar órdenes huérfanas (sin secuencia asociada)
    LimpiarOrdenesHuerfanas();
    
    LimpiarSecuenciasInactivas();
}

//+------------------------------------------------------------------+
//| FUNCIÓN NUEVA: Limpieza de secuencias inactivas                 |
//| AGREGAR al OnTick()                                             |
//+------------------------------------------------------------------+
void LimpiarSecuenciasInactivas()
{
    static datetime ultimaLimpieza = 0;
    
    if(TimeCurrent() - ultimaLimpieza < 10) return;
    ultimaLimpieza = TimeCurrent();
    
    int secuenciasLimpiadas = 0;
    
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            bool tieneActividad = false;
            
            // Verificar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    tieneActividad = true;
                    break;
                }
            }
            
            // Verificar órdenes
            if(!tieneActividad)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        tieneActividad = true;
                        break;
                    }
                }
            }
            
            // Limpiar si no hay actividad
            if(!tieneActividad)
            {
                Print("?? Limpiando secuencia fantasma #", secuencias[i].id);
                secuencias[i].activa = false;
                secuencias[i].tpReubicado = false;
                totalSecuencias--;
                secuenciasLimpiadas++;
                
                // Limpiar líneas
                string lineaId = "VirtualClose_" + IntegerToString(secuencias[i].id);
                ObjectDelete(0, lineaId);
                ObjectDelete(0, lineaId + "_Label");
            }
        }
    }
    
    if(secuenciasLimpiadas > 0)
    {
        GuardarEstadoSecuencias();
        ChartRedraw();
    }
}
